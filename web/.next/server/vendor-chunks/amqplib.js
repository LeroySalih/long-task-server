/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/amqplib";
exports.ids = ["vendor-chunks/amqplib"];
exports.modules = {

/***/ "(rsc)/./node_modules/amqplib/callback_api.js":
/*!**********************************************!*\
  !*** ./node_modules/amqplib/callback_api.js ***!
  \**********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var raw_connect = (__webpack_require__(/*! ./lib/connect */ \"(rsc)/./node_modules/amqplib/lib/connect.js\").connect);\nvar CallbackModel = (__webpack_require__(/*! ./lib/callback_model */ \"(rsc)/./node_modules/amqplib/lib/callback_model.js\").CallbackModel);\n\n// Supports three shapes:\n// connect(url, options, callback)\n// connect(url, callback)\n// connect(callback)\nfunction connect(url, options, cb) {\n  if (typeof url === 'function')\n    cb = url, url = false, options = false;\n  else if (typeof options === 'function')\n    cb = options, options = false;\n\n  raw_connect(url, options, function(err, c) {\n    if (err === null) cb(null, new CallbackModel(c));\n    else cb(err);\n  });\n};\n\nmodule.exports.connect = connect;\nmodule.exports.credentials = __webpack_require__(/*! ./lib/credentials */ \"(rsc)/./node_modules/amqplib/lib/credentials.js\");\nmodule.exports.IllegalOperationError = __webpack_require__(/*! ./lib/error */ \"(rsc)/./node_modules/amqplib/lib/error.js\").IllegalOperationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9jYWxsYmFja19hcGkuanMiLCJtYXBwaW5ncyI6IkFBQUEsa0JBQWtCLGlHQUFnQztBQUNsRCxvQkFBb0IscUhBQTZDOztBQUVqRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBLHNCQUFzQjtBQUN0Qiw0SEFBeUQ7QUFDekQsZ0pBQW1GIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMi8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2NhbGxiYWNrX2FwaS5qcz9kMDhkIl0sInNvdXJjZXNDb250ZW50IjpbInZhciByYXdfY29ubmVjdCA9IHJlcXVpcmUoJy4vbGliL2Nvbm5lY3QnKS5jb25uZWN0O1xudmFyIENhbGxiYWNrTW9kZWwgPSByZXF1aXJlKCcuL2xpYi9jYWxsYmFja19tb2RlbCcpLkNhbGxiYWNrTW9kZWw7XG5cbi8vIFN1cHBvcnRzIHRocmVlIHNoYXBlczpcbi8vIGNvbm5lY3QodXJsLCBvcHRpb25zLCBjYWxsYmFjaylcbi8vIGNvbm5lY3QodXJsLCBjYWxsYmFjaylcbi8vIGNvbm5lY3QoY2FsbGJhY2spXG5mdW5jdGlvbiBjb25uZWN0KHVybCwgb3B0aW9ucywgY2IpIHtcbiAgaWYgKHR5cGVvZiB1cmwgPT09ICdmdW5jdGlvbicpXG4gICAgY2IgPSB1cmwsIHVybCA9IGZhbHNlLCBvcHRpb25zID0gZmFsc2U7XG4gIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zID09PSAnZnVuY3Rpb24nKVxuICAgIGNiID0gb3B0aW9ucywgb3B0aW9ucyA9IGZhbHNlO1xuXG4gIHJhd19jb25uZWN0KHVybCwgb3B0aW9ucywgZnVuY3Rpb24oZXJyLCBjKSB7XG4gICAgaWYgKGVyciA9PT0gbnVsbCkgY2IobnVsbCwgbmV3IENhbGxiYWNrTW9kZWwoYykpO1xuICAgIGVsc2UgY2IoZXJyKTtcbiAgfSk7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5jb25uZWN0ID0gY29ubmVjdDtcbm1vZHVsZS5leHBvcnRzLmNyZWRlbnRpYWxzID0gcmVxdWlyZSgnLi9saWIvY3JlZGVudGlhbHMnKTtcbm1vZHVsZS5leHBvcnRzLklsbGVnYWxPcGVyYXRpb25FcnJvciA9IHJlcXVpcmUoJy4vbGliL2Vycm9yJykuSWxsZWdhbE9wZXJhdGlvbkVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/callback_api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/channel_api.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/channel_api.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var raw_connect = (__webpack_require__(/*! ./lib/connect */ \"(rsc)/./node_modules/amqplib/lib/connect.js\").connect);\nvar ChannelModel = (__webpack_require__(/*! ./lib/channel_model */ \"(rsc)/./node_modules/amqplib/lib/channel_model.js\").ChannelModel);\nvar promisify = (__webpack_require__(/*! util */ \"util\").promisify);\n\nfunction connect(url, connOptions) {\n  return promisify(function(cb) {\n    return raw_connect(url, connOptions, cb);\n  })()\n  .then(function(conn) {\n    return new ChannelModel(conn);\n  });\n};\n\nmodule.exports.connect = connect;\nmodule.exports.credentials = __webpack_require__(/*! ./lib/credentials */ \"(rsc)/./node_modules/amqplib/lib/credentials.js\");\nmodule.exports.IllegalOperationError = __webpack_require__(/*! ./lib/error */ \"(rsc)/./node_modules/amqplib/lib/error.js\").IllegalOperationError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9jaGFubmVsX2FwaS5qcyIsIm1hcHBpbmdzIjoiQUFBQSxrQkFBa0IsaUdBQWdDO0FBQ2xELG1CQUFtQixrSEFBMkM7QUFDOUQsZ0JBQWdCLG1EQUF5Qjs7QUFFekM7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7O0FBRUEsc0JBQXNCO0FBQ3RCLDRIQUF5RDtBQUN6RCxnSkFBbUYiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIyLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvY2hhbm5lbF9hcGkuanM/OTMzOCJdLCJzb3VyY2VzQ29udGVudCI6WyJ2YXIgcmF3X2Nvbm5lY3QgPSByZXF1aXJlKCcuL2xpYi9jb25uZWN0JykuY29ubmVjdDtcbnZhciBDaGFubmVsTW9kZWwgPSByZXF1aXJlKCcuL2xpYi9jaGFubmVsX21vZGVsJykuQ2hhbm5lbE1vZGVsO1xudmFyIHByb21pc2lmeSA9IHJlcXVpcmUoJ3V0aWwnKS5wcm9taXNpZnk7XG5cbmZ1bmN0aW9uIGNvbm5lY3QodXJsLCBjb25uT3B0aW9ucykge1xuICByZXR1cm4gcHJvbWlzaWZ5KGZ1bmN0aW9uKGNiKSB7XG4gICAgcmV0dXJuIHJhd19jb25uZWN0KHVybCwgY29ubk9wdGlvbnMsIGNiKTtcbiAgfSkoKVxuICAudGhlbihmdW5jdGlvbihjb25uKSB7XG4gICAgcmV0dXJuIG5ldyBDaGFubmVsTW9kZWwoY29ubik7XG4gIH0pO1xufTtcblxubW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IGNvbm5lY3Q7XG5tb2R1bGUuZXhwb3J0cy5jcmVkZW50aWFscyA9IHJlcXVpcmUoJy4vbGliL2NyZWRlbnRpYWxzJyk7XG5tb2R1bGUuZXhwb3J0cy5JbGxlZ2FsT3BlcmF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2xpYi9lcnJvcicpLklsbGVnYWxPcGVyYXRpb25FcnJvcjtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/channel_api.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/api_args.js":
/*!**********************************************!*\
  !*** ./node_modules/amqplib/lib/api_args.js ***!
  \**********************************************/
/***/ ((module) => {

"use strict";
eval("//\n//\n//\n\n\n\n/*\nThe channel (promise) and callback APIs have similar signatures, and\nin particular, both need AMQP fields prepared from the same arguments\nand options. The arguments marshalling is done here. Each of the\nprocedures below takes arguments and options (the latter in an object)\nparticular to the operation it represents, and returns an object with\nfields for handing to the encoder.\n*/\n\n// A number of AMQP methods have a table-typed field called\n// `arguments`, that is intended to carry extension-specific\n// values. RabbitMQ uses this in a number of places; e.g., to specify\n// an 'alternate exchange'.\n//\n// Many of the methods in this API have an `options` argument, from\n// which I take both values that have a default in AMQP (e.g.,\n// autoDelete in QueueDeclare) *and* values that are specific to\n// RabbitMQ (e.g., 'alternate-exchange'), which would normally be\n// supplied in `arguments`. So that extensions I don't support yet can\n// be used, I include `arguments` itself among the options.\n//\n// The upshot of this is that I often need to prepare an `arguments`\n// value that has any values passed in `options.arguments` as well as\n// any I've promoted to being options themselves. Since I don't want\n// to mutate anything passed in, the general pattern is to create a\n// fresh object with the `arguments` value given as its prototype; all\n// fields in the supplied value will be serialised, as well as any I\n// set on the fresh object. What I don't want to do, however, is set a\n// field to undefined by copying possibly missing field values,\n// because that will mask a value in the prototype.\n//\n// NB the `arguments` field already has a default value of `{}`, so\n// there's no need to explicitly default it unless I'm setting values.\nfunction setIfDefined(obj, prop, value) {\n  if (value != undefined) obj[prop] = value;\n}\n\nvar EMPTY_OPTIONS = Object.freeze({});\n\nvar Args = {};\n\nArgs.assertQueue = function(queue, options) {\n  queue = queue || '';\n  options = options || EMPTY_OPTIONS;\n\n  var argt = Object.create(options.arguments || null);\n  setIfDefined(argt, 'x-expires', options.expires);\n  setIfDefined(argt, 'x-message-ttl', options.messageTtl);\n  setIfDefined(argt, 'x-dead-letter-exchange',\n               options.deadLetterExchange);\n  setIfDefined(argt, 'x-dead-letter-routing-key',\n               options.deadLetterRoutingKey);\n  setIfDefined(argt, 'x-max-length', options.maxLength);\n  setIfDefined(argt, 'x-max-priority', options.maxPriority);\n  setIfDefined(argt, 'x-overflow', options.overflow);\n  setIfDefined(argt, 'x-queue-mode', options.queueMode);\n\n  return {\n    queue: queue,\n    exclusive: !!options.exclusive,\n    durable: (options.durable === undefined) ? true : options.durable,\n    autoDelete: !!options.autoDelete,\n    arguments: argt,\n    passive: false,\n    // deprecated but we have to include it\n    ticket: 0,\n    nowait: false\n  };\n};\n\nArgs.checkQueue = function(queue) {\n  return {\n    queue: queue,\n    passive: true, // switch to \"completely different\" mode\n    nowait: false,\n    durable: true, autoDelete: false, exclusive: false, // ignored\n    ticket: 0,\n  };\n};\n\nArgs.deleteQueue = function(queue, options) {\n  options = options || EMPTY_OPTIONS;\n  return {\n    queue: queue,\n    ifUnused: !!options.ifUnused,\n    ifEmpty: !!options.ifEmpty,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.purgeQueue = function(queue) {\n  return {\n    queue: queue,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.bindQueue = function(queue, source, pattern, argt) {\n  return {\n    queue: queue,\n    exchange: source,\n    routingKey: pattern,\n    arguments: argt,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.unbindQueue = function(queue, source, pattern, argt) {\n  return {\n    queue: queue,\n    exchange: source,\n    routingKey: pattern,\n    arguments: argt,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.assertExchange = function(exchange, type, options) {\n  options = options || EMPTY_OPTIONS;\n  var argt = Object.create(options.arguments || null);\n  setIfDefined(argt, 'alternate-exchange', options.alternateExchange);\n  return {\n    exchange: exchange,\n    ticket: 0,\n    type: type,\n    passive: false,\n    durable: (options.durable === undefined) ? true : options.durable,\n    autoDelete: !!options.autoDelete,\n    internal: !!options.internal,\n    nowait: false,\n    arguments: argt\n  };\n};\n\nArgs.checkExchange = function(exchange) {\n  return {\n    exchange: exchange,\n    passive: true, // switch to 'may as well be another method' mode\n    nowait: false,\n    // ff are ignored\n    durable: true, internal: false,  type: '',  autoDelete: false,\n    ticket: 0\n  };\n};\n\nArgs.deleteExchange = function(exchange, options) {\n  options = options || EMPTY_OPTIONS;\n  return {\n    exchange: exchange,\n    ifUnused: !!options.ifUnused,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.bindExchange = function(dest, source, pattern, argt) {\n  return {\n    source: source,\n    destination: dest,\n    routingKey: pattern,\n    arguments: argt,\n    ticket: 0, nowait: false\n  };\n};\n\nArgs.unbindExchange = function(dest, source, pattern, argt) {\n  return {\n    source: source,\n    destination: dest,\n    routingKey: pattern,\n    arguments: argt,\n    ticket: 0, nowait: false\n  };\n};\n\n// It's convenient to construct the properties and the method fields\n// at the same time, since in the APIs, values for both can appear in\n// `options`. Since the property or mthod field names don't overlap, I\n// just return one big object that can be used for both purposes, and\n// the encoder will pick out what it wants.\nArgs.publish = function(exchange, routingKey, options) {\n  options = options || EMPTY_OPTIONS;\n\n  // The CC and BCC fields expect an array of \"longstr\", which would\n  // normally be buffer values in JavaScript; however, since a field\n  // array (or table) cannot have shortstr values, the codec will\n  // encode all strings as longstrs anyway.\n  function convertCC(cc) {\n    if (cc === undefined) {\n      return undefined;\n    }\n    else if (Array.isArray(cc)) {\n      return cc.map(String);\n    }\n    else return [String(cc)];\n  }\n\n  var headers = Object.create(options.headers || null);\n  setIfDefined(headers, 'CC', convertCC(options.CC));\n  setIfDefined(headers, 'BCC', convertCC(options.BCC));\n\n  var deliveryMode; // undefined will default to 1 (non-persistent)\n\n  // Previously I overloaded deliveryMode be a boolean meaning\n  // 'persistent or not'; better is to name this option for what it\n  // is, but I need to have backwards compatibility for applications\n  // that either supply a numeric or boolean value.\n  if (options.persistent !== undefined)\n    deliveryMode = (options.persistent) ? 2 : 1;\n  else if (typeof options.deliveryMode === 'number')\n    deliveryMode = options.deliveryMode;\n  else if (options.deliveryMode) // is supplied and truthy\n    deliveryMode = 2;\n\n  var expiration = options.expiration;\n  if (expiration !== undefined) expiration = expiration.toString();\n\n  return {\n    // method fields\n    exchange: exchange,\n    routingKey: routingKey,\n    mandatory: !!options.mandatory,\n    immediate: false, // RabbitMQ doesn't implement this any more\n    ticket: undefined,\n    // properties\n    contentType: options.contentType,\n    contentEncoding: options.contentEncoding,\n    headers: headers,\n    deliveryMode: deliveryMode,\n    priority: options.priority,\n    correlationId: options.correlationId,\n    replyTo: options.replyTo,\n    expiration: expiration,\n    messageId: options.messageId,\n    timestamp: options.timestamp,\n    type: options.type,\n    userId: options.userId,\n    appId: options.appId,\n    clusterId: undefined\n  };\n};\n\nArgs.consume = function(queue, options) {\n  options = options || EMPTY_OPTIONS;\n  var argt = Object.create(options.arguments || null);\n  setIfDefined(argt, 'x-priority', options.priority);\n  return {\n    ticket: 0,\n    queue: queue,\n    consumerTag: options.consumerTag || '',\n    noLocal: !!options.noLocal,\n    noAck: !!options.noAck,\n    exclusive: !!options.exclusive,\n    nowait: false,\n    arguments: argt\n  };\n};\n\nArgs.cancel = function(consumerTag) {\n  return {\n    consumerTag: consumerTag,\n    nowait: false\n  };\n};\n\nArgs.get = function(queue, options) {\n  options = options || EMPTY_OPTIONS;\n  return {\n    ticket: 0,\n    queue: queue,\n    noAck: !!options.noAck\n  };\n};\n\nArgs.ack = function(tag, allUpTo) {\n  return {\n    deliveryTag: tag,\n    multiple: !!allUpTo\n  };\n};\n\nArgs.nack = function(tag, allUpTo, requeue) {\n  return {\n    deliveryTag: tag,\n    multiple: !!allUpTo,\n    requeue: (requeue === undefined) ? true : requeue\n  };\n};\n\nArgs.reject = function(tag, requeue) {\n  return {\n    deliveryTag: tag,\n    requeue: (requeue === undefined) ? true : requeue\n  };\n};\n\nArgs.prefetch = function(count, global) {\n  return {\n    prefetchCount: count || 0,\n    prefetchSize: 0,\n    global: !!global\n  };\n};\n\nArgs.recover = function() {\n  return {requeue: true};\n};\n\nmodule.exports = Object.freeze(Args);\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvYXBpX2FyZ3MuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHFEQUFxRDtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOERBQThEO0FBQzlEO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQzs7QUFFcEM7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjs7QUFFcEI7QUFDQSwwQkFBMEI7QUFDMUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFVBQVU7QUFDVjs7QUFFQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjIvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvYXBpX2FyZ3MuanM/MjA3NCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG5cbid1c2Ugc3RyaWN0JztcblxuLypcblRoZSBjaGFubmVsIChwcm9taXNlKSBhbmQgY2FsbGJhY2sgQVBJcyBoYXZlIHNpbWlsYXIgc2lnbmF0dXJlcywgYW5kXG5pbiBwYXJ0aWN1bGFyLCBib3RoIG5lZWQgQU1RUCBmaWVsZHMgcHJlcGFyZWQgZnJvbSB0aGUgc2FtZSBhcmd1bWVudHNcbmFuZCBvcHRpb25zLiBUaGUgYXJndW1lbnRzIG1hcnNoYWxsaW5nIGlzIGRvbmUgaGVyZS4gRWFjaCBvZiB0aGVcbnByb2NlZHVyZXMgYmVsb3cgdGFrZXMgYXJndW1lbnRzIGFuZCBvcHRpb25zICh0aGUgbGF0dGVyIGluIGFuIG9iamVjdClcbnBhcnRpY3VsYXIgdG8gdGhlIG9wZXJhdGlvbiBpdCByZXByZXNlbnRzLCBhbmQgcmV0dXJucyBhbiBvYmplY3Qgd2l0aFxuZmllbGRzIGZvciBoYW5kaW5nIHRvIHRoZSBlbmNvZGVyLlxuKi9cblxuLy8gQSBudW1iZXIgb2YgQU1RUCBtZXRob2RzIGhhdmUgYSB0YWJsZS10eXBlZCBmaWVsZCBjYWxsZWRcbi8vIGBhcmd1bWVudHNgLCB0aGF0IGlzIGludGVuZGVkIHRvIGNhcnJ5IGV4dGVuc2lvbi1zcGVjaWZpY1xuLy8gdmFsdWVzLiBSYWJiaXRNUSB1c2VzIHRoaXMgaW4gYSBudW1iZXIgb2YgcGxhY2VzOyBlLmcuLCB0byBzcGVjaWZ5XG4vLyBhbiAnYWx0ZXJuYXRlIGV4Y2hhbmdlJy5cbi8vXG4vLyBNYW55IG9mIHRoZSBtZXRob2RzIGluIHRoaXMgQVBJIGhhdmUgYW4gYG9wdGlvbnNgIGFyZ3VtZW50LCBmcm9tXG4vLyB3aGljaCBJIHRha2UgYm90aCB2YWx1ZXMgdGhhdCBoYXZlIGEgZGVmYXVsdCBpbiBBTVFQIChlLmcuLFxuLy8gYXV0b0RlbGV0ZSBpbiBRdWV1ZURlY2xhcmUpICphbmQqIHZhbHVlcyB0aGF0IGFyZSBzcGVjaWZpYyB0b1xuLy8gUmFiYml0TVEgKGUuZy4sICdhbHRlcm5hdGUtZXhjaGFuZ2UnKSwgd2hpY2ggd291bGQgbm9ybWFsbHkgYmVcbi8vIHN1cHBsaWVkIGluIGBhcmd1bWVudHNgLiBTbyB0aGF0IGV4dGVuc2lvbnMgSSBkb24ndCBzdXBwb3J0IHlldCBjYW5cbi8vIGJlIHVzZWQsIEkgaW5jbHVkZSBgYXJndW1lbnRzYCBpdHNlbGYgYW1vbmcgdGhlIG9wdGlvbnMuXG4vL1xuLy8gVGhlIHVwc2hvdCBvZiB0aGlzIGlzIHRoYXQgSSBvZnRlbiBuZWVkIHRvIHByZXBhcmUgYW4gYGFyZ3VtZW50c2Bcbi8vIHZhbHVlIHRoYXQgaGFzIGFueSB2YWx1ZXMgcGFzc2VkIGluIGBvcHRpb25zLmFyZ3VtZW50c2AgYXMgd2VsbCBhc1xuLy8gYW55IEkndmUgcHJvbW90ZWQgdG8gYmVpbmcgb3B0aW9ucyB0aGVtc2VsdmVzLiBTaW5jZSBJIGRvbid0IHdhbnRcbi8vIHRvIG11dGF0ZSBhbnl0aGluZyBwYXNzZWQgaW4sIHRoZSBnZW5lcmFsIHBhdHRlcm4gaXMgdG8gY3JlYXRlIGFcbi8vIGZyZXNoIG9iamVjdCB3aXRoIHRoZSBgYXJndW1lbnRzYCB2YWx1ZSBnaXZlbiBhcyBpdHMgcHJvdG90eXBlOyBhbGxcbi8vIGZpZWxkcyBpbiB0aGUgc3VwcGxpZWQgdmFsdWUgd2lsbCBiZSBzZXJpYWxpc2VkLCBhcyB3ZWxsIGFzIGFueSBJXG4vLyBzZXQgb24gdGhlIGZyZXNoIG9iamVjdC4gV2hhdCBJIGRvbid0IHdhbnQgdG8gZG8sIGhvd2V2ZXIsIGlzIHNldCBhXG4vLyBmaWVsZCB0byB1bmRlZmluZWQgYnkgY29weWluZyBwb3NzaWJseSBtaXNzaW5nIGZpZWxkIHZhbHVlcyxcbi8vIGJlY2F1c2UgdGhhdCB3aWxsIG1hc2sgYSB2YWx1ZSBpbiB0aGUgcHJvdG90eXBlLlxuLy9cbi8vIE5CIHRoZSBgYXJndW1lbnRzYCBmaWVsZCBhbHJlYWR5IGhhcyBhIGRlZmF1bHQgdmFsdWUgb2YgYHt9YCwgc29cbi8vIHRoZXJlJ3Mgbm8gbmVlZCB0byBleHBsaWNpdGx5IGRlZmF1bHQgaXQgdW5sZXNzIEknbSBzZXR0aW5nIHZhbHVlcy5cbmZ1bmN0aW9uIHNldElmRGVmaW5lZChvYmosIHByb3AsIHZhbHVlKSB7XG4gIGlmICh2YWx1ZSAhPSB1bmRlZmluZWQpIG9ialtwcm9wXSA9IHZhbHVlO1xufVxuXG52YXIgRU1QVFlfT1BUSU9OUyA9IE9iamVjdC5mcmVlemUoe30pO1xuXG52YXIgQXJncyA9IHt9O1xuXG5BcmdzLmFzc2VydFF1ZXVlID0gZnVuY3Rpb24ocXVldWUsIG9wdGlvbnMpIHtcbiAgcXVldWUgPSBxdWV1ZSB8fCAnJztcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcblxuICB2YXIgYXJndCA9IE9iamVjdC5jcmVhdGUob3B0aW9ucy5hcmd1bWVudHMgfHwgbnVsbCk7XG4gIHNldElmRGVmaW5lZChhcmd0LCAneC1leHBpcmVzJywgb3B0aW9ucy5leHBpcmVzKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LW1lc3NhZ2UtdHRsJywgb3B0aW9ucy5tZXNzYWdlVHRsKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LWRlYWQtbGV0dGVyLWV4Y2hhbmdlJyxcbiAgICAgICAgICAgICAgIG9wdGlvbnMuZGVhZExldHRlckV4Y2hhbmdlKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LWRlYWQtbGV0dGVyLXJvdXRpbmcta2V5JyxcbiAgICAgICAgICAgICAgIG9wdGlvbnMuZGVhZExldHRlclJvdXRpbmdLZXkpO1xuICBzZXRJZkRlZmluZWQoYXJndCwgJ3gtbWF4LWxlbmd0aCcsIG9wdGlvbnMubWF4TGVuZ3RoKTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LW1heC1wcmlvcml0eScsIG9wdGlvbnMubWF4UHJpb3JpdHkpO1xuICBzZXRJZkRlZmluZWQoYXJndCwgJ3gtb3ZlcmZsb3cnLCBvcHRpb25zLm92ZXJmbG93KTtcbiAgc2V0SWZEZWZpbmVkKGFyZ3QsICd4LXF1ZXVlLW1vZGUnLCBvcHRpb25zLnF1ZXVlTW9kZSk7XG5cbiAgcmV0dXJuIHtcbiAgICBxdWV1ZTogcXVldWUsXG4gICAgZXhjbHVzaXZlOiAhIW9wdGlvbnMuZXhjbHVzaXZlLFxuICAgIGR1cmFibGU6IChvcHRpb25zLmR1cmFibGUgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogb3B0aW9ucy5kdXJhYmxlLFxuICAgIGF1dG9EZWxldGU6ICEhb3B0aW9ucy5hdXRvRGVsZXRlLFxuICAgIGFyZ3VtZW50czogYXJndCxcbiAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICAvLyBkZXByZWNhdGVkIGJ1dCB3ZSBoYXZlIHRvIGluY2x1ZGUgaXRcbiAgICB0aWNrZXQ6IDAsXG4gICAgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuQXJncy5jaGVja1F1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgcmV0dXJuIHtcbiAgICBxdWV1ZTogcXVldWUsXG4gICAgcGFzc2l2ZTogdHJ1ZSwgLy8gc3dpdGNoIHRvIFwiY29tcGxldGVseSBkaWZmZXJlbnRcIiBtb2RlXG4gICAgbm93YWl0OiBmYWxzZSxcbiAgICBkdXJhYmxlOiB0cnVlLCBhdXRvRGVsZXRlOiBmYWxzZSwgZXhjbHVzaXZlOiBmYWxzZSwgLy8gaWdub3JlZFxuICAgIHRpY2tldDogMCxcbiAgfTtcbn07XG5cbkFyZ3MuZGVsZXRlUXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgb3B0aW9ucykge1xuICBvcHRpb25zID0gb3B0aW9ucyB8fCBFTVBUWV9PUFRJT05TO1xuICByZXR1cm4ge1xuICAgIHF1ZXVlOiBxdWV1ZSxcbiAgICBpZlVudXNlZDogISFvcHRpb25zLmlmVW51c2VkLFxuICAgIGlmRW1wdHk6ICEhb3B0aW9ucy5pZkVtcHR5LFxuICAgIHRpY2tldDogMCwgbm93YWl0OiBmYWxzZVxuICB9O1xufTtcblxuQXJncy5wdXJnZVF1ZXVlID0gZnVuY3Rpb24ocXVldWUpIHtcbiAgcmV0dXJuIHtcbiAgICBxdWV1ZTogcXVldWUsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLmJpbmRRdWV1ZSA9IGZ1bmN0aW9uKHF1ZXVlLCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpIHtcbiAgcmV0dXJuIHtcbiAgICBxdWV1ZTogcXVldWUsXG4gICAgZXhjaGFuZ2U6IHNvdXJjZSxcbiAgICByb3V0aW5nS2V5OiBwYXR0ZXJuLFxuICAgIGFyZ3VtZW50czogYXJndCxcbiAgICB0aWNrZXQ6IDAsIG5vd2FpdDogZmFsc2VcbiAgfTtcbn07XG5cbkFyZ3MudW5iaW5kUXVldWUgPSBmdW5jdGlvbihxdWV1ZSwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gIHJldHVybiB7XG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIGV4Y2hhbmdlOiBzb3VyY2UsXG4gICAgcm91dGluZ0tleTogcGF0dGVybixcbiAgICBhcmd1bWVudHM6IGFyZ3QsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLmFzc2VydEV4Y2hhbmdlID0gZnVuY3Rpb24oZXhjaGFuZ2UsIHR5cGUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcbiAgdmFyIGFyZ3QgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMuYXJndW1lbnRzIHx8IG51bGwpO1xuICBzZXRJZkRlZmluZWQoYXJndCwgJ2FsdGVybmF0ZS1leGNoYW5nZScsIG9wdGlvbnMuYWx0ZXJuYXRlRXhjaGFuZ2UpO1xuICByZXR1cm4ge1xuICAgIGV4Y2hhbmdlOiBleGNoYW5nZSxcbiAgICB0aWNrZXQ6IDAsXG4gICAgdHlwZTogdHlwZSxcbiAgICBwYXNzaXZlOiBmYWxzZSxcbiAgICBkdXJhYmxlOiAob3B0aW9ucy5kdXJhYmxlID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IG9wdGlvbnMuZHVyYWJsZSxcbiAgICBhdXRvRGVsZXRlOiAhIW9wdGlvbnMuYXV0b0RlbGV0ZSxcbiAgICBpbnRlcm5hbDogISFvcHRpb25zLmludGVybmFsLFxuICAgIG5vd2FpdDogZmFsc2UsXG4gICAgYXJndW1lbnRzOiBhcmd0XG4gIH07XG59O1xuXG5BcmdzLmNoZWNrRXhjaGFuZ2UgPSBmdW5jdGlvbihleGNoYW5nZSkge1xuICByZXR1cm4ge1xuICAgIGV4Y2hhbmdlOiBleGNoYW5nZSxcbiAgICBwYXNzaXZlOiB0cnVlLCAvLyBzd2l0Y2ggdG8gJ21heSBhcyB3ZWxsIGJlIGFub3RoZXIgbWV0aG9kJyBtb2RlXG4gICAgbm93YWl0OiBmYWxzZSxcbiAgICAvLyBmZiBhcmUgaWdub3JlZFxuICAgIGR1cmFibGU6IHRydWUsIGludGVybmFsOiBmYWxzZSwgIHR5cGU6ICcnLCAgYXV0b0RlbGV0ZTogZmFsc2UsXG4gICAgdGlja2V0OiAwXG4gIH07XG59O1xuXG5BcmdzLmRlbGV0ZUV4Y2hhbmdlID0gZnVuY3Rpb24oZXhjaGFuZ2UsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcbiAgcmV0dXJuIHtcbiAgICBleGNoYW5nZTogZXhjaGFuZ2UsXG4gICAgaWZVbnVzZWQ6ICEhb3B0aW9ucy5pZlVudXNlZCxcbiAgICB0aWNrZXQ6IDAsIG5vd2FpdDogZmFsc2VcbiAgfTtcbn07XG5cbkFyZ3MuYmluZEV4Y2hhbmdlID0gZnVuY3Rpb24oZGVzdCwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gIHJldHVybiB7XG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgZGVzdGluYXRpb246IGRlc3QsXG4gICAgcm91dGluZ0tleTogcGF0dGVybixcbiAgICBhcmd1bWVudHM6IGFyZ3QsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG5BcmdzLnVuYmluZEV4Y2hhbmdlID0gZnVuY3Rpb24oZGVzdCwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gIHJldHVybiB7XG4gICAgc291cmNlOiBzb3VyY2UsXG4gICAgZGVzdGluYXRpb246IGRlc3QsXG4gICAgcm91dGluZ0tleTogcGF0dGVybixcbiAgICBhcmd1bWVudHM6IGFyZ3QsXG4gICAgdGlja2V0OiAwLCBub3dhaXQ6IGZhbHNlXG4gIH07XG59O1xuXG4vLyBJdCdzIGNvbnZlbmllbnQgdG8gY29uc3RydWN0IHRoZSBwcm9wZXJ0aWVzIGFuZCB0aGUgbWV0aG9kIGZpZWxkc1xuLy8gYXQgdGhlIHNhbWUgdGltZSwgc2luY2UgaW4gdGhlIEFQSXMsIHZhbHVlcyBmb3IgYm90aCBjYW4gYXBwZWFyIGluXG4vLyBgb3B0aW9uc2AuIFNpbmNlIHRoZSBwcm9wZXJ0eSBvciBtdGhvZCBmaWVsZCBuYW1lcyBkb24ndCBvdmVybGFwLCBJXG4vLyBqdXN0IHJldHVybiBvbmUgYmlnIG9iamVjdCB0aGF0IGNhbiBiZSB1c2VkIGZvciBib3RoIHB1cnBvc2VzLCBhbmRcbi8vIHRoZSBlbmNvZGVyIHdpbGwgcGljayBvdXQgd2hhdCBpdCB3YW50cy5cbkFyZ3MucHVibGlzaCA9IGZ1bmN0aW9uKGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSBvcHRpb25zIHx8IEVNUFRZX09QVElPTlM7XG5cbiAgLy8gVGhlIENDIGFuZCBCQ0MgZmllbGRzIGV4cGVjdCBhbiBhcnJheSBvZiBcImxvbmdzdHJcIiwgd2hpY2ggd291bGRcbiAgLy8gbm9ybWFsbHkgYmUgYnVmZmVyIHZhbHVlcyBpbiBKYXZhU2NyaXB0OyBob3dldmVyLCBzaW5jZSBhIGZpZWxkXG4gIC8vIGFycmF5IChvciB0YWJsZSkgY2Fubm90IGhhdmUgc2hvcnRzdHIgdmFsdWVzLCB0aGUgY29kZWMgd2lsbFxuICAvLyBlbmNvZGUgYWxsIHN0cmluZ3MgYXMgbG9uZ3N0cnMgYW55d2F5LlxuICBmdW5jdGlvbiBjb252ZXJ0Q0MoY2MpIHtcbiAgICBpZiAoY2MgPT09IHVuZGVmaW5lZCkge1xuICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcbiAgICB9XG4gICAgZWxzZSBpZiAoQXJyYXkuaXNBcnJheShjYykpIHtcbiAgICAgIHJldHVybiBjYy5tYXAoU3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSByZXR1cm4gW1N0cmluZyhjYyldO1xuICB9XG5cbiAgdmFyIGhlYWRlcnMgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMuaGVhZGVycyB8fCBudWxsKTtcbiAgc2V0SWZEZWZpbmVkKGhlYWRlcnMsICdDQycsIGNvbnZlcnRDQyhvcHRpb25zLkNDKSk7XG4gIHNldElmRGVmaW5lZChoZWFkZXJzLCAnQkNDJywgY29udmVydENDKG9wdGlvbnMuQkNDKSk7XG5cbiAgdmFyIGRlbGl2ZXJ5TW9kZTsgLy8gdW5kZWZpbmVkIHdpbGwgZGVmYXVsdCB0byAxIChub24tcGVyc2lzdGVudClcblxuICAvLyBQcmV2aW91c2x5IEkgb3ZlcmxvYWRlZCBkZWxpdmVyeU1vZGUgYmUgYSBib29sZWFuIG1lYW5pbmdcbiAgLy8gJ3BlcnNpc3RlbnQgb3Igbm90JzsgYmV0dGVyIGlzIHRvIG5hbWUgdGhpcyBvcHRpb24gZm9yIHdoYXQgaXRcbiAgLy8gaXMsIGJ1dCBJIG5lZWQgdG8gaGF2ZSBiYWNrd2FyZHMgY29tcGF0aWJpbGl0eSBmb3IgYXBwbGljYXRpb25zXG4gIC8vIHRoYXQgZWl0aGVyIHN1cHBseSBhIG51bWVyaWMgb3IgYm9vbGVhbiB2YWx1ZS5cbiAgaWYgKG9wdGlvbnMucGVyc2lzdGVudCAhPT0gdW5kZWZpbmVkKVxuICAgIGRlbGl2ZXJ5TW9kZSA9IChvcHRpb25zLnBlcnNpc3RlbnQpID8gMiA6IDE7XG4gIGVsc2UgaWYgKHR5cGVvZiBvcHRpb25zLmRlbGl2ZXJ5TW9kZSA9PT0gJ251bWJlcicpXG4gICAgZGVsaXZlcnlNb2RlID0gb3B0aW9ucy5kZWxpdmVyeU1vZGU7XG4gIGVsc2UgaWYgKG9wdGlvbnMuZGVsaXZlcnlNb2RlKSAvLyBpcyBzdXBwbGllZCBhbmQgdHJ1dGh5XG4gICAgZGVsaXZlcnlNb2RlID0gMjtcblxuICB2YXIgZXhwaXJhdGlvbiA9IG9wdGlvbnMuZXhwaXJhdGlvbjtcbiAgaWYgKGV4cGlyYXRpb24gIT09IHVuZGVmaW5lZCkgZXhwaXJhdGlvbiA9IGV4cGlyYXRpb24udG9TdHJpbmcoKTtcblxuICByZXR1cm4ge1xuICAgIC8vIG1ldGhvZCBmaWVsZHNcbiAgICBleGNoYW5nZTogZXhjaGFuZ2UsXG4gICAgcm91dGluZ0tleTogcm91dGluZ0tleSxcbiAgICBtYW5kYXRvcnk6ICEhb3B0aW9ucy5tYW5kYXRvcnksXG4gICAgaW1tZWRpYXRlOiBmYWxzZSwgLy8gUmFiYml0TVEgZG9lc24ndCBpbXBsZW1lbnQgdGhpcyBhbnkgbW9yZVxuICAgIHRpY2tldDogdW5kZWZpbmVkLFxuICAgIC8vIHByb3BlcnRpZXNcbiAgICBjb250ZW50VHlwZTogb3B0aW9ucy5jb250ZW50VHlwZSxcbiAgICBjb250ZW50RW5jb2Rpbmc6IG9wdGlvbnMuY29udGVudEVuY29kaW5nLFxuICAgIGhlYWRlcnM6IGhlYWRlcnMsXG4gICAgZGVsaXZlcnlNb2RlOiBkZWxpdmVyeU1vZGUsXG4gICAgcHJpb3JpdHk6IG9wdGlvbnMucHJpb3JpdHksXG4gICAgY29ycmVsYXRpb25JZDogb3B0aW9ucy5jb3JyZWxhdGlvbklkLFxuICAgIHJlcGx5VG86IG9wdGlvbnMucmVwbHlUbyxcbiAgICBleHBpcmF0aW9uOiBleHBpcmF0aW9uLFxuICAgIG1lc3NhZ2VJZDogb3B0aW9ucy5tZXNzYWdlSWQsXG4gICAgdGltZXN0YW1wOiBvcHRpb25zLnRpbWVzdGFtcCxcbiAgICB0eXBlOiBvcHRpb25zLnR5cGUsXG4gICAgdXNlcklkOiBvcHRpb25zLnVzZXJJZCxcbiAgICBhcHBJZDogb3B0aW9ucy5hcHBJZCxcbiAgICBjbHVzdGVySWQ6IHVuZGVmaW5lZFxuICB9O1xufTtcblxuQXJncy5jb25zdW1lID0gZnVuY3Rpb24ocXVldWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcbiAgdmFyIGFyZ3QgPSBPYmplY3QuY3JlYXRlKG9wdGlvbnMuYXJndW1lbnRzIHx8IG51bGwpO1xuICBzZXRJZkRlZmluZWQoYXJndCwgJ3gtcHJpb3JpdHknLCBvcHRpb25zLnByaW9yaXR5KTtcbiAgcmV0dXJuIHtcbiAgICB0aWNrZXQ6IDAsXG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIGNvbnN1bWVyVGFnOiBvcHRpb25zLmNvbnN1bWVyVGFnIHx8ICcnLFxuICAgIG5vTG9jYWw6ICEhb3B0aW9ucy5ub0xvY2FsLFxuICAgIG5vQWNrOiAhIW9wdGlvbnMubm9BY2ssXG4gICAgZXhjbHVzaXZlOiAhIW9wdGlvbnMuZXhjbHVzaXZlLFxuICAgIG5vd2FpdDogZmFsc2UsXG4gICAgYXJndW1lbnRzOiBhcmd0XG4gIH07XG59O1xuXG5BcmdzLmNhbmNlbCA9IGZ1bmN0aW9uKGNvbnN1bWVyVGFnKSB7XG4gIHJldHVybiB7XG4gICAgY29uc3VtZXJUYWc6IGNvbnN1bWVyVGFnLFxuICAgIG5vd2FpdDogZmFsc2VcbiAgfTtcbn07XG5cbkFyZ3MuZ2V0ID0gZnVuY3Rpb24ocXVldWUsIG9wdGlvbnMpIHtcbiAgb3B0aW9ucyA9IG9wdGlvbnMgfHwgRU1QVFlfT1BUSU9OUztcbiAgcmV0dXJuIHtcbiAgICB0aWNrZXQ6IDAsXG4gICAgcXVldWU6IHF1ZXVlLFxuICAgIG5vQWNrOiAhIW9wdGlvbnMubm9BY2tcbiAgfTtcbn07XG5cbkFyZ3MuYWNrID0gZnVuY3Rpb24odGFnLCBhbGxVcFRvKSB7XG4gIHJldHVybiB7XG4gICAgZGVsaXZlcnlUYWc6IHRhZyxcbiAgICBtdWx0aXBsZTogISFhbGxVcFRvXG4gIH07XG59O1xuXG5BcmdzLm5hY2sgPSBmdW5jdGlvbih0YWcsIGFsbFVwVG8sIHJlcXVldWUpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWxpdmVyeVRhZzogdGFnLFxuICAgIG11bHRpcGxlOiAhIWFsbFVwVG8sXG4gICAgcmVxdWV1ZTogKHJlcXVldWUgPT09IHVuZGVmaW5lZCkgPyB0cnVlIDogcmVxdWV1ZVxuICB9O1xufTtcblxuQXJncy5yZWplY3QgPSBmdW5jdGlvbih0YWcsIHJlcXVldWUpIHtcbiAgcmV0dXJuIHtcbiAgICBkZWxpdmVyeVRhZzogdGFnLFxuICAgIHJlcXVldWU6IChyZXF1ZXVlID09PSB1bmRlZmluZWQpID8gdHJ1ZSA6IHJlcXVldWVcbiAgfTtcbn07XG5cbkFyZ3MucHJlZmV0Y2ggPSBmdW5jdGlvbihjb3VudCwgZ2xvYmFsKSB7XG4gIHJldHVybiB7XG4gICAgcHJlZmV0Y2hDb3VudDogY291bnQgfHwgMCxcbiAgICBwcmVmZXRjaFNpemU6IDAsXG4gICAgZ2xvYmFsOiAhIWdsb2JhbFxuICB9O1xufTtcblxuQXJncy5yZWNvdmVyID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB7cmVxdWV1ZTogdHJ1ZX07XG59O1xuXG5tb2R1bGUuZXhwb3J0cyA9IE9iamVjdC5mcmVlemUoQXJncyk7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/api_args.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/bitset.js":
/*!********************************************!*\
  !*** ./node_modules/amqplib/lib/bitset.js ***!
  \********************************************/
/***/ ((module) => {

"use strict";
eval("//\n//\n//\n\n\n\n/**\n * A bitset implementation, after that in java.util.  Yes there\n * already exist such things, but none implement next{Clear|Set}Bit or\n * equivalent, and none involved me tooling about for an evening.\n */\nclass BitSet {\n  /**\n   * @param {number} [size]\n   */\n  constructor(size) {\n    if (size) {\n      const numWords = Math.ceil(size / 32);\n      this.words = new Array(numWords);\n    }\n    else {\n      this.words = [];\n    }\n    this.wordsInUse = 0; // = number, not index\n  }\n\n  /**\n   * @param {number} numWords\n   */\n  ensureSize(numWords) {\n    const wordsPresent = this.words.length;\n    if (wordsPresent < numWords) {\n      this.words = this.words.concat(new Array(numWords - wordsPresent));\n    }\n  }\n\n  /**\n   * @param {number} bitIndex\n   */\n  set(bitIndex) {\n    const w = wordIndex(bitIndex);\n    if (w >= this.wordsInUse) {\n      this.ensureSize(w + 1);\n      this.wordsInUse = w + 1;\n    }\n    const bit = 1 << bitIndex;\n    this.words[w] |= bit;\n  }\n\n  /**\n   * @param {number} bitIndex\n   */\n  clear(bitIndex) {\n    const w = wordIndex(bitIndex);\n    if (w >= this.wordsInUse) return;\n    const mask = ~(1 << bitIndex);\n    this.words[w] &= mask;\n  }\n\n  /**\n   * @param {number} bitIndex\n   */\n  get(bitIndex) {\n    const w = wordIndex(bitIndex);\n    if (w >= this.wordsInUse) return false; // >= since index vs size\n    const bit = 1 << bitIndex;\n    return !!(this.words[w] & bit);\n  }\n\n  /**\n   * Give the next bit that is set on or after fromIndex, or -1 if no such bit\n   *\n   * @param {number} fromIndex\n   */\n  nextSetBit(fromIndex) {\n    let w = wordIndex(fromIndex);\n    if (w >= this.wordsInUse) return -1;\n\n    // the right-hand side is shifted to only test the bits of the first\n    // word that are > fromIndex\n    let word = this.words[w] & (0xffffffff << fromIndex);\n    while (true) {\n      if (word) return (w * 32) + trailingZeros(word);\n      w++;\n      if (w === this.wordsInUse) return -1;\n      word = this.words[w];\n    }\n  }\n\n  /**\n   * @param {number} fromIndex\n   */\n  nextClearBit(fromIndex) {\n    let w = wordIndex(fromIndex);\n    if (w >= this.wordsInUse) return fromIndex;\n\n    let word = ~(this.words[w]) & (0xffffffff << fromIndex);\n    while (true) {\n      if (word) return (w * 32) + trailingZeros(word);\n      w++;\n      if (w == this.wordsInUse) return w * 32;\n      word = ~(this.words[w]);\n    }\n  }\n}\n\n/**\n * @param {number} bitIndex\n */\nfunction wordIndex(bitIndex) {\n  return Math.floor(bitIndex / 32);\n}\n\n/**\n * @param {number} i\n */\nfunction trailingZeros(i) {\n  // From Hacker's Delight, via JDK. Probably far less effective here,\n  // since bit ops are not necessarily the quick way to do things in\n  // JS.\n  if (i === 0) return 32;\n  let y, n = 31;\n  y = i << 16; if (y != 0) { n = n -16; i = y; }\n  y = i << 8;  if (y != 0) { n = n - 8; i = y; }\n  y = i << 4;  if (y != 0) { n = n - 4; i = y; }\n  y = i << 2;  if (y != 0) { n = n - 2; i = y; }\n  return n - ((i << 1) >>> 31);\n}\n\nmodule.exports.BitSet = BitSet;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvYml0c2V0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0Esc0RBQXNELFVBQVU7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBLDRDQUE0QztBQUM1QztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsYUFBYSxRQUFRO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFdBQVcsUUFBUTtBQUNuQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGVBQWUsY0FBYyxXQUFXO0FBQ3hDLGVBQWUsY0FBYyxXQUFXO0FBQ3hDLGVBQWUsY0FBYyxXQUFXO0FBQ3hDLGVBQWUsY0FBYyxXQUFXO0FBQ3hDO0FBQ0E7O0FBRUEscUJBQXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMi8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9iaXRzZXQuanM/MjI4YiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG5cbid1c2Ugc3RyaWN0JztcblxuLyoqXG4gKiBBIGJpdHNldCBpbXBsZW1lbnRhdGlvbiwgYWZ0ZXIgdGhhdCBpbiBqYXZhLnV0aWwuICBZZXMgdGhlcmVcbiAqIGFscmVhZHkgZXhpc3Qgc3VjaCB0aGluZ3MsIGJ1dCBub25lIGltcGxlbWVudCBuZXh0e0NsZWFyfFNldH1CaXQgb3JcbiAqIGVxdWl2YWxlbnQsIGFuZCBub25lIGludm9sdmVkIG1lIHRvb2xpbmcgYWJvdXQgZm9yIGFuIGV2ZW5pbmcuXG4gKi9cbmNsYXNzIEJpdFNldCB7XG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gW3NpemVdXG4gICAqL1xuICBjb25zdHJ1Y3RvcihzaXplKSB7XG4gICAgaWYgKHNpemUpIHtcbiAgICAgIGNvbnN0IG51bVdvcmRzID0gTWF0aC5jZWlsKHNpemUgLyAzMik7XG4gICAgICB0aGlzLndvcmRzID0gbmV3IEFycmF5KG51bVdvcmRzKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB0aGlzLndvcmRzID0gW107XG4gICAgfVxuICAgIHRoaXMud29yZHNJblVzZSA9IDA7IC8vID0gbnVtYmVyLCBub3QgaW5kZXhcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gbnVtV29yZHNcbiAgICovXG4gIGVuc3VyZVNpemUobnVtV29yZHMpIHtcbiAgICBjb25zdCB3b3Jkc1ByZXNlbnQgPSB0aGlzLndvcmRzLmxlbmd0aDtcbiAgICBpZiAod29yZHNQcmVzZW50IDwgbnVtV29yZHMpIHtcbiAgICAgIHRoaXMud29yZHMgPSB0aGlzLndvcmRzLmNvbmNhdChuZXcgQXJyYXkobnVtV29yZHMgLSB3b3Jkc1ByZXNlbnQpKTtcbiAgICB9XG4gIH1cblxuICAvKipcbiAgICogQHBhcmFtIHtudW1iZXJ9IGJpdEluZGV4XG4gICAqL1xuICBzZXQoYml0SW5kZXgpIHtcbiAgICBjb25zdCB3ID0gd29yZEluZGV4KGJpdEluZGV4KTtcbiAgICBpZiAodyA+PSB0aGlzLndvcmRzSW5Vc2UpIHtcbiAgICAgIHRoaXMuZW5zdXJlU2l6ZSh3ICsgMSk7XG4gICAgICB0aGlzLndvcmRzSW5Vc2UgPSB3ICsgMTtcbiAgICB9XG4gICAgY29uc3QgYml0ID0gMSA8PCBiaXRJbmRleDtcbiAgICB0aGlzLndvcmRzW3ddIHw9IGJpdDtcbiAgfVxuXG4gIC8qKlxuICAgKiBAcGFyYW0ge251bWJlcn0gYml0SW5kZXhcbiAgICovXG4gIGNsZWFyKGJpdEluZGV4KSB7XG4gICAgY29uc3QgdyA9IHdvcmRJbmRleChiaXRJbmRleCk7XG4gICAgaWYgKHcgPj0gdGhpcy53b3Jkc0luVXNlKSByZXR1cm47XG4gICAgY29uc3QgbWFzayA9IH4oMSA8PCBiaXRJbmRleCk7XG4gICAgdGhpcy53b3Jkc1t3XSAmPSBtYXNrO1xuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBiaXRJbmRleFxuICAgKi9cbiAgZ2V0KGJpdEluZGV4KSB7XG4gICAgY29uc3QgdyA9IHdvcmRJbmRleChiaXRJbmRleCk7XG4gICAgaWYgKHcgPj0gdGhpcy53b3Jkc0luVXNlKSByZXR1cm4gZmFsc2U7IC8vID49IHNpbmNlIGluZGV4IHZzIHNpemVcbiAgICBjb25zdCBiaXQgPSAxIDw8IGJpdEluZGV4O1xuICAgIHJldHVybiAhISh0aGlzLndvcmRzW3ddICYgYml0KTtcbiAgfVxuXG4gIC8qKlxuICAgKiBHaXZlIHRoZSBuZXh0IGJpdCB0aGF0IGlzIHNldCBvbiBvciBhZnRlciBmcm9tSW5kZXgsIG9yIC0xIGlmIG5vIHN1Y2ggYml0XG4gICAqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXhcbiAgICovXG4gIG5leHRTZXRCaXQoZnJvbUluZGV4KSB7XG4gICAgbGV0IHcgPSB3b3JkSW5kZXgoZnJvbUluZGV4KTtcbiAgICBpZiAodyA+PSB0aGlzLndvcmRzSW5Vc2UpIHJldHVybiAtMTtcblxuICAgIC8vIHRoZSByaWdodC1oYW5kIHNpZGUgaXMgc2hpZnRlZCB0byBvbmx5IHRlc3QgdGhlIGJpdHMgb2YgdGhlIGZpcnN0XG4gICAgLy8gd29yZCB0aGF0IGFyZSA+IGZyb21JbmRleFxuICAgIGxldCB3b3JkID0gdGhpcy53b3Jkc1t3XSAmICgweGZmZmZmZmZmIDw8IGZyb21JbmRleCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh3b3JkKSByZXR1cm4gKHcgKiAzMikgKyB0cmFpbGluZ1plcm9zKHdvcmQpO1xuICAgICAgdysrO1xuICAgICAgaWYgKHcgPT09IHRoaXMud29yZHNJblVzZSkgcmV0dXJuIC0xO1xuICAgICAgd29yZCA9IHRoaXMud29yZHNbd107XG4gICAgfVxuICB9XG5cbiAgLyoqXG4gICAqIEBwYXJhbSB7bnVtYmVyfSBmcm9tSW5kZXhcbiAgICovXG4gIG5leHRDbGVhckJpdChmcm9tSW5kZXgpIHtcbiAgICBsZXQgdyA9IHdvcmRJbmRleChmcm9tSW5kZXgpO1xuICAgIGlmICh3ID49IHRoaXMud29yZHNJblVzZSkgcmV0dXJuIGZyb21JbmRleDtcblxuICAgIGxldCB3b3JkID0gfih0aGlzLndvcmRzW3ddKSAmICgweGZmZmZmZmZmIDw8IGZyb21JbmRleCk7XG4gICAgd2hpbGUgKHRydWUpIHtcbiAgICAgIGlmICh3b3JkKSByZXR1cm4gKHcgKiAzMikgKyB0cmFpbGluZ1plcm9zKHdvcmQpO1xuICAgICAgdysrO1xuICAgICAgaWYgKHcgPT0gdGhpcy53b3Jkc0luVXNlKSByZXR1cm4gdyAqIDMyO1xuICAgICAgd29yZCA9IH4odGhpcy53b3Jkc1t3XSk7XG4gICAgfVxuICB9XG59XG5cbi8qKlxuICogQHBhcmFtIHtudW1iZXJ9IGJpdEluZGV4XG4gKi9cbmZ1bmN0aW9uIHdvcmRJbmRleChiaXRJbmRleCkge1xuICByZXR1cm4gTWF0aC5mbG9vcihiaXRJbmRleCAvIDMyKTtcbn1cblxuLyoqXG4gKiBAcGFyYW0ge251bWJlcn0gaVxuICovXG5mdW5jdGlvbiB0cmFpbGluZ1plcm9zKGkpIHtcbiAgLy8gRnJvbSBIYWNrZXIncyBEZWxpZ2h0LCB2aWEgSkRLLiBQcm9iYWJseSBmYXIgbGVzcyBlZmZlY3RpdmUgaGVyZSxcbiAgLy8gc2luY2UgYml0IG9wcyBhcmUgbm90IG5lY2Vzc2FyaWx5IHRoZSBxdWljayB3YXkgdG8gZG8gdGhpbmdzIGluXG4gIC8vIEpTLlxuICBpZiAoaSA9PT0gMCkgcmV0dXJuIDMyO1xuICBsZXQgeSwgbiA9IDMxO1xuICB5ID0gaSA8PCAxNjsgaWYgKHkgIT0gMCkgeyBuID0gbiAtMTY7IGkgPSB5OyB9XG4gIHkgPSBpIDw8IDg7ICBpZiAoeSAhPSAwKSB7IG4gPSBuIC0gODsgaSA9IHk7IH1cbiAgeSA9IGkgPDwgNDsgIGlmICh5ICE9IDApIHsgbiA9IG4gLSA0OyBpID0geTsgfVxuICB5ID0gaSA8PCAyOyAgaWYgKHkgIT0gMCkgeyBuID0gbiAtIDI7IGkgPSB5OyB9XG4gIHJldHVybiBuIC0gKChpIDw8IDEpID4+PiAzMSk7XG59XG5cbm1vZHVsZS5leHBvcnRzLkJpdFNldCA9IEJpdFNldDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/bitset.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/callback_model.js":
/*!****************************************************!*\
  !*** ./node_modules/amqplib/lib/callback_model.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("//\n//\n//\n\n\n\nvar defs = __webpack_require__(/*! ./defs */ \"(rsc)/./node_modules/amqplib/lib/defs.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\");\nvar BaseChannel = (__webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/amqplib/lib/channel.js\").BaseChannel);\nvar acceptMessage = (__webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/amqplib/lib/channel.js\").acceptMessage);\nvar Args = __webpack_require__(/*! ./api_args */ \"(rsc)/./node_modules/amqplib/lib/api_args.js\");\n\nclass CallbackModel extends EventEmitter {\n  constructor (connection) {\n    super();\n    this.connection = connection;\n    var self = this;\n    ['error', 'close', 'blocked', 'unblocked'].forEach(function (ev) {\n      connection.on(ev, self.emit.bind(self, ev));\n    });\n  }\n\n  close (cb) {\n    this.connection.close(cb);\n  }\n\n  updateSecret(newSecret, reason, cb) {\n    this.connection._updateSecret(newSecret, reason, cb);\n  }\n\n  createChannel (cb) {\n    var ch = new Channel(this.connection);\n    ch.open(function (err, ok) {\n      if (err === null)\n        cb && cb(null, ch);\n      else\n        cb && cb(err);\n    });\n    return ch;\n  }\n\n  createConfirmChannel (cb) {\n    var ch = new ConfirmChannel(this.connection);\n    ch.open(function (err) {\n      if (err !== null)\n        return cb && cb(err);\n      else {\n        ch.rpc(defs.ConfirmSelect, { nowait: false },\n          defs.ConfirmSelectOk, function (err, _ok) {\n            if (err !== null)\n              return cb && cb(err);\n            else\n              cb && cb(null, ch);\n          });\n      }\n    });\n    return ch;\n  }\n}\n\nclass Channel extends BaseChannel {\n  constructor (connection) {\n    super(connection);\n    this.on('delivery', this.handleDelivery.bind(this));\n    this.on('cancel', this.handleCancel.bind(this));\n  }\n\n  // This encodes straight-forward RPC: no side-effects and return the\n  // fields from the server response. It wraps the callback given it, so\n  // the calling method argument can be passed as-is. For anything that\n  // needs to have side-effects, or needs to change the server response,\n  // use `#_rpc(...)` and remember to dereference `.fields` of the\n  // server response.\n  rpc (method, fields, expect, cb0) {\n    var cb = callbackWrapper(this, cb0);\n    this._rpc(method, fields, expect, function (err, ok) {\n      cb(err, ok && ok.fields); // in case of an error, ok will be\n\n      // undefined\n    });\n    return this;\n  }\n\n  // === Public API ===\n  open (cb) {\n    try { this.allocate(); }\n    catch (e) { return cb(e); }\n\n    return this.rpc(defs.ChannelOpen, { outOfBand: \"\" },\n      defs.ChannelOpenOk, cb);\n  }\n\n  close (cb) {\n    return this.closeBecause(\"Goodbye\", defs.constants.REPLY_SUCCESS,\n      function () { cb && cb(null); });\n  }\n\n  assertQueue (queue, options, cb) {\n    return this.rpc(defs.QueueDeclare,\n      Args.assertQueue(queue, options),\n      defs.QueueDeclareOk, cb);\n  }\n\n  checkQueue (queue, cb) {\n    return this.rpc(defs.QueueDeclare,\n      Args.checkQueue(queue),\n      defs.QueueDeclareOk, cb);\n  }\n\n  deleteQueue (queue, options, cb) {\n    return this.rpc(defs.QueueDelete,\n      Args.deleteQueue(queue, options),\n      defs.QueueDeleteOk, cb);\n  }\n\n  purgeQueue (queue, cb) {\n    return this.rpc(defs.QueuePurge,\n      Args.purgeQueue(queue),\n      defs.QueuePurgeOk, cb);\n  }\n\n  bindQueue (queue, source, pattern, argt, cb) {\n    return this.rpc(defs.QueueBind,\n      Args.bindQueue(queue, source, pattern, argt),\n      defs.QueueBindOk, cb);\n  }\n\n  unbindQueue (queue, source, pattern, argt, cb) {\n    return this.rpc(defs.QueueUnbind,\n      Args.unbindQueue(queue, source, pattern, argt),\n      defs.QueueUnbindOk, cb);\n  }\n\n  assertExchange (ex, type, options, cb0) {\n    var cb = callbackWrapper(this, cb0);\n    this._rpc(defs.ExchangeDeclare,\n      Args.assertExchange(ex, type, options),\n      defs.ExchangeDeclareOk,\n      function (e, _) { cb(e, { exchange: ex }); });\n    return this;\n  }\n\n  checkExchange (exchange, cb) {\n    return this.rpc(defs.ExchangeDeclare,\n      Args.checkExchange(exchange),\n      defs.ExchangeDeclareOk, cb);\n  }\n\n  deleteExchange (exchange, options, cb) {\n    return this.rpc(defs.ExchangeDelete,\n      Args.deleteExchange(exchange, options),\n      defs.ExchangeDeleteOk, cb);\n  }\n\n  bindExchange (dest, source, pattern, argt, cb) {\n    return this.rpc(defs.ExchangeBind,\n      Args.bindExchange(dest, source, pattern, argt),\n      defs.ExchangeBindOk, cb);\n  }\n\n  unbindExchange (dest, source, pattern, argt, cb) {\n    return this.rpc(defs.ExchangeUnbind,\n      Args.unbindExchange(dest, source, pattern, argt),\n      defs.ExchangeUnbindOk, cb);\n  }\n\n  publish (exchange, routingKey, content, options) {\n    var fieldsAndProps = Args.publish(exchange, routingKey, options);\n    return this.sendMessage(fieldsAndProps, fieldsAndProps, content);\n  }\n\n  sendToQueue (queue, content, options) {\n    return this.publish('', queue, content, options);\n  }\n\n  consume (queue, callback, options, cb0) {\n    var cb = callbackWrapper(this, cb0);\n    var fields = Args.consume(queue, options);\n    var self = this;\n    this._rpc(\n      defs.BasicConsume, fields, defs.BasicConsumeOk,\n      function (err, ok) {\n        if (err === null) {\n          self.registerConsumer(ok.fields.consumerTag, callback);\n          cb(null, ok.fields);\n        }\n        else\n          cb(err);\n      });\n    return this;\n  }\n\n  cancel (consumerTag, cb0) {\n    var cb = callbackWrapper(this, cb0);\n    var self = this;\n    this._rpc(\n      defs.BasicCancel, Args.cancel(consumerTag), defs.BasicCancelOk,\n      function (err, ok) {\n        if (err === null) {\n          self.unregisterConsumer(consumerTag);\n          cb(null, ok.fields);\n        }\n        else\n          cb(err);\n      });\n    return this;\n  }\n\n  get (queue, options, cb0) {\n    var self = this;\n    var fields = Args.get(queue, options);\n    var cb = callbackWrapper(this, cb0);\n    this.sendOrEnqueue(defs.BasicGet, fields, function (err, f) {\n      if (err === null) {\n        if (f.id === defs.BasicGetEmpty) {\n          cb(null, false);\n        }\n        else if (f.id === defs.BasicGetOk) {\n          self.handleMessage = acceptMessage(function (m) {\n            m.fields = f.fields;\n            cb(null, m);\n          });\n        }\n        else {\n          cb(new Error(\"Unexpected response to BasicGet: \" +\n            inspect(f)));\n        }\n      }\n    });\n    return this;\n  }\n\n  ack (message, allUpTo) {\n    this.sendImmediately(\n      defs.BasicAck, Args.ack(message.fields.deliveryTag, allUpTo));\n    return this;\n  }\n\n  ackAll () {\n    this.sendImmediately(defs.BasicAck, Args.ack(0, true));\n    return this;\n  }\n\n  nack (message, allUpTo, requeue) {\n    this.sendImmediately(\n      defs.BasicNack,\n      Args.nack(message.fields.deliveryTag, allUpTo, requeue));\n    return this;\n  }\n\n  nackAll (requeue) {\n    this.sendImmediately(\n      defs.BasicNack, Args.nack(0, true, requeue));\n    return this;\n  }\n\n  reject (message, requeue) {\n    this.sendImmediately(\n      defs.BasicReject,\n      Args.reject(message.fields.deliveryTag, requeue));\n    return this;\n  }\n\n  prefetch (count, global, cb) {\n    return this.rpc(defs.BasicQos,\n      Args.prefetch(count, global),\n      defs.BasicQosOk, cb);\n  }\n\n  recover (cb) {\n    return this.rpc(defs.BasicRecover,\n      Args.recover(),\n      defs.BasicRecoverOk, cb);\n  }\n}\n\n\n// Wrap an RPC callback to make sure the callback is invoked with\n// either `(null, value)` or `(error)`, i.e., never two non-null\n// values. Also substitutes a stub if the callback is `undefined` or\n// otherwise falsey, for convenience in methods for which the callback\n// is optional (that is, most of them).\nfunction callbackWrapper(ch, cb) {\n  return (cb) ? function(err, ok) {\n    if (err === null) {\n      cb(null, ok);\n    }\n    else cb(err);\n  } : function() {};\n}\n\nclass ConfirmChannel extends Channel {\n  publish (exchange, routingKey,\n    content, options, cb) {\n    this.pushConfirmCallback(cb);\n    return Channel.prototype.publish.call(\n      this, exchange, routingKey, content, options);\n  }\n\n  sendToQueue (queue, content,\n    options, cb) {\n    return this.publish('', queue, content, options, cb);\n  }\n\n  waitForConfirms (k) {\n    var awaiting = [];\n    var unconfirmed = this.unconfirmed;\n    unconfirmed.forEach(function (val, index) {\n      if (val === null)\n        ; // already confirmed\n      else {\n        var confirmed = new Promise(function (resolve, reject) {\n          unconfirmed[index] = function (err) {\n            if (val)\n              val(err);\n            if (err === null)\n              resolve();\n            else\n              reject(err);\n          };\n        });\n        awaiting.push(confirmed);\n      }\n    });\n    return Promise.all(awaiting).then(function () { k(); },\n      function (err) { k(err); });\n  }\n}\n\nmodule.exports.CallbackModel = CallbackModel;\nmodule.exports.Channel = Channel;\nmodule.exports.ConfirmChannel = ConfirmChannel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY2FsbGJhY2tfbW9kZWwuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyx3REFBUTtBQUMzQixtQkFBbUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxrQkFBa0IsaUdBQWdDO0FBQ2xELG9CQUFvQixtR0FBa0M7QUFDdEQsV0FBVyxtQkFBTyxDQUFDLGdFQUFZOztBQUUvQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDLGVBQWU7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQzs7QUFFaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsVUFBVTtBQUNWLGdCQUFnQjs7QUFFaEIsd0NBQXdDLGVBQWU7QUFDdkQ7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLFFBQVEsY0FBYyxJQUFJO0FBQ2xEO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVc7QUFDWDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsVUFBVTtBQUNWO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxLQUFLO0FBQ0wsb0RBQW9ELE1BQU07QUFDMUQsdUJBQXVCLFNBQVM7QUFDaEM7QUFDQTs7QUFFQSw0QkFBNEI7QUFDNUIsc0JBQXNCO0FBQ3RCLDZCQUE2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjIvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY2FsbGJhY2tfbW9kZWwuanM/YTNhOSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGRlZnMgPSByZXF1aXJlKCcuL2RlZnMnKTtcbnZhciBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbnZhciBCYXNlQ2hhbm5lbCA9IHJlcXVpcmUoJy4vY2hhbm5lbCcpLkJhc2VDaGFubmVsO1xudmFyIGFjY2VwdE1lc3NhZ2UgPSByZXF1aXJlKCcuL2NoYW5uZWwnKS5hY2NlcHRNZXNzYWdlO1xudmFyIEFyZ3MgPSByZXF1aXJlKCcuL2FwaV9hcmdzJyk7XG5cbmNsYXNzIENhbGxiYWNrTW9kZWwgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoY29ubmVjdGlvbikge1xuICAgIHN1cGVyKCk7XG4gICAgdGhpcy5jb25uZWN0aW9uID0gY29ubmVjdGlvbjtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgWydlcnJvcicsICdjbG9zZScsICdibG9ja2VkJywgJ3VuYmxvY2tlZCddLmZvckVhY2goZnVuY3Rpb24gKGV2KSB7XG4gICAgICBjb25uZWN0aW9uLm9uKGV2LCBzZWxmLmVtaXQuYmluZChzZWxmLCBldikpO1xuICAgIH0pO1xuICB9XG5cbiAgY2xvc2UgKGNiKSB7XG4gICAgdGhpcy5jb25uZWN0aW9uLmNsb3NlKGNiKTtcbiAgfVxuXG4gIHVwZGF0ZVNlY3JldChuZXdTZWNyZXQsIHJlYXNvbiwgY2IpIHtcbiAgICB0aGlzLmNvbm5lY3Rpb24uX3VwZGF0ZVNlY3JldChuZXdTZWNyZXQsIHJlYXNvbiwgY2IpO1xuICB9XG5cbiAgY3JlYXRlQ2hhbm5lbCAoY2IpIHtcbiAgICB2YXIgY2ggPSBuZXcgQ2hhbm5lbCh0aGlzLmNvbm5lY3Rpb24pO1xuICAgIGNoLm9wZW4oZnVuY3Rpb24gKGVyciwgb2spIHtcbiAgICAgIGlmIChlcnIgPT09IG51bGwpXG4gICAgICAgIGNiICYmIGNiKG51bGwsIGNoKTtcbiAgICAgIGVsc2VcbiAgICAgICAgY2IgJiYgY2IoZXJyKTtcbiAgICB9KTtcbiAgICByZXR1cm4gY2g7XG4gIH1cblxuICBjcmVhdGVDb25maXJtQ2hhbm5lbCAoY2IpIHtcbiAgICB2YXIgY2ggPSBuZXcgQ29uZmlybUNoYW5uZWwodGhpcy5jb25uZWN0aW9uKTtcbiAgICBjaC5vcGVuKGZ1bmN0aW9uIChlcnIpIHtcbiAgICAgIGlmIChlcnIgIT09IG51bGwpXG4gICAgICAgIHJldHVybiBjYiAmJiBjYihlcnIpO1xuICAgICAgZWxzZSB7XG4gICAgICAgIGNoLnJwYyhkZWZzLkNvbmZpcm1TZWxlY3QsIHsgbm93YWl0OiBmYWxzZSB9LFxuICAgICAgICAgIGRlZnMuQ29uZmlybVNlbGVjdE9rLCBmdW5jdGlvbiAoZXJyLCBfb2spIHtcbiAgICAgICAgICAgIGlmIChlcnIgIT09IG51bGwpXG4gICAgICAgICAgICAgIHJldHVybiBjYiAmJiBjYihlcnIpO1xuICAgICAgICAgICAgZWxzZVxuICAgICAgICAgICAgICBjYiAmJiBjYihudWxsLCBjaCk7XG4gICAgICAgICAgfSk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIGNoO1xuICB9XG59XG5cbmNsYXNzIENoYW5uZWwgZXh0ZW5kcyBCYXNlQ2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yIChjb25uZWN0aW9uKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbik7XG4gICAgdGhpcy5vbignZGVsaXZlcnknLCB0aGlzLmhhbmRsZURlbGl2ZXJ5LmJpbmQodGhpcykpO1xuICAgIHRoaXMub24oJ2NhbmNlbCcsIHRoaXMuaGFuZGxlQ2FuY2VsLmJpbmQodGhpcykpO1xuICB9XG5cbiAgLy8gVGhpcyBlbmNvZGVzIHN0cmFpZ2h0LWZvcndhcmQgUlBDOiBubyBzaWRlLWVmZmVjdHMgYW5kIHJldHVybiB0aGVcbiAgLy8gZmllbGRzIGZyb20gdGhlIHNlcnZlciByZXNwb25zZS4gSXQgd3JhcHMgdGhlIGNhbGxiYWNrIGdpdmVuIGl0LCBzb1xuICAvLyB0aGUgY2FsbGluZyBtZXRob2QgYXJndW1lbnQgY2FuIGJlIHBhc3NlZCBhcy1pcy4gRm9yIGFueXRoaW5nIHRoYXRcbiAgLy8gbmVlZHMgdG8gaGF2ZSBzaWRlLWVmZmVjdHMsIG9yIG5lZWRzIHRvIGNoYW5nZSB0aGUgc2VydmVyIHJlc3BvbnNlLFxuICAvLyB1c2UgYCNfcnBjKC4uLilgIGFuZCByZW1lbWJlciB0byBkZXJlZmVyZW5jZSBgLmZpZWxkc2Agb2YgdGhlXG4gIC8vIHNlcnZlciByZXNwb25zZS5cbiAgcnBjIChtZXRob2QsIGZpZWxkcywgZXhwZWN0LCBjYjApIHtcbiAgICB2YXIgY2IgPSBjYWxsYmFja1dyYXBwZXIodGhpcywgY2IwKTtcbiAgICB0aGlzLl9ycGMobWV0aG9kLCBmaWVsZHMsIGV4cGVjdCwgZnVuY3Rpb24gKGVyciwgb2spIHtcbiAgICAgIGNiKGVyciwgb2sgJiYgb2suZmllbGRzKTsgLy8gaW4gY2FzZSBvZiBhbiBlcnJvciwgb2sgd2lsbCBiZVxuXG4gICAgICAvLyB1bmRlZmluZWRcbiAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIC8vID09PSBQdWJsaWMgQVBJID09PVxuICBvcGVuIChjYikge1xuICAgIHRyeSB7IHRoaXMuYWxsb2NhdGUoKTsgfVxuICAgIGNhdGNoIChlKSB7IHJldHVybiBjYihlKTsgfVxuXG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuQ2hhbm5lbE9wZW4sIHsgb3V0T2ZCYW5kOiBcIlwiIH0sXG4gICAgICBkZWZzLkNoYW5uZWxPcGVuT2ssIGNiKTtcbiAgfVxuXG4gIGNsb3NlIChjYikge1xuICAgIHJldHVybiB0aGlzLmNsb3NlQmVjYXVzZShcIkdvb2RieWVcIiwgZGVmcy5jb25zdGFudHMuUkVQTFlfU1VDQ0VTUyxcbiAgICAgIGZ1bmN0aW9uICgpIHsgY2IgJiYgY2IobnVsbCk7IH0pO1xuICB9XG5cbiAgYXNzZXJ0UXVldWUgKHF1ZXVlLCBvcHRpb25zLCBjYikge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLlF1ZXVlRGVjbGFyZSxcbiAgICAgIEFyZ3MuYXNzZXJ0UXVldWUocXVldWUsIG9wdGlvbnMpLFxuICAgICAgZGVmcy5RdWV1ZURlY2xhcmVPaywgY2IpO1xuICB9XG5cbiAgY2hlY2tRdWV1ZSAocXVldWUsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuUXVldWVEZWNsYXJlLFxuICAgICAgQXJncy5jaGVja1F1ZXVlKHF1ZXVlKSxcbiAgICAgIGRlZnMuUXVldWVEZWNsYXJlT2ssIGNiKTtcbiAgfVxuXG4gIGRlbGV0ZVF1ZXVlIChxdWV1ZSwgb3B0aW9ucywgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5RdWV1ZURlbGV0ZSxcbiAgICAgIEFyZ3MuZGVsZXRlUXVldWUocXVldWUsIG9wdGlvbnMpLFxuICAgICAgZGVmcy5RdWV1ZURlbGV0ZU9rLCBjYik7XG4gIH1cblxuICBwdXJnZVF1ZXVlIChxdWV1ZSwgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5RdWV1ZVB1cmdlLFxuICAgICAgQXJncy5wdXJnZVF1ZXVlKHF1ZXVlKSxcbiAgICAgIGRlZnMuUXVldWVQdXJnZU9rLCBjYik7XG4gIH1cblxuICBiaW5kUXVldWUgKHF1ZXVlLCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuUXVldWVCaW5kLFxuICAgICAgQXJncy5iaW5kUXVldWUocXVldWUsIHNvdXJjZSwgcGF0dGVybiwgYXJndCksXG4gICAgICBkZWZzLlF1ZXVlQmluZE9rLCBjYik7XG4gIH1cblxuICB1bmJpbmRRdWV1ZSAocXVldWUsIHNvdXJjZSwgcGF0dGVybiwgYXJndCwgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5RdWV1ZVVuYmluZCxcbiAgICAgIEFyZ3MudW5iaW5kUXVldWUocXVldWUsIHNvdXJjZSwgcGF0dGVybiwgYXJndCksXG4gICAgICBkZWZzLlF1ZXVlVW5iaW5kT2ssIGNiKTtcbiAgfVxuXG4gIGFzc2VydEV4Y2hhbmdlIChleCwgdHlwZSwgb3B0aW9ucywgY2IwKSB7XG4gICAgdmFyIGNiID0gY2FsbGJhY2tXcmFwcGVyKHRoaXMsIGNiMCk7XG4gICAgdGhpcy5fcnBjKGRlZnMuRXhjaGFuZ2VEZWNsYXJlLFxuICAgICAgQXJncy5hc3NlcnRFeGNoYW5nZShleCwgdHlwZSwgb3B0aW9ucyksXG4gICAgICBkZWZzLkV4Y2hhbmdlRGVjbGFyZU9rLFxuICAgICAgZnVuY3Rpb24gKGUsIF8pIHsgY2IoZSwgeyBleGNoYW5nZTogZXggfSk7IH0pO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgY2hlY2tFeGNoYW5nZSAoZXhjaGFuZ2UsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuRXhjaGFuZ2VEZWNsYXJlLFxuICAgICAgQXJncy5jaGVja0V4Y2hhbmdlKGV4Y2hhbmdlKSxcbiAgICAgIGRlZnMuRXhjaGFuZ2VEZWNsYXJlT2ssIGNiKTtcbiAgfVxuXG4gIGRlbGV0ZUV4Y2hhbmdlIChleGNoYW5nZSwgb3B0aW9ucywgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5FeGNoYW5nZURlbGV0ZSxcbiAgICAgIEFyZ3MuZGVsZXRlRXhjaGFuZ2UoZXhjaGFuZ2UsIG9wdGlvbnMpLFxuICAgICAgZGVmcy5FeGNoYW5nZURlbGV0ZU9rLCBjYik7XG4gIH1cblxuICBiaW5kRXhjaGFuZ2UgKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCwgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5FeGNoYW5nZUJpbmQsXG4gICAgICBBcmdzLmJpbmRFeGNoYW5nZShkZXN0LCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpLFxuICAgICAgZGVmcy5FeGNoYW5nZUJpbmRPaywgY2IpO1xuICB9XG5cbiAgdW5iaW5kRXhjaGFuZ2UgKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCwgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5FeGNoYW5nZVVuYmluZCxcbiAgICAgIEFyZ3MudW5iaW5kRXhjaGFuZ2UoZGVzdCwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSxcbiAgICAgIGRlZnMuRXhjaGFuZ2VVbmJpbmRPaywgY2IpO1xuICB9XG5cbiAgcHVibGlzaCAoZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICB2YXIgZmllbGRzQW5kUHJvcHMgPSBBcmdzLnB1Ymxpc2goZXhjaGFuZ2UsIHJvdXRpbmdLZXksIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlKGZpZWxkc0FuZFByb3BzLCBmaWVsZHNBbmRQcm9wcywgY29udGVudCk7XG4gIH1cblxuICBzZW5kVG9RdWV1ZSAocXVldWUsIGNvbnRlbnQsIG9wdGlvbnMpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKCcnLCBxdWV1ZSwgY29udGVudCwgb3B0aW9ucyk7XG4gIH1cblxuICBjb25zdW1lIChxdWV1ZSwgY2FsbGJhY2ssIG9wdGlvbnMsIGNiMCkge1xuICAgIHZhciBjYiA9IGNhbGxiYWNrV3JhcHBlcih0aGlzLCBjYjApO1xuICAgIHZhciBmaWVsZHMgPSBBcmdzLmNvbnN1bWUocXVldWUsIG9wdGlvbnMpO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLl9ycGMoXG4gICAgICBkZWZzLkJhc2ljQ29uc3VtZSwgZmllbGRzLCBkZWZzLkJhc2ljQ29uc3VtZU9rLFxuICAgICAgZnVuY3Rpb24gKGVyciwgb2spIHtcbiAgICAgICAgaWYgKGVyciA9PT0gbnVsbCkge1xuICAgICAgICAgIHNlbGYucmVnaXN0ZXJDb25zdW1lcihvay5maWVsZHMuY29uc3VtZXJUYWcsIGNhbGxiYWNrKTtcbiAgICAgICAgICBjYihudWxsLCBvay5maWVsZHMpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2VcbiAgICAgICAgICBjYihlcnIpO1xuICAgICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBjYW5jZWwgKGNvbnN1bWVyVGFnLCBjYjApIHtcbiAgICB2YXIgY2IgPSBjYWxsYmFja1dyYXBwZXIodGhpcywgY2IwKTtcbiAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgdGhpcy5fcnBjKFxuICAgICAgZGVmcy5CYXNpY0NhbmNlbCwgQXJncy5jYW5jZWwoY29uc3VtZXJUYWcpLCBkZWZzLkJhc2ljQ2FuY2VsT2ssXG4gICAgICBmdW5jdGlvbiAoZXJyLCBvaykge1xuICAgICAgICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgICAgICAgc2VsZi51bnJlZ2lzdGVyQ29uc3VtZXIoY29uc3VtZXJUYWcpO1xuICAgICAgICAgIGNiKG51bGwsIG9rLmZpZWxkcyk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGNiKGVycik7XG4gICAgICB9KTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIGdldCAocXVldWUsIG9wdGlvbnMsIGNiMCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB2YXIgZmllbGRzID0gQXJncy5nZXQocXVldWUsIG9wdGlvbnMpO1xuICAgIHZhciBjYiA9IGNhbGxiYWNrV3JhcHBlcih0aGlzLCBjYjApO1xuICAgIHRoaXMuc2VuZE9yRW5xdWV1ZShkZWZzLkJhc2ljR2V0LCBmaWVsZHMsIGZ1bmN0aW9uIChlcnIsIGYpIHtcbiAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKGYuaWQgPT09IGRlZnMuQmFzaWNHZXRFbXB0eSkge1xuICAgICAgICAgIGNiKG51bGwsIGZhbHNlKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkJhc2ljR2V0T2spIHtcbiAgICAgICAgICBzZWxmLmhhbmRsZU1lc3NhZ2UgPSBhY2NlcHRNZXNzYWdlKGZ1bmN0aW9uIChtKSB7XG4gICAgICAgICAgICBtLmZpZWxkcyA9IGYuZmllbGRzO1xuICAgICAgICAgICAgY2IobnVsbCwgbSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgY2IobmV3IEVycm9yKFwiVW5leHBlY3RlZCByZXNwb25zZSB0byBCYXNpY0dldDogXCIgK1xuICAgICAgICAgICAgaW5zcGVjdChmKSkpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhY2sgKG1lc3NhZ2UsIGFsbFVwVG8pIHtcbiAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShcbiAgICAgIGRlZnMuQmFzaWNBY2ssIEFyZ3MuYWNrKG1lc3NhZ2UuZmllbGRzLmRlbGl2ZXJ5VGFnLCBhbGxVcFRvKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBhY2tBbGwgKCkge1xuICAgIHRoaXMuc2VuZEltbWVkaWF0ZWx5KGRlZnMuQmFzaWNBY2ssIEFyZ3MuYWNrKDAsIHRydWUpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIG5hY2sgKG1lc3NhZ2UsIGFsbFVwVG8sIHJlcXVldWUpIHtcbiAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShcbiAgICAgIGRlZnMuQmFzaWNOYWNrLFxuICAgICAgQXJncy5uYWNrKG1lc3NhZ2UuZmllbGRzLmRlbGl2ZXJ5VGFnLCBhbGxVcFRvLCByZXF1ZXVlKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBuYWNrQWxsIChyZXF1ZXVlKSB7XG4gICAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoXG4gICAgICBkZWZzLkJhc2ljTmFjaywgQXJncy5uYWNrKDAsIHRydWUsIHJlcXVldWUpKTtcbiAgICByZXR1cm4gdGhpcztcbiAgfVxuXG4gIHJlamVjdCAobWVzc2FnZSwgcmVxdWV1ZSkge1xuICAgIHRoaXMuc2VuZEltbWVkaWF0ZWx5KFxuICAgICAgZGVmcy5CYXNpY1JlamVjdCxcbiAgICAgIEFyZ3MucmVqZWN0KG1lc3NhZ2UuZmllbGRzLmRlbGl2ZXJ5VGFnLCByZXF1ZXVlKSk7XG4gICAgcmV0dXJuIHRoaXM7XG4gIH1cblxuICBwcmVmZXRjaCAoY291bnQsIGdsb2JhbCwgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5ycGMoZGVmcy5CYXNpY1FvcyxcbiAgICAgIEFyZ3MucHJlZmV0Y2goY291bnQsIGdsb2JhbCksXG4gICAgICBkZWZzLkJhc2ljUW9zT2ssIGNiKTtcbiAgfVxuXG4gIHJlY292ZXIgKGNiKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuQmFzaWNSZWNvdmVyLFxuICAgICAgQXJncy5yZWNvdmVyKCksXG4gICAgICBkZWZzLkJhc2ljUmVjb3Zlck9rLCBjYik7XG4gIH1cbn1cblxuXG4vLyBXcmFwIGFuIFJQQyBjYWxsYmFjayB0byBtYWtlIHN1cmUgdGhlIGNhbGxiYWNrIGlzIGludm9rZWQgd2l0aFxuLy8gZWl0aGVyIGAobnVsbCwgdmFsdWUpYCBvciBgKGVycm9yKWAsIGkuZS4sIG5ldmVyIHR3byBub24tbnVsbFxuLy8gdmFsdWVzLiBBbHNvIHN1YnN0aXR1dGVzIGEgc3R1YiBpZiB0aGUgY2FsbGJhY2sgaXMgYHVuZGVmaW5lZGAgb3Jcbi8vIG90aGVyd2lzZSBmYWxzZXksIGZvciBjb252ZW5pZW5jZSBpbiBtZXRob2RzIGZvciB3aGljaCB0aGUgY2FsbGJhY2tcbi8vIGlzIG9wdGlvbmFsICh0aGF0IGlzLCBtb3N0IG9mIHRoZW0pLlxuZnVuY3Rpb24gY2FsbGJhY2tXcmFwcGVyKGNoLCBjYikge1xuICByZXR1cm4gKGNiKSA/IGZ1bmN0aW9uKGVyciwgb2spIHtcbiAgICBpZiAoZXJyID09PSBudWxsKSB7XG4gICAgICBjYihudWxsLCBvayk7XG4gICAgfVxuICAgIGVsc2UgY2IoZXJyKTtcbiAgfSA6IGZ1bmN0aW9uKCkge307XG59XG5cbmNsYXNzIENvbmZpcm1DaGFubmVsIGV4dGVuZHMgQ2hhbm5lbCB7XG4gIHB1Ymxpc2ggKGV4Y2hhbmdlLCByb3V0aW5nS2V5LFxuICAgIGNvbnRlbnQsIG9wdGlvbnMsIGNiKSB7XG4gICAgdGhpcy5wdXNoQ29uZmlybUNhbGxiYWNrKGNiKTtcbiAgICByZXR1cm4gQ2hhbm5lbC5wcm90b3R5cGUucHVibGlzaC5jYWxsKFxuICAgICAgdGhpcywgZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNvbnRlbnQsIG9wdGlvbnMpO1xuICB9XG5cbiAgc2VuZFRvUXVldWUgKHF1ZXVlLCBjb250ZW50LFxuICAgIG9wdGlvbnMsIGNiKSB7XG4gICAgcmV0dXJuIHRoaXMucHVibGlzaCgnJywgcXVldWUsIGNvbnRlbnQsIG9wdGlvbnMsIGNiKTtcbiAgfVxuXG4gIHdhaXRGb3JDb25maXJtcyAoaykge1xuICAgIHZhciBhd2FpdGluZyA9IFtdO1xuICAgIHZhciB1bmNvbmZpcm1lZCA9IHRoaXMudW5jb25maXJtZWQ7XG4gICAgdW5jb25maXJtZWQuZm9yRWFjaChmdW5jdGlvbiAodmFsLCBpbmRleCkge1xuICAgICAgaWYgKHZhbCA9PT0gbnVsbClcbiAgICAgICAgOyAvLyBhbHJlYWR5IGNvbmZpcm1lZFxuICAgICAgZWxzZSB7XG4gICAgICAgIHZhciBjb25maXJtZWQgPSBuZXcgUHJvbWlzZShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XG4gICAgICAgICAgdW5jb25maXJtZWRbaW5kZXhdID0gZnVuY3Rpb24gKGVycikge1xuICAgICAgICAgICAgaWYgKHZhbClcbiAgICAgICAgICAgICAgdmFsKGVycik7XG4gICAgICAgICAgICBpZiAoZXJyID09PSBudWxsKVxuICAgICAgICAgICAgICByZXNvbHZlKCk7XG4gICAgICAgICAgICBlbHNlXG4gICAgICAgICAgICAgIHJlamVjdChlcnIpO1xuICAgICAgICAgIH07XG4gICAgICAgIH0pO1xuICAgICAgICBhd2FpdGluZy5wdXNoKGNvbmZpcm1lZCk7XG4gICAgICB9XG4gICAgfSk7XG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGF3YWl0aW5nKS50aGVuKGZ1bmN0aW9uICgpIHsgaygpOyB9LFxuICAgICAgZnVuY3Rpb24gKGVycikgeyBrKGVycik7IH0pO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkNhbGxiYWNrTW9kZWwgPSBDYWxsYmFja01vZGVsO1xubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbCA9IENoYW5uZWw7XG5tb2R1bGUuZXhwb3J0cy5Db25maXJtQ2hhbm5lbCA9IENvbmZpcm1DaGFubmVsO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/callback_model.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/channel.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/lib/channel.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("//\n//\n//\n\n// Channel machinery.\n\n\n\nvar defs = __webpack_require__(/*! ./defs */ \"(rsc)/./node_modules/amqplib/lib/defs.js\");\nvar closeMsg = (__webpack_require__(/*! ./format */ \"(rsc)/./node_modules/amqplib/lib/format.js\").closeMessage);\nvar inspect = (__webpack_require__(/*! ./format */ \"(rsc)/./node_modules/amqplib/lib/format.js\").inspect);\nvar methodName = (__webpack_require__(/*! ./format */ \"(rsc)/./node_modules/amqplib/lib/format.js\").methodName);\nvar assert = __webpack_require__(/*! assert */ \"assert\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\");\nvar fmt = (__webpack_require__(/*! util */ \"util\").format);\nvar IllegalOperationError = (__webpack_require__(/*! ./error */ \"(rsc)/./node_modules/amqplib/lib/error.js\").IllegalOperationError);\nvar stackCapture = (__webpack_require__(/*! ./error */ \"(rsc)/./node_modules/amqplib/lib/error.js\").stackCapture);\n\nclass Channel extends EventEmitter {\n  constructor (connection) {\n    super();\n\n    this.connection = connection;\n    // for the presently outstanding RPC\n    this.reply = null;\n    // for the RPCs awaiting action\n    this.pending = [];\n    // for unconfirmed messages\n    this.lwm = 1; // the least, unconfirmed deliveryTag\n    this.unconfirmed = []; // rolling window of delivery callbacks\n    this.on('ack', this.handleConfirm.bind(this, function (cb) {\n      if (cb)\n        cb(null);\n    }));\n    this.on('nack', this.handleConfirm.bind(this, function (cb) {\n      if (cb)\n        cb(new Error('message nacked'));\n    }));\n    this.on('close', function () {\n      var cb;\n      while (cb = this.unconfirmed.shift()) {\n        if (cb)\n          cb(new Error('channel closed'));\n      }\n    });\n    // message frame state machine\n    this.handleMessage = acceptDeliveryOrReturn;\n  }\n\n  allocate () {\n    this.ch = this.connection.freshChannel(this);\n    return this;\n  }\n\n  // Incoming frames are either notifications of e.g., message delivery,\n  // or replies to something we've sent. In general I deal with the\n  // former by emitting an event, and with the latter by keeping a track\n  // of what's expecting a reply.\n  //\n  // The AMQP specification implies that RPCs can't be pipelined; that\n  // is, you can have only one outstanding RPC on a channel at a\n  // time. Certainly that's what RabbitMQ and its clients assume. For\n  // this reason, I buffer RPCs if the channel is already waiting for a\n  // reply.\n  // Just send the damn frame.\n  sendImmediately (method, fields) {\n    return this.connection.sendMethod(this.ch, method, fields);\n  }\n\n  // Invariant: !this.reply -> pending.length == 0. That is, whenever we\n  // clear a reply, we must send another RPC (and thereby fill\n  // this.reply) if there is one waiting. The invariant relevant here\n  // and in `accept`.\n  sendOrEnqueue (method, fields, reply) {\n    if (!this.reply) { // if no reply waiting, we can go\n      assert(this.pending.length === 0);\n      this.reply = reply;\n      this.sendImmediately(method, fields);\n    }\n    else {\n      this.pending.push({\n        method: method,\n        fields: fields,\n        reply: reply\n      });\n    }\n  }\n\n  sendMessage (fields, properties, content) {\n    return this.connection.sendMessage(\n      this.ch,\n      defs.BasicPublish, fields,\n      defs.BasicProperties, properties,\n      content);\n  }\n\n  // Internal, synchronously resolved RPC; the return value is resolved\n  // with the whole frame.\n  _rpc (method, fields, expect, cb) {\n    var self = this;\n\n    function reply (err, f) {\n      if (err === null) {\n        if (f.id === expect) {\n          return cb(null, f);\n        }\n        else {\n          // We have detected a problem, so it's up to us to close the\n          // channel\n          var expectedName = methodName(expect);\n\n          var e = new Error(fmt(\"Expected %s; got %s\",\n            expectedName, inspect(f, false)));\n          self.closeWithError(f.id, fmt('Expected %s; got %s',\n            expectedName, methodName(f.id)),\n            defs.constants.UNEXPECTED_FRAME, e);\n          return cb(e);\n        }\n      }\n\n\n      // An error will be given if, for example, this is waiting to be\n      // sent and the connection closes\n      else if (err instanceof Error)\n        return cb(err);\n\n\n      // A close frame will be given if this is the RPC awaiting reply\n      // and the channel is closed by the server\n      else {\n        // otherwise, it's a close frame\n        var closeReason = (err.fields.classId << 16) + err.fields.methodId;\n        var e = (method === closeReason)\n          ? fmt(\"Operation failed: %s; %s\",\n            methodName(method), closeMsg(err))\n          : fmt(\"Channel closed by server: %s\", closeMsg(err));\n        var closeFrameError = new Error(e);\n        closeFrameError.code = err.fields.replyCode;\n        closeFrameError.classId = err.fields.classId;\n        closeFrameError.methodId = err.fields.methodId;\n        return cb(closeFrameError);\n      }\n    }\n\n    this.sendOrEnqueue(method, fields, reply);\n  }\n\n  // Move to entirely closed state.\n  toClosed (capturedStack) {\n    this._rejectPending();\n    invalidateSend(this, 'Channel closed', capturedStack);\n    this.accept = invalidOp('Channel closed', capturedStack);\n    this.connection.releaseChannel(this.ch);\n    this.emit('close');\n  }\n\n  // Stop being able to send and receive methods and content. Used when\n  // we close the channel. Invokes the continuation once the server has\n  // acknowledged the close, but before the channel is moved to the\n  // closed state.\n  toClosing (capturedStack, k) {\n    var send = this.sendImmediately.bind(this);\n    invalidateSend(this, 'Channel closing', capturedStack);\n\n    this.accept = function (f) {\n      if (f.id === defs.ChannelCloseOk) {\n        if (k)\n          k();\n        var s = stackCapture('ChannelCloseOk frame received');\n        this.toClosed(s);\n      }\n      else if (f.id === defs.ChannelClose) {\n        send(defs.ChannelCloseOk, {});\n      }\n      // else ignore frame\n    };\n  }\n\n  _rejectPending () {\n    function rej (r) {\n      r(new Error(\"Channel ended, no reply will be forthcoming\"));\n    }\n    if (this.reply !== null)\n      rej(this.reply);\n    this.reply = null;\n\n    var discard;\n    while (discard = this.pending.shift())\n      rej(discard.reply);\n    this.pending = null; // so pushes will break\n  }\n\n  closeBecause (reason, code, k) {\n    this.sendImmediately(defs.ChannelClose, {\n      replyText: reason,\n      replyCode: code,\n      methodId: 0, classId: 0\n    });\n    var s = stackCapture('closeBecause called: ' + reason);\n    this.toClosing(s, k);\n  }\n\n  // If we close because there's been an error, we need to distinguish\n  // between what we tell the server (`reason`) and what we report as\n  // the cause in the client (`error`).\n  closeWithError (id, reason, code, error) {\n    var self = this;\n    this.closeBecause(reason, code, function () {\n      error.code = code;\n      // content frames and consumer errors do not provide a method a class/method ID\n      if (id) {\n        error.classId = defs.info(id).classId;\n        error.methodId = defs.info(id).methodId;\n      }\n      self.emit('error', error);\n    });\n  }\n\n  // A trampolining state machine for message frames on a channel. A\n  // message arrives in at least two frames: first, a method announcing\n  // the message (either a BasicDeliver or BasicGetOk); then, a message\n  // header with the message properties; then, zero or more content\n  // frames.\n  // Keep the try/catch localised, in an attempt to avoid disabling\n  // optimisation\n  acceptMessageFrame (f) {\n    try {\n      this.handleMessage = this.handleMessage(f);\n    }\n    catch (msg) {\n      if (typeof msg === 'string') {\n        this.closeWithError(f.id, msg, defs.constants.UNEXPECTED_FRAME,\n          new Error(msg));\n      }\n      else if (msg instanceof Error) {\n        this.closeWithError(f.id, 'Error while processing message',\n          defs.constants.INTERNAL_ERROR, msg);\n      }\n      else {\n        this.closeWithError(f.id, 'Internal error while processing message',\n          defs.constants.INTERNAL_ERROR,\n          new Error(msg.toString()));\n      }\n    }\n  }\n\n  handleConfirm (handle, f) {\n    var tag = f.deliveryTag;\n    var multi = f.multiple;\n\n    if (multi) {\n      var confirmed = this.unconfirmed.splice(0, tag - this.lwm + 1);\n      this.lwm = tag + 1;\n      confirmed.forEach(handle);\n    }\n    else {\n      var c;\n      if (tag === this.lwm) {\n        c = this.unconfirmed.shift();\n        this.lwm++;\n        // Advance the LWM and the window to the next non-gap, or\n        // possibly to the end\n        while (this.unconfirmed[0] === null) {\n          this.unconfirmed.shift();\n          this.lwm++;\n        }\n      }\n      else {\n        c = this.unconfirmed[tag - this.lwm];\n        this.unconfirmed[tag - this.lwm] = null;\n      }\n      // Technically, in the single-deliveryTag case, I should report a\n      // protocol breach if it's already been confirmed.\n      handle(c);\n    }\n  }\n\n  pushConfirmCallback (cb) {\n    // `null` is used specifically for marking already confirmed slots,\n    // so I coerce `undefined` and `null` to false; functions are never\n    // falsey.\n    this.unconfirmed.push(cb || false);\n  }\n\n  onBufferDrain () {\n    this.emit('drain');\n  }\n\n  accept(f) {\n\n    switch (f.id) {\n\n      // Message frames\n    case undefined: // content frame!\n    case defs.BasicDeliver:\n    case defs.BasicReturn:\n    case defs.BasicProperties:\n      return this.acceptMessageFrame(f);\n\n      // confirmations, need to do confirm.select first\n    case defs.BasicAck:\n      return this.emit('ack', f.fields);\n    case defs.BasicNack:\n      return this.emit('nack', f.fields);\n    case defs.BasicCancel:\n      // The broker can send this if e.g., the queue is deleted.\n      return this.emit('cancel', f.fields);\n\n    case defs.ChannelClose:\n      // Any remote closure is an error to us. Reject the pending reply\n      // with the close frame, so it can see whether it was that\n      // operation that caused it to close.\n      if (this.reply) {\n        var reply = this.reply; this.reply = null;\n        reply(f);\n      }\n      var emsg = \"Channel closed by server: \" + closeMsg(f);\n      this.sendImmediately(defs.ChannelCloseOk, {});\n\n      var error = new Error(emsg);\n      error.code = f.fields.replyCode;\n      error.classId = f.fields.classId;\n      error.methodId = f.fields.methodId;\n      this.emit('error', error);\n\n      var s = stackCapture(emsg);\n      this.toClosed(s);\n      return;\n\n    case defs.BasicFlow:\n      // RabbitMQ doesn't send this, it just blocks the TCP socket\n      return this.closeWithError(f.id, \"Flow not implemented\",\n                                 defs.constants.NOT_IMPLEMENTED,\n                                 new Error('Flow not implemented'));\n\n    default: // assume all other things are replies\n      // Resolving the reply may lead to another RPC; to make sure we\n      // don't hold that up, clear this.reply\n      var reply = this.reply; this.reply = null;\n      // however, maybe there's an RPC waiting to go? If so, that'll\n      // fill this.reply again, restoring the invariant. This does rely\n      // on any response being recv'ed after resolving the promise,\n      // below; hence, I use synchronous defer.\n      if (this.pending.length > 0) {\n        var send = this.pending.shift();\n        this.reply = send.reply;\n        this.sendImmediately(send.method, send.fields);\n      }\n      return reply(null, f);\n    }\n  }\n}\n\n// Shutdown protocol. There's three scenarios:\n//\n// 1. The application decides to shut the channel\n// 2. The server decides to shut the channel, possibly because of\n// something the application did\n// 3. The connection is closing, so there won't be any more frames\n// going back and forth.\n//\n// 1 and 2 involve an exchange of method frames (Close and CloseOk),\n// while 3 doesn't; the connection simply says \"shutdown\" to the\n// channel, which then acts as if it's closing, without going through\n// the exchange.\n\nfunction invalidOp(msg, stack) {\n  return function() {\n    throw new IllegalOperationError(msg, stack);\n  };\n}\n\nfunction invalidateSend(ch, msg, stack) {\n  ch.sendImmediately = ch.sendOrEnqueue = ch.sendMessage =\n    invalidOp(msg, stack);\n}\n\n// Kick off a message delivery given a BasicDeliver or BasicReturn\n// frame (BasicGet uses the RPC mechanism)\nfunction acceptDeliveryOrReturn(f) {\n  var event;\n  if (f.id === defs.BasicDeliver) event = 'delivery';\n  else if (f.id === defs.BasicReturn) event = 'return';\n  else throw fmt(\"Expected BasicDeliver or BasicReturn; got %s\",\n                 inspect(f));\n\n  var self = this;\n  var fields = f.fields;\n  return acceptMessage(function(message) {\n    message.fields = fields;\n    self.emit(event, message);\n  });\n}\n\n// Move to the state of waiting for message frames (headers, then\n// one or more content frames)\nfunction acceptMessage(continuation) {\n  var totalSize = 0, remaining = 0;\n  var buffers = null;\n\n  var message = {\n    fields: null,\n    properties: null,\n    content: null\n  };\n\n  return headers;\n\n  // expect a headers frame\n  function headers(f) {\n    if (f.id === defs.BasicProperties) {\n      message.properties = f.fields;\n      totalSize = remaining = f.size;\n\n      // for zero-length messages, content frames aren't required.\n      if (totalSize === 0) {\n        message.content = Buffer.alloc(0);\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      }\n      else {\n        return content;\n      }\n    }\n    else {\n      throw \"Expected headers frame after delivery\";\n    }\n  }\n\n  // expect a content frame\n  // %%% TODO cancelled messages (sent as zero-length content frame)\n  function content(f) {\n    if (f.content) {\n      var size = f.content.length;\n      remaining -= size;\n      if (remaining === 0) {\n        if (buffers !== null) {\n          buffers.push(f.content);\n          message.content = Buffer.concat(buffers);\n        }\n        else {\n          message.content = f.content;\n        }\n        continuation(message);\n        return acceptDeliveryOrReturn;\n      }\n      else if (remaining < 0) {\n        throw fmt(\"Too much content sent! Expected %d bytes\",\n                  totalSize);\n      }\n      else {\n        if (buffers !== null)\n          buffers.push(f.content);\n        else\n          buffers = [f.content];\n        return content;\n      }\n    }\n    else throw \"Expected content frame after headers\"\n  }\n}\n\n// This adds just a bit more stuff useful for the APIs, but not\n// low-level machinery.\nclass BaseChannel extends Channel {\n  constructor (connection) {\n    super(connection);\n    this.consumers = new Map();\n  }\n\n  // Not sure I like the ff, it's going to be changing hidden classes\n  // all over the place. On the other hand, whaddya do.\n  registerConsumer (tag, callback) {\n    this.consumers.set(tag, callback);\n  }\n\n  unregisterConsumer (tag) {\n    this.consumers.delete(tag);\n  }\n\n  dispatchMessage (fields, message) {\n    var consumerTag = fields.consumerTag;\n    var consumer = this.consumers.get(consumerTag);\n    if (consumer) {\n      return consumer(message);\n    }\n    else {\n      // %%% Surely a race here\n      throw new Error(\"Unknown consumer: \" + consumerTag);\n    }\n  }\n\n  handleDelivery (message) {\n    return this.dispatchMessage(message.fields, message);\n  }\n\n  handleCancel (fields) {\n    var result = this.dispatchMessage(fields, null);\n    this.unregisterConsumer(fields.consumerTag);\n    return result;\n  }\n}\n\nmodule.exports.acceptMessage = acceptMessage;\nmodule.exports.BaseChannel = BaseChannel;\nmodule.exports.Channel = Channel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY2hhbm5lbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLHdEQUFRO0FBQzNCLGVBQWUsZ0dBQWdDO0FBQy9DLGNBQWMsMkZBQTJCO0FBQ3pDLGlCQUFpQiw4RkFBOEI7QUFDL0MsYUFBYSxtQkFBTyxDQUFDLHNCQUFRO0FBQzdCLG1CQUFtQixtQkFBTyxDQUFDLHNCQUFRO0FBQ25DLFVBQVUsZ0RBQXNCO0FBQ2hDLDRCQUE0Qix1R0FBd0M7QUFDcEUsbUJBQW1CLDhGQUErQjs7QUFFbEQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQiwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrRUFBa0U7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLE9BQU87QUFDUDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJDQUEyQztBQUMzQztBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDhDQUE4QztBQUM5QztBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0E7QUFDQTtBQUNBOzs7QUFHQTtBQUNBO0FBQ0E7QUFDQTs7O0FBR0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RCx5Q0FBeUM7QUFDekM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BEO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQztBQUNoQztBQUNBO0FBQ0E7QUFDQSxrREFBa0Q7O0FBRWxEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxzREFBc0Q7QUFDdEQ7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdEQUF3RDtBQUN4RDs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCO0FBQzVCLDBCQUEwQjtBQUMxQixzQkFBc0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIyLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2NoYW5uZWwuanM/YmVlMCJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG5cbi8vIENoYW5uZWwgbWFjaGluZXJ5LlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBkZWZzID0gcmVxdWlyZSgnLi9kZWZzJyk7XG52YXIgY2xvc2VNc2cgPSByZXF1aXJlKCcuL2Zvcm1hdCcpLmNsb3NlTWVzc2FnZTtcbnZhciBpbnNwZWN0ID0gcmVxdWlyZSgnLi9mb3JtYXQnKS5pbnNwZWN0O1xudmFyIG1ldGhvZE5hbWUgPSByZXF1aXJlKCcuL2Zvcm1hdCcpLm1ldGhvZE5hbWU7XG52YXIgYXNzZXJ0ID0gcmVxdWlyZSgnYXNzZXJ0Jyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgZm10ID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcbnZhciBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IgPSByZXF1aXJlKCcuL2Vycm9yJykuSWxsZWdhbE9wZXJhdGlvbkVycm9yO1xudmFyIHN0YWNrQ2FwdHVyZSA9IHJlcXVpcmUoJy4vZXJyb3InKS5zdGFja0NhcHR1cmU7XG5cbmNsYXNzIENoYW5uZWwgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoY29ubmVjdGlvbikge1xuICAgIHN1cGVyKCk7XG5cbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuICAgIC8vIGZvciB0aGUgcHJlc2VudGx5IG91dHN0YW5kaW5nIFJQQ1xuICAgIHRoaXMucmVwbHkgPSBudWxsO1xuICAgIC8vIGZvciB0aGUgUlBDcyBhd2FpdGluZyBhY3Rpb25cbiAgICB0aGlzLnBlbmRpbmcgPSBbXTtcbiAgICAvLyBmb3IgdW5jb25maXJtZWQgbWVzc2FnZXNcbiAgICB0aGlzLmx3bSA9IDE7IC8vIHRoZSBsZWFzdCwgdW5jb25maXJtZWQgZGVsaXZlcnlUYWdcbiAgICB0aGlzLnVuY29uZmlybWVkID0gW107IC8vIHJvbGxpbmcgd2luZG93IG9mIGRlbGl2ZXJ5IGNhbGxiYWNrc1xuICAgIHRoaXMub24oJ2FjaycsIHRoaXMuaGFuZGxlQ29uZmlybS5iaW5kKHRoaXMsIGZ1bmN0aW9uIChjYikge1xuICAgICAgaWYgKGNiKVxuICAgICAgICBjYihudWxsKTtcbiAgICB9KSk7XG4gICAgdGhpcy5vbignbmFjaycsIHRoaXMuaGFuZGxlQ29uZmlybS5iaW5kKHRoaXMsIGZ1bmN0aW9uIChjYikge1xuICAgICAgaWYgKGNiKVxuICAgICAgICBjYihuZXcgRXJyb3IoJ21lc3NhZ2UgbmFja2VkJykpO1xuICAgIH0pKTtcbiAgICB0aGlzLm9uKCdjbG9zZScsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHZhciBjYjtcbiAgICAgIHdoaWxlIChjYiA9IHRoaXMudW5jb25maXJtZWQuc2hpZnQoKSkge1xuICAgICAgICBpZiAoY2IpXG4gICAgICAgICAgY2IobmV3IEVycm9yKCdjaGFubmVsIGNsb3NlZCcpKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBtZXNzYWdlIGZyYW1lIHN0YXRlIG1hY2hpbmVcbiAgICB0aGlzLmhhbmRsZU1lc3NhZ2UgPSBhY2NlcHREZWxpdmVyeU9yUmV0dXJuO1xuICB9XG5cbiAgYWxsb2NhdGUgKCkge1xuICAgIHRoaXMuY2ggPSB0aGlzLmNvbm5lY3Rpb24uZnJlc2hDaGFubmVsKHRoaXMpO1xuICAgIHJldHVybiB0aGlzO1xuICB9XG5cbiAgLy8gSW5jb21pbmcgZnJhbWVzIGFyZSBlaXRoZXIgbm90aWZpY2F0aW9ucyBvZiBlLmcuLCBtZXNzYWdlIGRlbGl2ZXJ5LFxuICAvLyBvciByZXBsaWVzIHRvIHNvbWV0aGluZyB3ZSd2ZSBzZW50LiBJbiBnZW5lcmFsIEkgZGVhbCB3aXRoIHRoZVxuICAvLyBmb3JtZXIgYnkgZW1pdHRpbmcgYW4gZXZlbnQsIGFuZCB3aXRoIHRoZSBsYXR0ZXIgYnkga2VlcGluZyBhIHRyYWNrXG4gIC8vIG9mIHdoYXQncyBleHBlY3RpbmcgYSByZXBseS5cbiAgLy9cbiAgLy8gVGhlIEFNUVAgc3BlY2lmaWNhdGlvbiBpbXBsaWVzIHRoYXQgUlBDcyBjYW4ndCBiZSBwaXBlbGluZWQ7IHRoYXRcbiAgLy8gaXMsIHlvdSBjYW4gaGF2ZSBvbmx5IG9uZSBvdXRzdGFuZGluZyBSUEMgb24gYSBjaGFubmVsIGF0IGFcbiAgLy8gdGltZS4gQ2VydGFpbmx5IHRoYXQncyB3aGF0IFJhYmJpdE1RIGFuZCBpdHMgY2xpZW50cyBhc3N1bWUuIEZvclxuICAvLyB0aGlzIHJlYXNvbiwgSSBidWZmZXIgUlBDcyBpZiB0aGUgY2hhbm5lbCBpcyBhbHJlYWR5IHdhaXRpbmcgZm9yIGFcbiAgLy8gcmVwbHkuXG4gIC8vIEp1c3Qgc2VuZCB0aGUgZGFtbiBmcmFtZS5cbiAgc2VuZEltbWVkaWF0ZWx5IChtZXRob2QsIGZpZWxkcykge1xuICAgIHJldHVybiB0aGlzLmNvbm5lY3Rpb24uc2VuZE1ldGhvZCh0aGlzLmNoLCBtZXRob2QsIGZpZWxkcyk7XG4gIH1cblxuICAvLyBJbnZhcmlhbnQ6ICF0aGlzLnJlcGx5IC0+IHBlbmRpbmcubGVuZ3RoID09IDAuIFRoYXQgaXMsIHdoZW5ldmVyIHdlXG4gIC8vIGNsZWFyIGEgcmVwbHksIHdlIG11c3Qgc2VuZCBhbm90aGVyIFJQQyAoYW5kIHRoZXJlYnkgZmlsbFxuICAvLyB0aGlzLnJlcGx5KSBpZiB0aGVyZSBpcyBvbmUgd2FpdGluZy4gVGhlIGludmFyaWFudCByZWxldmFudCBoZXJlXG4gIC8vIGFuZCBpbiBgYWNjZXB0YC5cbiAgc2VuZE9yRW5xdWV1ZSAobWV0aG9kLCBmaWVsZHMsIHJlcGx5KSB7XG4gICAgaWYgKCF0aGlzLnJlcGx5KSB7IC8vIGlmIG5vIHJlcGx5IHdhaXRpbmcsIHdlIGNhbiBnb1xuICAgICAgYXNzZXJ0KHRoaXMucGVuZGluZy5sZW5ndGggPT09IDApO1xuICAgICAgdGhpcy5yZXBseSA9IHJlcGx5O1xuICAgICAgdGhpcy5zZW5kSW1tZWRpYXRlbHkobWV0aG9kLCBmaWVsZHMpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHRoaXMucGVuZGluZy5wdXNoKHtcbiAgICAgICAgbWV0aG9kOiBtZXRob2QsXG4gICAgICAgIGZpZWxkczogZmllbGRzLFxuICAgICAgICByZXBseTogcmVwbHlcbiAgICAgIH0pO1xuICAgIH1cbiAgfVxuXG4gIHNlbmRNZXNzYWdlIChmaWVsZHMsIHByb3BlcnRpZXMsIGNvbnRlbnQpIHtcbiAgICByZXR1cm4gdGhpcy5jb25uZWN0aW9uLnNlbmRNZXNzYWdlKFxuICAgICAgdGhpcy5jaCxcbiAgICAgIGRlZnMuQmFzaWNQdWJsaXNoLCBmaWVsZHMsXG4gICAgICBkZWZzLkJhc2ljUHJvcGVydGllcywgcHJvcGVydGllcyxcbiAgICAgIGNvbnRlbnQpO1xuICB9XG5cbiAgLy8gSW50ZXJuYWwsIHN5bmNocm9ub3VzbHkgcmVzb2x2ZWQgUlBDOyB0aGUgcmV0dXJuIHZhbHVlIGlzIHJlc29sdmVkXG4gIC8vIHdpdGggdGhlIHdob2xlIGZyYW1lLlxuICBfcnBjIChtZXRob2QsIGZpZWxkcywgZXhwZWN0LCBjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIHJlcGx5IChlcnIsIGYpIHtcbiAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgaWYgKGYuaWQgPT09IGV4cGVjdCkge1xuICAgICAgICAgIHJldHVybiBjYihudWxsLCBmKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICAvLyBXZSBoYXZlIGRldGVjdGVkIGEgcHJvYmxlbSwgc28gaXQncyB1cCB0byB1cyB0byBjbG9zZSB0aGVcbiAgICAgICAgICAvLyBjaGFubmVsXG4gICAgICAgICAgdmFyIGV4cGVjdGVkTmFtZSA9IG1ldGhvZE5hbWUoZXhwZWN0KTtcblxuICAgICAgICAgIHZhciBlID0gbmV3IEVycm9yKGZtdChcIkV4cGVjdGVkICVzOyBnb3QgJXNcIixcbiAgICAgICAgICAgIGV4cGVjdGVkTmFtZSwgaW5zcGVjdChmLCBmYWxzZSkpKTtcbiAgICAgICAgICBzZWxmLmNsb3NlV2l0aEVycm9yKGYuaWQsIGZtdCgnRXhwZWN0ZWQgJXM7IGdvdCAlcycsXG4gICAgICAgICAgICBleHBlY3RlZE5hbWUsIG1ldGhvZE5hbWUoZi5pZCkpLFxuICAgICAgICAgICAgZGVmcy5jb25zdGFudHMuVU5FWFBFQ1RFRF9GUkFNRSwgZSk7XG4gICAgICAgICAgcmV0dXJuIGNiKGUpO1xuICAgICAgICB9XG4gICAgICB9XG5cblxuICAgICAgLy8gQW4gZXJyb3Igd2lsbCBiZSBnaXZlbiBpZiwgZm9yIGV4YW1wbGUsIHRoaXMgaXMgd2FpdGluZyB0byBiZVxuICAgICAgLy8gc2VudCBhbmQgdGhlIGNvbm5lY3Rpb24gY2xvc2VzXG4gICAgICBlbHNlIGlmIChlcnIgaW5zdGFuY2VvZiBFcnJvcilcbiAgICAgICAgcmV0dXJuIGNiKGVycik7XG5cblxuICAgICAgLy8gQSBjbG9zZSBmcmFtZSB3aWxsIGJlIGdpdmVuIGlmIHRoaXMgaXMgdGhlIFJQQyBhd2FpdGluZyByZXBseVxuICAgICAgLy8gYW5kIHRoZSBjaGFubmVsIGlzIGNsb3NlZCBieSB0aGUgc2VydmVyXG4gICAgICBlbHNlIHtcbiAgICAgICAgLy8gb3RoZXJ3aXNlLCBpdCdzIGEgY2xvc2UgZnJhbWVcbiAgICAgICAgdmFyIGNsb3NlUmVhc29uID0gKGVyci5maWVsZHMuY2xhc3NJZCA8PCAxNikgKyBlcnIuZmllbGRzLm1ldGhvZElkO1xuICAgICAgICB2YXIgZSA9IChtZXRob2QgPT09IGNsb3NlUmVhc29uKVxuICAgICAgICAgID8gZm10KFwiT3BlcmF0aW9uIGZhaWxlZDogJXM7ICVzXCIsXG4gICAgICAgICAgICBtZXRob2ROYW1lKG1ldGhvZCksIGNsb3NlTXNnKGVycikpXG4gICAgICAgICAgOiBmbXQoXCJDaGFubmVsIGNsb3NlZCBieSBzZXJ2ZXI6ICVzXCIsIGNsb3NlTXNnKGVycikpO1xuICAgICAgICB2YXIgY2xvc2VGcmFtZUVycm9yID0gbmV3IEVycm9yKGUpO1xuICAgICAgICBjbG9zZUZyYW1lRXJyb3IuY29kZSA9IGVyci5maWVsZHMucmVwbHlDb2RlO1xuICAgICAgICBjbG9zZUZyYW1lRXJyb3IuY2xhc3NJZCA9IGVyci5maWVsZHMuY2xhc3NJZDtcbiAgICAgICAgY2xvc2VGcmFtZUVycm9yLm1ldGhvZElkID0gZXJyLmZpZWxkcy5tZXRob2RJZDtcbiAgICAgICAgcmV0dXJuIGNiKGNsb3NlRnJhbWVFcnJvcik7XG4gICAgICB9XG4gICAgfVxuXG4gICAgdGhpcy5zZW5kT3JFbnF1ZXVlKG1ldGhvZCwgZmllbGRzLCByZXBseSk7XG4gIH1cblxuICAvLyBNb3ZlIHRvIGVudGlyZWx5IGNsb3NlZCBzdGF0ZS5cbiAgdG9DbG9zZWQgKGNhcHR1cmVkU3RhY2spIHtcbiAgICB0aGlzLl9yZWplY3RQZW5kaW5nKCk7XG4gICAgaW52YWxpZGF0ZVNlbmQodGhpcywgJ0NoYW5uZWwgY2xvc2VkJywgY2FwdHVyZWRTdGFjayk7XG4gICAgdGhpcy5hY2NlcHQgPSBpbnZhbGlkT3AoJ0NoYW5uZWwgY2xvc2VkJywgY2FwdHVyZWRTdGFjayk7XG4gICAgdGhpcy5jb25uZWN0aW9uLnJlbGVhc2VDaGFubmVsKHRoaXMuY2gpO1xuICAgIHRoaXMuZW1pdCgnY2xvc2UnKTtcbiAgfVxuXG4gIC8vIFN0b3AgYmVpbmcgYWJsZSB0byBzZW5kIGFuZCByZWNlaXZlIG1ldGhvZHMgYW5kIGNvbnRlbnQuIFVzZWQgd2hlblxuICAvLyB3ZSBjbG9zZSB0aGUgY2hhbm5lbC4gSW52b2tlcyB0aGUgY29udGludWF0aW9uIG9uY2UgdGhlIHNlcnZlciBoYXNcbiAgLy8gYWNrbm93bGVkZ2VkIHRoZSBjbG9zZSwgYnV0IGJlZm9yZSB0aGUgY2hhbm5lbCBpcyBtb3ZlZCB0byB0aGVcbiAgLy8gY2xvc2VkIHN0YXRlLlxuICB0b0Nsb3NpbmcgKGNhcHR1cmVkU3RhY2ssIGspIHtcbiAgICB2YXIgc2VuZCA9IHRoaXMuc2VuZEltbWVkaWF0ZWx5LmJpbmQodGhpcyk7XG4gICAgaW52YWxpZGF0ZVNlbmQodGhpcywgJ0NoYW5uZWwgY2xvc2luZycsIGNhcHR1cmVkU3RhY2spO1xuXG4gICAgdGhpcy5hY2NlcHQgPSBmdW5jdGlvbiAoZikge1xuICAgICAgaWYgKGYuaWQgPT09IGRlZnMuQ2hhbm5lbENsb3NlT2spIHtcbiAgICAgICAgaWYgKGspXG4gICAgICAgICAgaygpO1xuICAgICAgICB2YXIgcyA9IHN0YWNrQ2FwdHVyZSgnQ2hhbm5lbENsb3NlT2sgZnJhbWUgcmVjZWl2ZWQnKTtcbiAgICAgICAgdGhpcy50b0Nsb3NlZChzKTtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKGYuaWQgPT09IGRlZnMuQ2hhbm5lbENsb3NlKSB7XG4gICAgICAgIHNlbmQoZGVmcy5DaGFubmVsQ2xvc2VPaywge30pO1xuICAgICAgfVxuICAgICAgLy8gZWxzZSBpZ25vcmUgZnJhbWVcbiAgICB9O1xuICB9XG5cbiAgX3JlamVjdFBlbmRpbmcgKCkge1xuICAgIGZ1bmN0aW9uIHJlaiAocikge1xuICAgICAgcihuZXcgRXJyb3IoXCJDaGFubmVsIGVuZGVkLCBubyByZXBseSB3aWxsIGJlIGZvcnRoY29taW5nXCIpKTtcbiAgICB9XG4gICAgaWYgKHRoaXMucmVwbHkgIT09IG51bGwpXG4gICAgICByZWoodGhpcy5yZXBseSk7XG4gICAgdGhpcy5yZXBseSA9IG51bGw7XG5cbiAgICB2YXIgZGlzY2FyZDtcbiAgICB3aGlsZSAoZGlzY2FyZCA9IHRoaXMucGVuZGluZy5zaGlmdCgpKVxuICAgICAgcmVqKGRpc2NhcmQucmVwbHkpO1xuICAgIHRoaXMucGVuZGluZyA9IG51bGw7IC8vIHNvIHB1c2hlcyB3aWxsIGJyZWFrXG4gIH1cblxuICBjbG9zZUJlY2F1c2UgKHJlYXNvbiwgY29kZSwgaykge1xuICAgIHRoaXMuc2VuZEltbWVkaWF0ZWx5KGRlZnMuQ2hhbm5lbENsb3NlLCB7XG4gICAgICByZXBseVRleHQ6IHJlYXNvbixcbiAgICAgIHJlcGx5Q29kZTogY29kZSxcbiAgICAgIG1ldGhvZElkOiAwLCBjbGFzc0lkOiAwXG4gICAgfSk7XG4gICAgdmFyIHMgPSBzdGFja0NhcHR1cmUoJ2Nsb3NlQmVjYXVzZSBjYWxsZWQ6ICcgKyByZWFzb24pO1xuICAgIHRoaXMudG9DbG9zaW5nKHMsIGspO1xuICB9XG5cbiAgLy8gSWYgd2UgY2xvc2UgYmVjYXVzZSB0aGVyZSdzIGJlZW4gYW4gZXJyb3IsIHdlIG5lZWQgdG8gZGlzdGluZ3Vpc2hcbiAgLy8gYmV0d2VlbiB3aGF0IHdlIHRlbGwgdGhlIHNlcnZlciAoYHJlYXNvbmApIGFuZCB3aGF0IHdlIHJlcG9ydCBhc1xuICAvLyB0aGUgY2F1c2UgaW4gdGhlIGNsaWVudCAoYGVycm9yYCkuXG4gIGNsb3NlV2l0aEVycm9yIChpZCwgcmVhc29uLCBjb2RlLCBlcnJvcikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICB0aGlzLmNsb3NlQmVjYXVzZShyZWFzb24sIGNvZGUsIGZ1bmN0aW9uICgpIHtcbiAgICAgIGVycm9yLmNvZGUgPSBjb2RlO1xuICAgICAgLy8gY29udGVudCBmcmFtZXMgYW5kIGNvbnN1bWVyIGVycm9ycyBkbyBub3QgcHJvdmlkZSBhIG1ldGhvZCBhIGNsYXNzL21ldGhvZCBJRFxuICAgICAgaWYgKGlkKSB7XG4gICAgICAgIGVycm9yLmNsYXNzSWQgPSBkZWZzLmluZm8oaWQpLmNsYXNzSWQ7XG4gICAgICAgIGVycm9yLm1ldGhvZElkID0gZGVmcy5pbmZvKGlkKS5tZXRob2RJZDtcbiAgICAgIH1cbiAgICAgIHNlbGYuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgfSk7XG4gIH1cblxuICAvLyBBIHRyYW1wb2xpbmluZyBzdGF0ZSBtYWNoaW5lIGZvciBtZXNzYWdlIGZyYW1lcyBvbiBhIGNoYW5uZWwuIEFcbiAgLy8gbWVzc2FnZSBhcnJpdmVzIGluIGF0IGxlYXN0IHR3byBmcmFtZXM6IGZpcnN0LCBhIG1ldGhvZCBhbm5vdW5jaW5nXG4gIC8vIHRoZSBtZXNzYWdlIChlaXRoZXIgYSBCYXNpY0RlbGl2ZXIgb3IgQmFzaWNHZXRPayk7IHRoZW4sIGEgbWVzc2FnZVxuICAvLyBoZWFkZXIgd2l0aCB0aGUgbWVzc2FnZSBwcm9wZXJ0aWVzOyB0aGVuLCB6ZXJvIG9yIG1vcmUgY29udGVudFxuICAvLyBmcmFtZXMuXG4gIC8vIEtlZXAgdGhlIHRyeS9jYXRjaCBsb2NhbGlzZWQsIGluIGFuIGF0dGVtcHQgdG8gYXZvaWQgZGlzYWJsaW5nXG4gIC8vIG9wdGltaXNhdGlvblxuICBhY2NlcHRNZXNzYWdlRnJhbWUgKGYpIHtcbiAgICB0cnkge1xuICAgICAgdGhpcy5oYW5kbGVNZXNzYWdlID0gdGhpcy5oYW5kbGVNZXNzYWdlKGYpO1xuICAgIH1cbiAgICBjYXRjaCAobXNnKSB7XG4gICAgICBpZiAodHlwZW9mIG1zZyA9PT0gJ3N0cmluZycpIHtcbiAgICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihmLmlkLCBtc2csIGRlZnMuY29uc3RhbnRzLlVORVhQRUNURURfRlJBTUUsXG4gICAgICAgICAgbmV3IEVycm9yKG1zZykpO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAobXNnIGluc3RhbmNlb2YgRXJyb3IpIHtcbiAgICAgICAgdGhpcy5jbG9zZVdpdGhFcnJvcihmLmlkLCAnRXJyb3Igd2hpbGUgcHJvY2Vzc2luZyBtZXNzYWdlJyxcbiAgICAgICAgICBkZWZzLmNvbnN0YW50cy5JTlRFUk5BTF9FUlJPUiwgbXNnKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLmNsb3NlV2l0aEVycm9yKGYuaWQsICdJbnRlcm5hbCBlcnJvciB3aGlsZSBwcm9jZXNzaW5nIG1lc3NhZ2UnLFxuICAgICAgICAgIGRlZnMuY29uc3RhbnRzLklOVEVSTkFMX0VSUk9SLFxuICAgICAgICAgIG5ldyBFcnJvcihtc2cudG9TdHJpbmcoKSkpO1xuICAgICAgfVxuICAgIH1cbiAgfVxuXG4gIGhhbmRsZUNvbmZpcm0gKGhhbmRsZSwgZikge1xuICAgIHZhciB0YWcgPSBmLmRlbGl2ZXJ5VGFnO1xuICAgIHZhciBtdWx0aSA9IGYubXVsdGlwbGU7XG5cbiAgICBpZiAobXVsdGkpIHtcbiAgICAgIHZhciBjb25maXJtZWQgPSB0aGlzLnVuY29uZmlybWVkLnNwbGljZSgwLCB0YWcgLSB0aGlzLmx3bSArIDEpO1xuICAgICAgdGhpcy5sd20gPSB0YWcgKyAxO1xuICAgICAgY29uZmlybWVkLmZvckVhY2goaGFuZGxlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICB2YXIgYztcbiAgICAgIGlmICh0YWcgPT09IHRoaXMubHdtKSB7XG4gICAgICAgIGMgPSB0aGlzLnVuY29uZmlybWVkLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMubHdtKys7XG4gICAgICAgIC8vIEFkdmFuY2UgdGhlIExXTSBhbmQgdGhlIHdpbmRvdyB0byB0aGUgbmV4dCBub24tZ2FwLCBvclxuICAgICAgICAvLyBwb3NzaWJseSB0byB0aGUgZW5kXG4gICAgICAgIHdoaWxlICh0aGlzLnVuY29uZmlybWVkWzBdID09PSBudWxsKSB7XG4gICAgICAgICAgdGhpcy51bmNvbmZpcm1lZC5zaGlmdCgpO1xuICAgICAgICAgIHRoaXMubHdtKys7XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBjID0gdGhpcy51bmNvbmZpcm1lZFt0YWcgLSB0aGlzLmx3bV07XG4gICAgICAgIHRoaXMudW5jb25maXJtZWRbdGFnIC0gdGhpcy5sd21dID0gbnVsbDtcbiAgICAgIH1cbiAgICAgIC8vIFRlY2huaWNhbGx5LCBpbiB0aGUgc2luZ2xlLWRlbGl2ZXJ5VGFnIGNhc2UsIEkgc2hvdWxkIHJlcG9ydCBhXG4gICAgICAvLyBwcm90b2NvbCBicmVhY2ggaWYgaXQncyBhbHJlYWR5IGJlZW4gY29uZmlybWVkLlxuICAgICAgaGFuZGxlKGMpO1xuICAgIH1cbiAgfVxuXG4gIHB1c2hDb25maXJtQ2FsbGJhY2sgKGNiKSB7XG4gICAgLy8gYG51bGxgIGlzIHVzZWQgc3BlY2lmaWNhbGx5IGZvciBtYXJraW5nIGFscmVhZHkgY29uZmlybWVkIHNsb3RzLFxuICAgIC8vIHNvIEkgY29lcmNlIGB1bmRlZmluZWRgIGFuZCBgbnVsbGAgdG8gZmFsc2U7IGZ1bmN0aW9ucyBhcmUgbmV2ZXJcbiAgICAvLyBmYWxzZXkuXG4gICAgdGhpcy51bmNvbmZpcm1lZC5wdXNoKGNiIHx8IGZhbHNlKTtcbiAgfVxuXG4gIG9uQnVmZmVyRHJhaW4gKCkge1xuICAgIHRoaXMuZW1pdCgnZHJhaW4nKTtcbiAgfVxuXG4gIGFjY2VwdChmKSB7XG5cbiAgICBzd2l0Y2ggKGYuaWQpIHtcblxuICAgICAgLy8gTWVzc2FnZSBmcmFtZXNcbiAgICBjYXNlIHVuZGVmaW5lZDogLy8gY29udGVudCBmcmFtZSFcbiAgICBjYXNlIGRlZnMuQmFzaWNEZWxpdmVyOlxuICAgIGNhc2UgZGVmcy5CYXNpY1JldHVybjpcbiAgICBjYXNlIGRlZnMuQmFzaWNQcm9wZXJ0aWVzOlxuICAgICAgcmV0dXJuIHRoaXMuYWNjZXB0TWVzc2FnZUZyYW1lKGYpO1xuXG4gICAgICAvLyBjb25maXJtYXRpb25zLCBuZWVkIHRvIGRvIGNvbmZpcm0uc2VsZWN0IGZpcnN0XG4gICAgY2FzZSBkZWZzLkJhc2ljQWNrOlxuICAgICAgcmV0dXJuIHRoaXMuZW1pdCgnYWNrJywgZi5maWVsZHMpO1xuICAgIGNhc2UgZGVmcy5CYXNpY05hY2s6XG4gICAgICByZXR1cm4gdGhpcy5lbWl0KCduYWNrJywgZi5maWVsZHMpO1xuICAgIGNhc2UgZGVmcy5CYXNpY0NhbmNlbDpcbiAgICAgIC8vIFRoZSBicm9rZXIgY2FuIHNlbmQgdGhpcyBpZiBlLmcuLCB0aGUgcXVldWUgaXMgZGVsZXRlZC5cbiAgICAgIHJldHVybiB0aGlzLmVtaXQoJ2NhbmNlbCcsIGYuZmllbGRzKTtcblxuICAgIGNhc2UgZGVmcy5DaGFubmVsQ2xvc2U6XG4gICAgICAvLyBBbnkgcmVtb3RlIGNsb3N1cmUgaXMgYW4gZXJyb3IgdG8gdXMuIFJlamVjdCB0aGUgcGVuZGluZyByZXBseVxuICAgICAgLy8gd2l0aCB0aGUgY2xvc2UgZnJhbWUsIHNvIGl0IGNhbiBzZWUgd2hldGhlciBpdCB3YXMgdGhhdFxuICAgICAgLy8gb3BlcmF0aW9uIHRoYXQgY2F1c2VkIGl0IHRvIGNsb3NlLlxuICAgICAgaWYgKHRoaXMucmVwbHkpIHtcbiAgICAgICAgdmFyIHJlcGx5ID0gdGhpcy5yZXBseTsgdGhpcy5yZXBseSA9IG51bGw7XG4gICAgICAgIHJlcGx5KGYpO1xuICAgICAgfVxuICAgICAgdmFyIGVtc2cgPSBcIkNoYW5uZWwgY2xvc2VkIGJ5IHNlcnZlcjogXCIgKyBjbG9zZU1zZyhmKTtcbiAgICAgIHRoaXMuc2VuZEltbWVkaWF0ZWx5KGRlZnMuQ2hhbm5lbENsb3NlT2ssIHt9KTtcblxuICAgICAgdmFyIGVycm9yID0gbmV3IEVycm9yKGVtc2cpO1xuICAgICAgZXJyb3IuY29kZSA9IGYuZmllbGRzLnJlcGx5Q29kZTtcbiAgICAgIGVycm9yLmNsYXNzSWQgPSBmLmZpZWxkcy5jbGFzc0lkO1xuICAgICAgZXJyb3IubWV0aG9kSWQgPSBmLmZpZWxkcy5tZXRob2RJZDtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG5cbiAgICAgIHZhciBzID0gc3RhY2tDYXB0dXJlKGVtc2cpO1xuICAgICAgdGhpcy50b0Nsb3NlZChzKTtcbiAgICAgIHJldHVybjtcblxuICAgIGNhc2UgZGVmcy5CYXNpY0Zsb3c6XG4gICAgICAvLyBSYWJiaXRNUSBkb2Vzbid0IHNlbmQgdGhpcywgaXQganVzdCBibG9ja3MgdGhlIFRDUCBzb2NrZXRcbiAgICAgIHJldHVybiB0aGlzLmNsb3NlV2l0aEVycm9yKGYuaWQsIFwiRmxvdyBub3QgaW1wbGVtZW50ZWRcIixcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIGRlZnMuY29uc3RhbnRzLk5PVF9JTVBMRU1FTlRFRCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIG5ldyBFcnJvcignRmxvdyBub3QgaW1wbGVtZW50ZWQnKSk7XG5cbiAgICBkZWZhdWx0OiAvLyBhc3N1bWUgYWxsIG90aGVyIHRoaW5ncyBhcmUgcmVwbGllc1xuICAgICAgLy8gUmVzb2x2aW5nIHRoZSByZXBseSBtYXkgbGVhZCB0byBhbm90aGVyIFJQQzsgdG8gbWFrZSBzdXJlIHdlXG4gICAgICAvLyBkb24ndCBob2xkIHRoYXQgdXAsIGNsZWFyIHRoaXMucmVwbHlcbiAgICAgIHZhciByZXBseSA9IHRoaXMucmVwbHk7IHRoaXMucmVwbHkgPSBudWxsO1xuICAgICAgLy8gaG93ZXZlciwgbWF5YmUgdGhlcmUncyBhbiBSUEMgd2FpdGluZyB0byBnbz8gSWYgc28sIHRoYXQnbGxcbiAgICAgIC8vIGZpbGwgdGhpcy5yZXBseSBhZ2FpbiwgcmVzdG9yaW5nIHRoZSBpbnZhcmlhbnQuIFRoaXMgZG9lcyByZWx5XG4gICAgICAvLyBvbiBhbnkgcmVzcG9uc2UgYmVpbmcgcmVjdidlZCBhZnRlciByZXNvbHZpbmcgdGhlIHByb21pc2UsXG4gICAgICAvLyBiZWxvdzsgaGVuY2UsIEkgdXNlIHN5bmNocm9ub3VzIGRlZmVyLlxuICAgICAgaWYgKHRoaXMucGVuZGluZy5sZW5ndGggPiAwKSB7XG4gICAgICAgIHZhciBzZW5kID0gdGhpcy5wZW5kaW5nLnNoaWZ0KCk7XG4gICAgICAgIHRoaXMucmVwbHkgPSBzZW5kLnJlcGx5O1xuICAgICAgICB0aGlzLnNlbmRJbW1lZGlhdGVseShzZW5kLm1ldGhvZCwgc2VuZC5maWVsZHMpO1xuICAgICAgfVxuICAgICAgcmV0dXJuIHJlcGx5KG51bGwsIGYpO1xuICAgIH1cbiAgfVxufVxuXG4vLyBTaHV0ZG93biBwcm90b2NvbC4gVGhlcmUncyB0aHJlZSBzY2VuYXJpb3M6XG4vL1xuLy8gMS4gVGhlIGFwcGxpY2F0aW9uIGRlY2lkZXMgdG8gc2h1dCB0aGUgY2hhbm5lbFxuLy8gMi4gVGhlIHNlcnZlciBkZWNpZGVzIHRvIHNodXQgdGhlIGNoYW5uZWwsIHBvc3NpYmx5IGJlY2F1c2Ugb2Zcbi8vIHNvbWV0aGluZyB0aGUgYXBwbGljYXRpb24gZGlkXG4vLyAzLiBUaGUgY29ubmVjdGlvbiBpcyBjbG9zaW5nLCBzbyB0aGVyZSB3b24ndCBiZSBhbnkgbW9yZSBmcmFtZXNcbi8vIGdvaW5nIGJhY2sgYW5kIGZvcnRoLlxuLy9cbi8vIDEgYW5kIDIgaW52b2x2ZSBhbiBleGNoYW5nZSBvZiBtZXRob2QgZnJhbWVzIChDbG9zZSBhbmQgQ2xvc2VPayksXG4vLyB3aGlsZSAzIGRvZXNuJ3Q7IHRoZSBjb25uZWN0aW9uIHNpbXBseSBzYXlzIFwic2h1dGRvd25cIiB0byB0aGVcbi8vIGNoYW5uZWwsIHdoaWNoIHRoZW4gYWN0cyBhcyBpZiBpdCdzIGNsb3NpbmcsIHdpdGhvdXQgZ29pbmcgdGhyb3VnaFxuLy8gdGhlIGV4Y2hhbmdlLlxuXG5mdW5jdGlvbiBpbnZhbGlkT3AobXNnLCBzdGFjaykge1xuICByZXR1cm4gZnVuY3Rpb24oKSB7XG4gICAgdGhyb3cgbmV3IElsbGVnYWxPcGVyYXRpb25FcnJvcihtc2csIHN0YWNrKTtcbiAgfTtcbn1cblxuZnVuY3Rpb24gaW52YWxpZGF0ZVNlbmQoY2gsIG1zZywgc3RhY2spIHtcbiAgY2guc2VuZEltbWVkaWF0ZWx5ID0gY2guc2VuZE9yRW5xdWV1ZSA9IGNoLnNlbmRNZXNzYWdlID1cbiAgICBpbnZhbGlkT3AobXNnLCBzdGFjayk7XG59XG5cbi8vIEtpY2sgb2ZmIGEgbWVzc2FnZSBkZWxpdmVyeSBnaXZlbiBhIEJhc2ljRGVsaXZlciBvciBCYXNpY1JldHVyblxuLy8gZnJhbWUgKEJhc2ljR2V0IHVzZXMgdGhlIFJQQyBtZWNoYW5pc20pXG5mdW5jdGlvbiBhY2NlcHREZWxpdmVyeU9yUmV0dXJuKGYpIHtcbiAgdmFyIGV2ZW50O1xuICBpZiAoZi5pZCA9PT0gZGVmcy5CYXNpY0RlbGl2ZXIpIGV2ZW50ID0gJ2RlbGl2ZXJ5JztcbiAgZWxzZSBpZiAoZi5pZCA9PT0gZGVmcy5CYXNpY1JldHVybikgZXZlbnQgPSAncmV0dXJuJztcbiAgZWxzZSB0aHJvdyBmbXQoXCJFeHBlY3RlZCBCYXNpY0RlbGl2ZXIgb3IgQmFzaWNSZXR1cm47IGdvdCAlc1wiLFxuICAgICAgICAgICAgICAgICBpbnNwZWN0KGYpKTtcblxuICB2YXIgc2VsZiA9IHRoaXM7XG4gIHZhciBmaWVsZHMgPSBmLmZpZWxkcztcbiAgcmV0dXJuIGFjY2VwdE1lc3NhZ2UoZnVuY3Rpb24obWVzc2FnZSkge1xuICAgIG1lc3NhZ2UuZmllbGRzID0gZmllbGRzO1xuICAgIHNlbGYuZW1pdChldmVudCwgbWVzc2FnZSk7XG4gIH0pO1xufVxuXG4vLyBNb3ZlIHRvIHRoZSBzdGF0ZSBvZiB3YWl0aW5nIGZvciBtZXNzYWdlIGZyYW1lcyAoaGVhZGVycywgdGhlblxuLy8gb25lIG9yIG1vcmUgY29udGVudCBmcmFtZXMpXG5mdW5jdGlvbiBhY2NlcHRNZXNzYWdlKGNvbnRpbnVhdGlvbikge1xuICB2YXIgdG90YWxTaXplID0gMCwgcmVtYWluaW5nID0gMDtcbiAgdmFyIGJ1ZmZlcnMgPSBudWxsO1xuXG4gIHZhciBtZXNzYWdlID0ge1xuICAgIGZpZWxkczogbnVsbCxcbiAgICBwcm9wZXJ0aWVzOiBudWxsLFxuICAgIGNvbnRlbnQ6IG51bGxcbiAgfTtcblxuICByZXR1cm4gaGVhZGVycztcblxuICAvLyBleHBlY3QgYSBoZWFkZXJzIGZyYW1lXG4gIGZ1bmN0aW9uIGhlYWRlcnMoZikge1xuICAgIGlmIChmLmlkID09PSBkZWZzLkJhc2ljUHJvcGVydGllcykge1xuICAgICAgbWVzc2FnZS5wcm9wZXJ0aWVzID0gZi5maWVsZHM7XG4gICAgICB0b3RhbFNpemUgPSByZW1haW5pbmcgPSBmLnNpemU7XG5cbiAgICAgIC8vIGZvciB6ZXJvLWxlbmd0aCBtZXNzYWdlcywgY29udGVudCBmcmFtZXMgYXJlbid0IHJlcXVpcmVkLlxuICAgICAgaWYgKHRvdGFsU2l6ZSA9PT0gMCkge1xuICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSBCdWZmZXIuYWxsb2MoMCk7XG4gICAgICAgIGNvbnRpbnVhdGlvbihtZXNzYWdlKTtcbiAgICAgICAgcmV0dXJuIGFjY2VwdERlbGl2ZXJ5T3JSZXR1cm47XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgXCJFeHBlY3RlZCBoZWFkZXJzIGZyYW1lIGFmdGVyIGRlbGl2ZXJ5XCI7XG4gICAgfVxuICB9XG5cbiAgLy8gZXhwZWN0IGEgY29udGVudCBmcmFtZVxuICAvLyAlJSUgVE9ETyBjYW5jZWxsZWQgbWVzc2FnZXMgKHNlbnQgYXMgemVyby1sZW5ndGggY29udGVudCBmcmFtZSlcbiAgZnVuY3Rpb24gY29udGVudChmKSB7XG4gICAgaWYgKGYuY29udGVudCkge1xuICAgICAgdmFyIHNpemUgPSBmLmNvbnRlbnQubGVuZ3RoO1xuICAgICAgcmVtYWluaW5nIC09IHNpemU7XG4gICAgICBpZiAocmVtYWluaW5nID09PSAwKSB7XG4gICAgICAgIGlmIChidWZmZXJzICE9PSBudWxsKSB7XG4gICAgICAgICAgYnVmZmVycy5wdXNoKGYuY29udGVudCk7XG4gICAgICAgICAgbWVzc2FnZS5jb250ZW50ID0gQnVmZmVyLmNvbmNhdChidWZmZXJzKTtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBtZXNzYWdlLmNvbnRlbnQgPSBmLmNvbnRlbnQ7XG4gICAgICAgIH1cbiAgICAgICAgY29udGludWF0aW9uKG1lc3NhZ2UpO1xuICAgICAgICByZXR1cm4gYWNjZXB0RGVsaXZlcnlPclJldHVybjtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHJlbWFpbmluZyA8IDApIHtcbiAgICAgICAgdGhyb3cgZm10KFwiVG9vIG11Y2ggY29udGVudCBzZW50ISBFeHBlY3RlZCAlZCBieXRlc1wiLFxuICAgICAgICAgICAgICAgICAgdG90YWxTaXplKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBpZiAoYnVmZmVycyAhPT0gbnVsbClcbiAgICAgICAgICBidWZmZXJzLnB1c2goZi5jb250ZW50KTtcbiAgICAgICAgZWxzZVxuICAgICAgICAgIGJ1ZmZlcnMgPSBbZi5jb250ZW50XTtcbiAgICAgICAgcmV0dXJuIGNvbnRlbnQ7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2UgdGhyb3cgXCJFeHBlY3RlZCBjb250ZW50IGZyYW1lIGFmdGVyIGhlYWRlcnNcIlxuICB9XG59XG5cbi8vIFRoaXMgYWRkcyBqdXN0IGEgYml0IG1vcmUgc3R1ZmYgdXNlZnVsIGZvciB0aGUgQVBJcywgYnV0IG5vdFxuLy8gbG93LWxldmVsIG1hY2hpbmVyeS5cbmNsYXNzIEJhc2VDaGFubmVsIGV4dGVuZHMgQ2hhbm5lbCB7XG4gIGNvbnN0cnVjdG9yIChjb25uZWN0aW9uKSB7XG4gICAgc3VwZXIoY29ubmVjdGlvbik7XG4gICAgdGhpcy5jb25zdW1lcnMgPSBuZXcgTWFwKCk7XG4gIH1cblxuICAvLyBOb3Qgc3VyZSBJIGxpa2UgdGhlIGZmLCBpdCdzIGdvaW5nIHRvIGJlIGNoYW5naW5nIGhpZGRlbiBjbGFzc2VzXG4gIC8vIGFsbCBvdmVyIHRoZSBwbGFjZS4gT24gdGhlIG90aGVyIGhhbmQsIHdoYWRkeWEgZG8uXG4gIHJlZ2lzdGVyQ29uc3VtZXIgKHRhZywgY2FsbGJhY2spIHtcbiAgICB0aGlzLmNvbnN1bWVycy5zZXQodGFnLCBjYWxsYmFjayk7XG4gIH1cblxuICB1bnJlZ2lzdGVyQ29uc3VtZXIgKHRhZykge1xuICAgIHRoaXMuY29uc3VtZXJzLmRlbGV0ZSh0YWcpO1xuICB9XG5cbiAgZGlzcGF0Y2hNZXNzYWdlIChmaWVsZHMsIG1lc3NhZ2UpIHtcbiAgICB2YXIgY29uc3VtZXJUYWcgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gICAgdmFyIGNvbnN1bWVyID0gdGhpcy5jb25zdW1lcnMuZ2V0KGNvbnN1bWVyVGFnKTtcbiAgICBpZiAoY29uc3VtZXIpIHtcbiAgICAgIHJldHVybiBjb25zdW1lcihtZXNzYWdlKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICAvLyAlJSUgU3VyZWx5IGEgcmFjZSBoZXJlXG4gICAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNvbnN1bWVyOiBcIiArIGNvbnN1bWVyVGFnKTtcbiAgICB9XG4gIH1cblxuICBoYW5kbGVEZWxpdmVyeSAobWVzc2FnZSkge1xuICAgIHJldHVybiB0aGlzLmRpc3BhdGNoTWVzc2FnZShtZXNzYWdlLmZpZWxkcywgbWVzc2FnZSk7XG4gIH1cblxuICBoYW5kbGVDYW5jZWwgKGZpZWxkcykge1xuICAgIHZhciByZXN1bHQgPSB0aGlzLmRpc3BhdGNoTWVzc2FnZShmaWVsZHMsIG51bGwpO1xuICAgIHRoaXMudW5yZWdpc3RlckNvbnN1bWVyKGZpZWxkcy5jb25zdW1lclRhZyk7XG4gICAgcmV0dXJuIHJlc3VsdDtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5hY2NlcHRNZXNzYWdlID0gYWNjZXB0TWVzc2FnZTtcbm1vZHVsZS5leHBvcnRzLkJhc2VDaGFubmVsID0gQmFzZUNoYW5uZWw7XG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsID0gQ2hhbm5lbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/channel.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/channel_model.js":
/*!***************************************************!*\
  !*** ./node_modules/amqplib/lib/channel_model.js ***!
  \***************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("//\n//\n//\n\n\n\nconst EventEmitter = __webpack_require__(/*! events */ \"events\");\nconst promisify = (__webpack_require__(/*! util */ \"util\").promisify);\nconst defs = __webpack_require__(/*! ./defs */ \"(rsc)/./node_modules/amqplib/lib/defs.js\");\nconst {BaseChannel} = __webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/amqplib/lib/channel.js\");\nconst {acceptMessage} = __webpack_require__(/*! ./channel */ \"(rsc)/./node_modules/amqplib/lib/channel.js\");\nconst Args = __webpack_require__(/*! ./api_args */ \"(rsc)/./node_modules/amqplib/lib/api_args.js\");\nconst {inspect} = __webpack_require__(/*! ./format */ \"(rsc)/./node_modules/amqplib/lib/format.js\");\n\nclass ChannelModel extends EventEmitter {\n  constructor(connection) {\n    super();\n    this.connection = connection;\n\n    ['error', 'close', 'blocked', 'unblocked'].forEach(ev => {\n      connection.on(ev, this.emit.bind(this, ev));\n    });\n  }\n\n  close() {\n    return promisify(this.connection.close.bind(this.connection))();\n  }\n\n  updateSecret(newSecret, reason) {\n    return promisify(this.connection._updateSecret.bind(this.connection))(newSecret, reason);\n  }\n\n  async createChannel() {\n    const channel = new Channel(this.connection);\n    await channel.open();\n    return channel;\n  }\n\n  async createConfirmChannel() {\n    const channel = new ConfirmChannel(this.connection);\n    await channel.open();\n    await channel.rpc(defs.ConfirmSelect, {nowait: false}, defs.ConfirmSelectOk);\n    return channel;\n  }\n}\n\n// Channels\n\nclass Channel extends BaseChannel {\n  constructor(connection) {\n    super(connection);\n    this.on('delivery', this.handleDelivery.bind(this));\n    this.on('cancel', this.handleCancel.bind(this));\n  }\n\n  // An RPC that returns a 'proper' promise, which resolves to just the\n  // response's fields; this is intended to be suitable for implementing\n  // API procedures.\n  async rpc(method, fields, expect) {\n    const f = await promisify(cb => {\n      return this._rpc(method, fields, expect, cb);\n    })();\n\n    return f.fields;\n  }\n\n  // Do the remarkably simple channel open handshake\n  async open() {\n    const ch = await this.allocate.bind(this)();\n    return ch.rpc(defs.ChannelOpen, {outOfBand: \"\"},\n                  defs.ChannelOpenOk);\n  }\n\n  close() {\n    return promisify(cb => {\n      return this.closeBecause(\"Goodbye\", defs.constants.REPLY_SUCCESS,\n                      cb);\n    })();\n  }\n\n  // === Public API, declaring queues and stuff ===\n\n  assertQueue(queue, options) {\n    return this.rpc(defs.QueueDeclare,\n                    Args.assertQueue(queue, options),\n                    defs.QueueDeclareOk);\n  }\n\n  checkQueue(queue) {\n    return this.rpc(defs.QueueDeclare,\n                    Args.checkQueue(queue),\n                    defs.QueueDeclareOk);\n  }\n\n  deleteQueue(queue, options) {\n    return this.rpc(defs.QueueDelete,\n                    Args.deleteQueue(queue, options),\n                    defs.QueueDeleteOk);\n  }\n\n  purgeQueue(queue) {\n    return this.rpc(defs.QueuePurge,\n                    Args.purgeQueue(queue),\n                    defs.QueuePurgeOk);\n  }\n\n  bindQueue(queue, source, pattern, argt) {\n    return this.rpc(defs.QueueBind,\n                    Args.bindQueue(queue, source, pattern, argt),\n                    defs.QueueBindOk);\n  }\n\n  unbindQueue(queue, source, pattern, argt) {\n    return this.rpc(defs.QueueUnbind,\n                    Args.unbindQueue(queue, source, pattern, argt),\n                    defs.QueueUnbindOk);\n  }\n\n  assertExchange(exchange, type, options) {\n    // The server reply is an empty set of fields, but it's convenient\n    // to have the exchange name handed to the continuation.\n    return this.rpc(defs.ExchangeDeclare,\n                    Args.assertExchange(exchange, type, options),\n                    defs.ExchangeDeclareOk)\n      .then(_ok => { return { exchange }; });\n  }\n\n  checkExchange(exchange) {\n    return this.rpc(defs.ExchangeDeclare,\n                    Args.checkExchange(exchange),\n                    defs.ExchangeDeclareOk);\n  }\n\n  deleteExchange(name, options) {\n    return this.rpc(defs.ExchangeDelete,\n                    Args.deleteExchange(name, options),\n                    defs.ExchangeDeleteOk);\n  }\n\n  bindExchange(dest, source, pattern, argt) {\n    return this.rpc(defs.ExchangeBind,\n                    Args.bindExchange(dest, source, pattern, argt),\n                    defs.ExchangeBindOk);\n  }\n\n  unbindExchange(dest, source, pattern, argt) {\n    return this.rpc(defs.ExchangeUnbind,\n                    Args.unbindExchange(dest, source, pattern, argt),\n                    defs.ExchangeUnbindOk);\n  }\n\n  // Working with messages\n\n  publish(exchange, routingKey, content, options) {\n    const fieldsAndProps = Args.publish(exchange, routingKey, options);\n    return this.sendMessage(fieldsAndProps, fieldsAndProps, content);\n  }\n\n  sendToQueue(queue, content, options) {\n    return this.publish('', queue, content, options);\n  }\n\n  consume(queue, callback, options) {\n    // NB we want the callback to be run synchronously, so that we've\n    // registered the consumerTag before any messages can arrive.\n    const fields = Args.consume(queue, options);\n    return new Promise((resolve, reject) => {\n      this._rpc(defs.BasicConsume, fields, defs.BasicConsumeOk, (err, ok) => {\n        if (err) return reject(err);\n        this.registerConsumer(ok.fields.consumerTag, callback);\n        resolve(ok.fields);\n      });\n    });\n  }\n\n  async cancel(consumerTag) {\n    const ok = await promisify(cb => {\n      this._rpc(defs.BasicCancel, Args.cancel(consumerTag),\n            defs.BasicCancelOk,\n            cb);\n    })()\n    .then(ok => {\n      this.unregisterConsumer(consumerTag);\n      return ok.fields;\n    });\n  }\n\n  get(queue, options) {\n    const fields = Args.get(queue, options);\n    return new Promise((resolve, reject) => {\n      this.sendOrEnqueue(defs.BasicGet, fields, (err, f) => {\n        if (err) return reject(err);\n        if (f.id === defs.BasicGetEmpty) {\n          return resolve(false);\n        }\n        else if (f.id === defs.BasicGetOk) {\n          const fields = f.fields;\n          this.handleMessage = acceptMessage(m => {\n            m.fields = fields;\n            resolve(m);\n          });\n        }\n        else {\n          reject(new Error(`Unexpected response to BasicGet: ${inspect(f)}`));\n        }\n      });\n    });\n  }\n\n  ack(message, allUpTo) {\n    this.sendImmediately(\n      defs.BasicAck,\n      Args.ack(message.fields.deliveryTag, allUpTo));\n  }\n\n  ackAll() {\n    this.sendImmediately(defs.BasicAck, Args.ack(0, true));\n  }\n\n  nack(message, allUpTo, requeue) {\n    this.sendImmediately(\n      defs.BasicNack,\n      Args.nack(message.fields.deliveryTag, allUpTo, requeue));\n  }\n\n  nackAll(requeue) {\n    this.sendImmediately(defs.BasicNack,\n                         Args.nack(0, true, requeue));\n  }\n\n  // `Basic.Nack` is not available in older RabbitMQ versions (or in the\n  // AMQP specification), so you have to use the one-at-a-time\n  // `Basic.Reject`. This is otherwise synonymous with\n  // `#nack(message, false, requeue)`.\n  reject(message, requeue) {\n    this.sendImmediately(\n      defs.BasicReject,\n      Args.reject(message.fields.deliveryTag, requeue));\n  }\n\n  recover() {\n    return this.rpc(defs.BasicRecover,\n                    Args.recover(),\n                    defs.BasicRecoverOk);\n  }\n\n  qos(count, global) {\n    return this.rpc(defs.BasicQos,\n                    Args.prefetch(count, global),\n                    defs.BasicQosOk);\n  }\n}\n\n// There are more options in AMQP than exposed here; RabbitMQ only\n// implements prefetch based on message count, and only for individual\n// channels or consumers. RabbitMQ v3.3.0 and after treat prefetch\n// (without `global` set) as per-consumer (for consumers following),\n// and prefetch with `global` set as per-channel.\nChannel.prototype.prefetch = Channel.prototype.qos\n\n// Confirm channel. This is a channel with confirms 'switched on',\n// meaning sent messages will provoke a responding 'ack' or 'nack'\n// from the server. The upshot of this is that `publish` and\n// `sendToQueue` both take a callback, which will be called either\n// with `null` as its argument to signify 'ack', or an exception as\n// its argument to signify 'nack'.\n\nclass ConfirmChannel extends Channel {\n  publish(exchange, routingKey, content, options, cb) {\n    this.pushConfirmCallback(cb);\n    return super.publish(exchange, routingKey, content, options);\n  }\n\n  sendToQueue(queue, content, options, cb) {\n    return this.publish('', queue, content, options, cb);\n  }\n\n  waitForConfirms() {\n    const awaiting = [];\n    const unconfirmed = this.unconfirmed;\n    unconfirmed.forEach((val, index) => {\n      if (val !== null) {\n        const confirmed = new Promise((resolve, reject) => {\n          unconfirmed[index] = err => {\n            if (val) val(err);\n            if (err === null) resolve();\n            else reject(err);\n          };\n        });\n        awaiting.push(confirmed);\n      }\n    });\n    // Channel closed\n    if (!this.pending) {\n      var cb;\n      while (cb = this.unconfirmed.shift()) {\n        if (cb) cb(new Error('channel closed'));\n      }\n    }\n    return Promise.all(awaiting);\n  }\n}\n\nmodule.exports.ConfirmChannel = ConfirmChannel;\nmodule.exports.Channel = Channel;\nmodule.exports.ChannelModel = ChannelModel;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY2hhbm5lbF9tb2RlbC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIscUJBQXFCLG1CQUFPLENBQUMsc0JBQVE7QUFDckMsa0JBQWtCLG1EQUF5QjtBQUMzQyxhQUFhLG1CQUFPLENBQUMsd0RBQVE7QUFDN0IsT0FBTyxhQUFhLEVBQUUsbUJBQU8sQ0FBQyw4REFBVztBQUN6QyxPQUFPLGVBQWUsRUFBRSxtQkFBTyxDQUFDLDhEQUFXO0FBQzNDLGFBQWEsbUJBQU8sQ0FBQyxnRUFBWTtBQUNqQyxPQUFPLFNBQVMsRUFBRSxtQkFBTyxDQUFDLDREQUFVOztBQUVwQztBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMsY0FBYztBQUN6RDtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esd0JBQXdCO0FBQ3hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSzs7QUFFTDtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyxjQUFjO0FBQ25EO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUJBQXFCLFNBQVMsYUFBYTtBQUMzQzs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1AsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsV0FBVztBQUNYO0FBQ0E7QUFDQSwrREFBK0QsV0FBVztBQUMxRTtBQUNBLE9BQU87QUFDUCxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscURBQXFEO0FBQ3JEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7QUFDN0Isc0JBQXNCO0FBQ3RCLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjIvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY2hhbm5lbF9tb2RlbC5qcz8xNWU1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vL1xuLy9cblxuJ3VzZSBzdHJpY3QnO1xuXG5jb25zdCBFdmVudEVtaXR0ZXIgPSByZXF1aXJlKCdldmVudHMnKTtcbmNvbnN0IHByb21pc2lmeSA9IHJlcXVpcmUoJ3V0aWwnKS5wcm9taXNpZnk7XG5jb25zdCBkZWZzID0gcmVxdWlyZSgnLi9kZWZzJyk7XG5jb25zdCB7QmFzZUNoYW5uZWx9ID0gcmVxdWlyZSgnLi9jaGFubmVsJyk7XG5jb25zdCB7YWNjZXB0TWVzc2FnZX0gPSByZXF1aXJlKCcuL2NoYW5uZWwnKTtcbmNvbnN0IEFyZ3MgPSByZXF1aXJlKCcuL2FwaV9hcmdzJyk7XG5jb25zdCB7aW5zcGVjdH0gPSByZXF1aXJlKCcuL2Zvcm1hdCcpO1xuXG5jbGFzcyBDaGFubmVsTW9kZWwgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3Rvcihjb25uZWN0aW9uKSB7XG4gICAgc3VwZXIoKTtcbiAgICB0aGlzLmNvbm5lY3Rpb24gPSBjb25uZWN0aW9uO1xuXG4gICAgWydlcnJvcicsICdjbG9zZScsICdibG9ja2VkJywgJ3VuYmxvY2tlZCddLmZvckVhY2goZXYgPT4ge1xuICAgICAgY29ubmVjdGlvbi5vbihldiwgdGhpcy5lbWl0LmJpbmQodGhpcywgZXYpKTtcbiAgICB9KTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBwcm9taXNpZnkodGhpcy5jb25uZWN0aW9uLmNsb3NlLmJpbmQodGhpcy5jb25uZWN0aW9uKSkoKTtcbiAgfVxuXG4gIHVwZGF0ZVNlY3JldChuZXdTZWNyZXQsIHJlYXNvbikge1xuICAgIHJldHVybiBwcm9taXNpZnkodGhpcy5jb25uZWN0aW9uLl91cGRhdGVTZWNyZXQuYmluZCh0aGlzLmNvbm5lY3Rpb24pKShuZXdTZWNyZXQsIHJlYXNvbik7XG4gIH1cblxuICBhc3luYyBjcmVhdGVDaGFubmVsKCkge1xuICAgIGNvbnN0IGNoYW5uZWwgPSBuZXcgQ2hhbm5lbCh0aGlzLmNvbm5lY3Rpb24pO1xuICAgIGF3YWl0IGNoYW5uZWwub3BlbigpO1xuICAgIHJldHVybiBjaGFubmVsO1xuICB9XG5cbiAgYXN5bmMgY3JlYXRlQ29uZmlybUNoYW5uZWwoKSB7XG4gICAgY29uc3QgY2hhbm5lbCA9IG5ldyBDb25maXJtQ2hhbm5lbCh0aGlzLmNvbm5lY3Rpb24pO1xuICAgIGF3YWl0IGNoYW5uZWwub3BlbigpO1xuICAgIGF3YWl0IGNoYW5uZWwucnBjKGRlZnMuQ29uZmlybVNlbGVjdCwge25vd2FpdDogZmFsc2V9LCBkZWZzLkNvbmZpcm1TZWxlY3RPayk7XG4gICAgcmV0dXJuIGNoYW5uZWw7XG4gIH1cbn1cblxuLy8gQ2hhbm5lbHNcblxuY2xhc3MgQ2hhbm5lbCBleHRlbmRzIEJhc2VDaGFubmVsIHtcbiAgY29uc3RydWN0b3IoY29ubmVjdGlvbikge1xuICAgIHN1cGVyKGNvbm5lY3Rpb24pO1xuICAgIHRoaXMub24oJ2RlbGl2ZXJ5JywgdGhpcy5oYW5kbGVEZWxpdmVyeS5iaW5kKHRoaXMpKTtcbiAgICB0aGlzLm9uKCdjYW5jZWwnLCB0aGlzLmhhbmRsZUNhbmNlbC5iaW5kKHRoaXMpKTtcbiAgfVxuXG4gIC8vIEFuIFJQQyB0aGF0IHJldHVybnMgYSAncHJvcGVyJyBwcm9taXNlLCB3aGljaCByZXNvbHZlcyB0byBqdXN0IHRoZVxuICAvLyByZXNwb25zZSdzIGZpZWxkczsgdGhpcyBpcyBpbnRlbmRlZCB0byBiZSBzdWl0YWJsZSBmb3IgaW1wbGVtZW50aW5nXG4gIC8vIEFQSSBwcm9jZWR1cmVzLlxuICBhc3luYyBycGMobWV0aG9kLCBmaWVsZHMsIGV4cGVjdCkge1xuICAgIGNvbnN0IGYgPSBhd2FpdCBwcm9taXNpZnkoY2IgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuX3JwYyhtZXRob2QsIGZpZWxkcywgZXhwZWN0LCBjYik7XG4gICAgfSkoKTtcblxuICAgIHJldHVybiBmLmZpZWxkcztcbiAgfVxuXG4gIC8vIERvIHRoZSByZW1hcmthYmx5IHNpbXBsZSBjaGFubmVsIG9wZW4gaGFuZHNoYWtlXG4gIGFzeW5jIG9wZW4oKSB7XG4gICAgY29uc3QgY2ggPSBhd2FpdCB0aGlzLmFsbG9jYXRlLmJpbmQodGhpcykoKTtcbiAgICByZXR1cm4gY2gucnBjKGRlZnMuQ2hhbm5lbE9wZW4sIHtvdXRPZkJhbmQ6IFwiXCJ9LFxuICAgICAgICAgICAgICAgICAgZGVmcy5DaGFubmVsT3Blbk9rKTtcbiAgfVxuXG4gIGNsb3NlKCkge1xuICAgIHJldHVybiBwcm9taXNpZnkoY2IgPT4ge1xuICAgICAgcmV0dXJuIHRoaXMuY2xvc2VCZWNhdXNlKFwiR29vZGJ5ZVwiLCBkZWZzLmNvbnN0YW50cy5SRVBMWV9TVUNDRVNTLFxuICAgICAgICAgICAgICAgICAgICAgIGNiKTtcbiAgICB9KSgpO1xuICB9XG5cbiAgLy8gPT09IFB1YmxpYyBBUEksIGRlY2xhcmluZyBxdWV1ZXMgYW5kIHN0dWZmID09PVxuXG4gIGFzc2VydFF1ZXVlKHF1ZXVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuUXVldWVEZWNsYXJlLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLmFzc2VydFF1ZXVlKHF1ZXVlLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5RdWV1ZURlY2xhcmVPayk7XG4gIH1cblxuICBjaGVja1F1ZXVlKHF1ZXVlKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuUXVldWVEZWNsYXJlLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLmNoZWNrUXVldWUocXVldWUpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLlF1ZXVlRGVjbGFyZU9rKTtcbiAgfVxuXG4gIGRlbGV0ZVF1ZXVlKHF1ZXVlLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuUXVldWVEZWxldGUsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MuZGVsZXRlUXVldWUocXVldWUsIG9wdGlvbnMpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLlF1ZXVlRGVsZXRlT2spO1xuICB9XG5cbiAgcHVyZ2VRdWV1ZShxdWV1ZSkge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLlF1ZXVlUHVyZ2UsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MucHVyZ2VRdWV1ZShxdWV1ZSksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuUXVldWVQdXJnZU9rKTtcbiAgfVxuXG4gIGJpbmRRdWV1ZShxdWV1ZSwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuUXVldWVCaW5kLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLmJpbmRRdWV1ZShxdWV1ZSwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5RdWV1ZUJpbmRPayk7XG4gIH1cblxuICB1bmJpbmRRdWV1ZShxdWV1ZSwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuUXVldWVVbmJpbmQsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MudW5iaW5kUXVldWUocXVldWUsIHNvdXJjZSwgcGF0dGVybiwgYXJndCksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuUXVldWVVbmJpbmRPayk7XG4gIH1cblxuICBhc3NlcnRFeGNoYW5nZShleGNoYW5nZSwgdHlwZSwgb3B0aW9ucykge1xuICAgIC8vIFRoZSBzZXJ2ZXIgcmVwbHkgaXMgYW4gZW1wdHkgc2V0IG9mIGZpZWxkcywgYnV0IGl0J3MgY29udmVuaWVudFxuICAgIC8vIHRvIGhhdmUgdGhlIGV4Y2hhbmdlIG5hbWUgaGFuZGVkIHRvIHRoZSBjb250aW51YXRpb24uXG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuRXhjaGFuZ2VEZWNsYXJlLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLmFzc2VydEV4Y2hhbmdlKGV4Y2hhbmdlLCB0eXBlLCBvcHRpb25zKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5FeGNoYW5nZURlY2xhcmVPaylcbiAgICAgIC50aGVuKF9vayA9PiB7IHJldHVybiB7IGV4Y2hhbmdlIH07IH0pO1xuICB9XG5cbiAgY2hlY2tFeGNoYW5nZShleGNoYW5nZSkge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLkV4Y2hhbmdlRGVjbGFyZSxcbiAgICAgICAgICAgICAgICAgICAgQXJncy5jaGVja0V4Y2hhbmdlKGV4Y2hhbmdlKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5FeGNoYW5nZURlY2xhcmVPayk7XG4gIH1cblxuICBkZWxldGVFeGNoYW5nZShuYW1lLCBvcHRpb25zKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuRXhjaGFuZ2VEZWxldGUsXG4gICAgICAgICAgICAgICAgICAgIEFyZ3MuZGVsZXRlRXhjaGFuZ2UobmFtZSwgb3B0aW9ucyksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuRXhjaGFuZ2VEZWxldGVPayk7XG4gIH1cblxuICBiaW5kRXhjaGFuZ2UoZGVzdCwgc291cmNlLCBwYXR0ZXJuLCBhcmd0KSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuRXhjaGFuZ2VCaW5kLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLmJpbmRFeGNoYW5nZShkZXN0LCBzb3VyY2UsIHBhdHRlcm4sIGFyZ3QpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLkV4Y2hhbmdlQmluZE9rKTtcbiAgfVxuXG4gIHVuYmluZEV4Y2hhbmdlKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCkge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLkV4Y2hhbmdlVW5iaW5kLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLnVuYmluZEV4Y2hhbmdlKGRlc3QsIHNvdXJjZSwgcGF0dGVybiwgYXJndCksXG4gICAgICAgICAgICAgICAgICAgIGRlZnMuRXhjaGFuZ2VVbmJpbmRPayk7XG4gIH1cblxuICAvLyBXb3JraW5nIHdpdGggbWVzc2FnZXNcblxuICBwdWJsaXNoKGV4Y2hhbmdlLCByb3V0aW5nS2V5LCBjb250ZW50LCBvcHRpb25zKSB7XG4gICAgY29uc3QgZmllbGRzQW5kUHJvcHMgPSBBcmdzLnB1Ymxpc2goZXhjaGFuZ2UsIHJvdXRpbmdLZXksIG9wdGlvbnMpO1xuICAgIHJldHVybiB0aGlzLnNlbmRNZXNzYWdlKGZpZWxkc0FuZFByb3BzLCBmaWVsZHNBbmRQcm9wcywgY29udGVudCk7XG4gIH1cblxuICBzZW5kVG9RdWV1ZShxdWV1ZSwgY29udGVudCwgb3B0aW9ucykge1xuICAgIHJldHVybiB0aGlzLnB1Ymxpc2goJycsIHF1ZXVlLCBjb250ZW50LCBvcHRpb25zKTtcbiAgfVxuXG4gIGNvbnN1bWUocXVldWUsIGNhbGxiYWNrLCBvcHRpb25zKSB7XG4gICAgLy8gTkIgd2Ugd2FudCB0aGUgY2FsbGJhY2sgdG8gYmUgcnVuIHN5bmNocm9ub3VzbHksIHNvIHRoYXQgd2UndmVcbiAgICAvLyByZWdpc3RlcmVkIHRoZSBjb25zdW1lclRhZyBiZWZvcmUgYW55IG1lc3NhZ2VzIGNhbiBhcnJpdmUuXG4gICAgY29uc3QgZmllbGRzID0gQXJncy5jb25zdW1lKHF1ZXVlLCBvcHRpb25zKTtcbiAgICByZXR1cm4gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgdGhpcy5fcnBjKGRlZnMuQmFzaWNDb25zdW1lLCBmaWVsZHMsIGRlZnMuQmFzaWNDb25zdW1lT2ssIChlcnIsIG9rKSA9PiB7XG4gICAgICAgIGlmIChlcnIpIHJldHVybiByZWplY3QoZXJyKTtcbiAgICAgICAgdGhpcy5yZWdpc3RlckNvbnN1bWVyKG9rLmZpZWxkcy5jb25zdW1lclRhZywgY2FsbGJhY2spO1xuICAgICAgICByZXNvbHZlKG9rLmZpZWxkcyk7XG4gICAgICB9KTtcbiAgICB9KTtcbiAgfVxuXG4gIGFzeW5jIGNhbmNlbChjb25zdW1lclRhZykge1xuICAgIGNvbnN0IG9rID0gYXdhaXQgcHJvbWlzaWZ5KGNiID0+IHtcbiAgICAgIHRoaXMuX3JwYyhkZWZzLkJhc2ljQ2FuY2VsLCBBcmdzLmNhbmNlbChjb25zdW1lclRhZyksXG4gICAgICAgICAgICBkZWZzLkJhc2ljQ2FuY2VsT2ssXG4gICAgICAgICAgICBjYik7XG4gICAgfSkoKVxuICAgIC50aGVuKG9rID0+IHtcbiAgICAgIHRoaXMudW5yZWdpc3RlckNvbnN1bWVyKGNvbnN1bWVyVGFnKTtcbiAgICAgIHJldHVybiBvay5maWVsZHM7XG4gICAgfSk7XG4gIH1cblxuICBnZXQocXVldWUsIG9wdGlvbnMpIHtcbiAgICBjb25zdCBmaWVsZHMgPSBBcmdzLmdldChxdWV1ZSwgb3B0aW9ucyk7XG4gICAgcmV0dXJuIG5ldyBQcm9taXNlKChyZXNvbHZlLCByZWplY3QpID0+IHtcbiAgICAgIHRoaXMuc2VuZE9yRW5xdWV1ZShkZWZzLkJhc2ljR2V0LCBmaWVsZHMsIChlcnIsIGYpID0+IHtcbiAgICAgICAgaWYgKGVycikgcmV0dXJuIHJlamVjdChlcnIpO1xuICAgICAgICBpZiAoZi5pZCA9PT0gZGVmcy5CYXNpY0dldEVtcHR5KSB7XG4gICAgICAgICAgcmV0dXJuIHJlc29sdmUoZmFsc2UpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKGYuaWQgPT09IGRlZnMuQmFzaWNHZXRPaykge1xuICAgICAgICAgIGNvbnN0IGZpZWxkcyA9IGYuZmllbGRzO1xuICAgICAgICAgIHRoaXMuaGFuZGxlTWVzc2FnZSA9IGFjY2VwdE1lc3NhZ2UobSA9PiB7XG4gICAgICAgICAgICBtLmZpZWxkcyA9IGZpZWxkcztcbiAgICAgICAgICAgIHJlc29sdmUobSk7XG4gICAgICAgICAgfSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSB7XG4gICAgICAgICAgcmVqZWN0KG5ldyBFcnJvcihgVW5leHBlY3RlZCByZXNwb25zZSB0byBCYXNpY0dldDogJHtpbnNwZWN0KGYpfWApKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfSk7XG4gIH1cblxuICBhY2sobWVzc2FnZSwgYWxsVXBUbykge1xuICAgIHRoaXMuc2VuZEltbWVkaWF0ZWx5KFxuICAgICAgZGVmcy5CYXNpY0FjayxcbiAgICAgIEFyZ3MuYWNrKG1lc3NhZ2UuZmllbGRzLmRlbGl2ZXJ5VGFnLCBhbGxVcFRvKSk7XG4gIH1cblxuICBhY2tBbGwoKSB7XG4gICAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoZGVmcy5CYXNpY0FjaywgQXJncy5hY2soMCwgdHJ1ZSkpO1xuICB9XG5cbiAgbmFjayhtZXNzYWdlLCBhbGxVcFRvLCByZXF1ZXVlKSB7XG4gICAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoXG4gICAgICBkZWZzLkJhc2ljTmFjayxcbiAgICAgIEFyZ3MubmFjayhtZXNzYWdlLmZpZWxkcy5kZWxpdmVyeVRhZywgYWxsVXBUbywgcmVxdWV1ZSkpO1xuICB9XG5cbiAgbmFja0FsbChyZXF1ZXVlKSB7XG4gICAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoZGVmcy5CYXNpY05hY2ssXG4gICAgICAgICAgICAgICAgICAgICAgICAgQXJncy5uYWNrKDAsIHRydWUsIHJlcXVldWUpKTtcbiAgfVxuXG4gIC8vIGBCYXNpYy5OYWNrYCBpcyBub3QgYXZhaWxhYmxlIGluIG9sZGVyIFJhYmJpdE1RIHZlcnNpb25zIChvciBpbiB0aGVcbiAgLy8gQU1RUCBzcGVjaWZpY2F0aW9uKSwgc28geW91IGhhdmUgdG8gdXNlIHRoZSBvbmUtYXQtYS10aW1lXG4gIC8vIGBCYXNpYy5SZWplY3RgLiBUaGlzIGlzIG90aGVyd2lzZSBzeW5vbnltb3VzIHdpdGhcbiAgLy8gYCNuYWNrKG1lc3NhZ2UsIGZhbHNlLCByZXF1ZXVlKWAuXG4gIHJlamVjdChtZXNzYWdlLCByZXF1ZXVlKSB7XG4gICAgdGhpcy5zZW5kSW1tZWRpYXRlbHkoXG4gICAgICBkZWZzLkJhc2ljUmVqZWN0LFxuICAgICAgQXJncy5yZWplY3QobWVzc2FnZS5maWVsZHMuZGVsaXZlcnlUYWcsIHJlcXVldWUpKTtcbiAgfVxuXG4gIHJlY292ZXIoKSB7XG4gICAgcmV0dXJuIHRoaXMucnBjKGRlZnMuQmFzaWNSZWNvdmVyLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLnJlY292ZXIoKSxcbiAgICAgICAgICAgICAgICAgICAgZGVmcy5CYXNpY1JlY292ZXJPayk7XG4gIH1cblxuICBxb3MoY291bnQsIGdsb2JhbCkge1xuICAgIHJldHVybiB0aGlzLnJwYyhkZWZzLkJhc2ljUW9zLFxuICAgICAgICAgICAgICAgICAgICBBcmdzLnByZWZldGNoKGNvdW50LCBnbG9iYWwpLFxuICAgICAgICAgICAgICAgICAgICBkZWZzLkJhc2ljUW9zT2spO1xuICB9XG59XG5cbi8vIFRoZXJlIGFyZSBtb3JlIG9wdGlvbnMgaW4gQU1RUCB0aGFuIGV4cG9zZWQgaGVyZTsgUmFiYml0TVEgb25seVxuLy8gaW1wbGVtZW50cyBwcmVmZXRjaCBiYXNlZCBvbiBtZXNzYWdlIGNvdW50LCBhbmQgb25seSBmb3IgaW5kaXZpZHVhbFxuLy8gY2hhbm5lbHMgb3IgY29uc3VtZXJzLiBSYWJiaXRNUSB2My4zLjAgYW5kIGFmdGVyIHRyZWF0IHByZWZldGNoXG4vLyAod2l0aG91dCBgZ2xvYmFsYCBzZXQpIGFzIHBlci1jb25zdW1lciAoZm9yIGNvbnN1bWVycyBmb2xsb3dpbmcpLFxuLy8gYW5kIHByZWZldGNoIHdpdGggYGdsb2JhbGAgc2V0IGFzIHBlci1jaGFubmVsLlxuQ2hhbm5lbC5wcm90b3R5cGUucHJlZmV0Y2ggPSBDaGFubmVsLnByb3RvdHlwZS5xb3NcblxuLy8gQ29uZmlybSBjaGFubmVsLiBUaGlzIGlzIGEgY2hhbm5lbCB3aXRoIGNvbmZpcm1zICdzd2l0Y2hlZCBvbicsXG4vLyBtZWFuaW5nIHNlbnQgbWVzc2FnZXMgd2lsbCBwcm92b2tlIGEgcmVzcG9uZGluZyAnYWNrJyBvciAnbmFjaydcbi8vIGZyb20gdGhlIHNlcnZlci4gVGhlIHVwc2hvdCBvZiB0aGlzIGlzIHRoYXQgYHB1Ymxpc2hgIGFuZFxuLy8gYHNlbmRUb1F1ZXVlYCBib3RoIHRha2UgYSBjYWxsYmFjaywgd2hpY2ggd2lsbCBiZSBjYWxsZWQgZWl0aGVyXG4vLyB3aXRoIGBudWxsYCBhcyBpdHMgYXJndW1lbnQgdG8gc2lnbmlmeSAnYWNrJywgb3IgYW4gZXhjZXB0aW9uIGFzXG4vLyBpdHMgYXJndW1lbnQgdG8gc2lnbmlmeSAnbmFjaycuXG5cbmNsYXNzIENvbmZpcm1DaGFubmVsIGV4dGVuZHMgQ2hhbm5lbCB7XG4gIHB1Ymxpc2goZXhjaGFuZ2UsIHJvdXRpbmdLZXksIGNvbnRlbnQsIG9wdGlvbnMsIGNiKSB7XG4gICAgdGhpcy5wdXNoQ29uZmlybUNhbGxiYWNrKGNiKTtcbiAgICByZXR1cm4gc3VwZXIucHVibGlzaChleGNoYW5nZSwgcm91dGluZ0tleSwgY29udGVudCwgb3B0aW9ucyk7XG4gIH1cblxuICBzZW5kVG9RdWV1ZShxdWV1ZSwgY29udGVudCwgb3B0aW9ucywgY2IpIHtcbiAgICByZXR1cm4gdGhpcy5wdWJsaXNoKCcnLCBxdWV1ZSwgY29udGVudCwgb3B0aW9ucywgY2IpO1xuICB9XG5cbiAgd2FpdEZvckNvbmZpcm1zKCkge1xuICAgIGNvbnN0IGF3YWl0aW5nID0gW107XG4gICAgY29uc3QgdW5jb25maXJtZWQgPSB0aGlzLnVuY29uZmlybWVkO1xuICAgIHVuY29uZmlybWVkLmZvckVhY2goKHZhbCwgaW5kZXgpID0+IHtcbiAgICAgIGlmICh2YWwgIT09IG51bGwpIHtcbiAgICAgICAgY29uc3QgY29uZmlybWVkID0gbmV3IFByb21pc2UoKHJlc29sdmUsIHJlamVjdCkgPT4ge1xuICAgICAgICAgIHVuY29uZmlybWVkW2luZGV4XSA9IGVyciA9PiB7XG4gICAgICAgICAgICBpZiAodmFsKSB2YWwoZXJyKTtcbiAgICAgICAgICAgIGlmIChlcnIgPT09IG51bGwpIHJlc29sdmUoKTtcbiAgICAgICAgICAgIGVsc2UgcmVqZWN0KGVycik7XG4gICAgICAgICAgfTtcbiAgICAgICAgfSk7XG4gICAgICAgIGF3YWl0aW5nLnB1c2goY29uZmlybWVkKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgICAvLyBDaGFubmVsIGNsb3NlZFxuICAgIGlmICghdGhpcy5wZW5kaW5nKSB7XG4gICAgICB2YXIgY2I7XG4gICAgICB3aGlsZSAoY2IgPSB0aGlzLnVuY29uZmlybWVkLnNoaWZ0KCkpIHtcbiAgICAgICAgaWYgKGNiKSBjYihuZXcgRXJyb3IoJ2NoYW5uZWwgY2xvc2VkJykpO1xuICAgICAgfVxuICAgIH1cbiAgICByZXR1cm4gUHJvbWlzZS5hbGwoYXdhaXRpbmcpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkNvbmZpcm1DaGFubmVsID0gQ29uZmlybUNoYW5uZWw7XG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsID0gQ2hhbm5lbDtcbm1vZHVsZS5leHBvcnRzLkNoYW5uZWxNb2RlbCA9IENoYW5uZWxNb2RlbDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/channel_model.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/codec.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/codec.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("//\n//\n//\n\n/*\n\nThe AMQP 0-9-1 is a mess when it comes to the types that can be\nencoded on the wire.\n\nThere are four encoding schemes, and three overlapping sets of types:\nframes, methods, (field-)tables, and properties.\n\nEach *frame type* has a set layout in which values of given types are\nconcatenated along with sections of \"raw binary\" data.\n\nIn frames there are `shortstr`s, that is length-prefixed strings of\nUTF8 chars, 8 bit unsigned integers (called `octet`), unsigned 16 bit\nintegers (called `short` or `short-uint`), unsigned 32 bit integers\n(called `long` or `long-uint`), unsigned 64 bit integers (called\n`longlong` or `longlong-uint`), and flags (called `bit`).\n\nMethods are encoded as a frame giving a method ID and a sequence of\narguments of known types. The encoded method argument values are\nconcatenated (with some fun complications around \"packing\" consecutive\nbit values into bytes).\n\nAlong with the types given in frames, method arguments may be long\nbyte strings (`longstr`, not required to be UTF8) or 64 bit unsigned\nintegers to be interpreted as timestamps (yeah I don't know why\neither), or arbitrary sets of key-value pairs (called `field-table`).\n\nInside a field table the keys are `shortstr` and the values are\nprefixed with a byte tag giving the type. The types are any of the\nabove except for bits (which are replaced by byte-wide `bool`), along\nwith a NULL value `void`, a special fixed-precision number encoding\n(`decimal`), IEEE754 `float`s and `double`s, signed integers,\n`field-array` (a sequence of tagged values), and nested field-tables.\n\nRabbitMQ and QPid use a subset of the field-table types, and different\nvalue tags, established before the AMQP 0-9-1 specification was\npublished. So far as I know, no-one uses the types and tags as\npublished. http://www.rabbitmq.com/amqp-0-9-1-errata.html gives the\nlist of field-table types.\n\nLastly, there are (sets of) properties, only one of which is given in\nAMQP 0-9-1: `BasicProperties`. These are almost the same as methods,\nexcept that they appear in content header frames, which include a\ncontent size, and they carry a set of flags indicating which\nproperties are present. This scheme can save ones of bytes per message\n(messages which take a minimum of three frames each to send).\n\n*/\n\n\n\nvar ints = __webpack_require__(/*! buffer-more-ints */ \"(rsc)/./node_modules/buffer-more-ints/buffer-more-ints.js\");\n\n// JavaScript uses only doubles so what I'm testing for is whether\n// it's *better* to encode a number as a float or double. This really\n// just amounts to testing whether there's a fractional part to the\n// number, except that see below. NB I don't use bitwise operations to\n// do this 'efficiently' -- it would mask the number to 32 bits.\n//\n// At 2^50, doubles don't have sufficient precision to distinguish\n// between floating point and integer numbers (`Math.pow(2, 50) + 0.1\n// === Math.pow(2, 50)` (and, above 2^53, doubles cannot represent all\n// integers (`Math.pow(2, 53) + 1 === Math.pow(2, 53)`)). Hence\n// anything with a magnitude at or above 2^50 may as well be encoded\n// as a 64-bit integer. Except that only signed integers are supported\n// by RabbitMQ, so anything above 2^63 - 1 must be a double.\nfunction isFloatingPoint(n) {\n    return n >= 0x8000000000000000 ||\n        (Math.abs(n) < 0x4000000000000\n         && Math.floor(n) !== n);\n}\n\nfunction encodeTable(buffer, val, offset) {\n    var start = offset;\n    offset += 4; // leave room for the table length\n    for (var key in val) {\n        if (val[key] !== undefined) {\n          var len = Buffer.byteLength(key);\n          buffer.writeUInt8(len, offset); offset++;\n          buffer.write(key, offset, 'utf8'); offset += len;\n          offset += encodeFieldValue(buffer, val[key], offset);\n        }\n    }\n    var size = offset - start;\n    buffer.writeUInt32BE(size - 4, start);\n    return size;\n}\n\nfunction encodeArray(buffer, val, offset) {\n    var start = offset;\n    offset += 4;\n    for (var i=0, num=val.length; i < num; i++) {\n        offset += encodeFieldValue(buffer, val[i], offset);\n    }\n    var size = offset - start;\n    buffer.writeUInt32BE(size - 4, start);\n    return size;\n}\n\nfunction encodeFieldValue(buffer, value, offset) {\n    var start = offset;\n    var type = typeof value, val = value;\n    // A trapdoor for specifying a type, e.g., timestamp\n    if (value && type === 'object' && value.hasOwnProperty('!')) {\n        val = value.value;\n        type = value['!'];\n    }\n\n    // If it's a JS number, we'll have to guess what type to encode it\n    // as.\n    if (type == 'number') {\n        // Making assumptions about the kind of number (floating point\n        // v integer, signed, unsigned, size) desired is dangerous in\n        // general; however, in practice RabbitMQ uses only\n        // longstrings and unsigned integers in its arguments, and\n        // other clients generally conflate number types anyway. So\n        // the only distinction we care about is floating point vs\n        // integers, preferring integers since those can be promoted\n        // if necessary. If floating point is required, we may as well\n        // use double precision.\n        if (isFloatingPoint(val)) {\n            type = 'double';\n        }\n        else { // only signed values are used in tables by\n               // RabbitMQ. It *used* to (< v3.3.0) treat the byte 'b'\n               // type as unsigned, but most clients (and the spec)\n               // think it's signed, and now RabbitMQ does too.\n            if (val < 128 && val >= -128) {\n                type = 'byte';\n            }\n            else if (val >= -0x8000 && val < 0x8000) {\n                type = 'short'\n            }\n            else if (val >= -0x80000000 && val < 0x80000000) {\n                type = 'int';\n            }\n            else {\n                type = 'long';\n            }\n        }\n    }\n\n    function tag(t) { buffer.write(t, offset); offset++; }\n\n    switch (type) {\n    case 'string': // no shortstr in field tables\n        var len = Buffer.byteLength(val, 'utf8');\n        tag('S');\n        buffer.writeUInt32BE(len, offset); offset += 4;\n        buffer.write(val, offset, 'utf8'); offset += len;\n        break;\n    case 'object':\n        if (val === null) {\n            tag('V');\n        }\n        else if (Array.isArray(val)) {\n            tag('A');\n            offset += encodeArray(buffer, val, offset);\n        }\n        else if (Buffer.isBuffer(val)) {\n            tag('x');\n            buffer.writeUInt32BE(val.length, offset); offset += 4;\n            val.copy(buffer, offset); offset += val.length;\n        }\n        else {\n            tag('F');\n            offset += encodeTable(buffer, val, offset);\n        }\n        break;\n    case 'boolean':\n        tag('t');\n        buffer.writeUInt8((val) ? 1 : 0, offset); offset++;\n        break;\n    // These are the types that are either guessed above, or\n    // explicitly given using the {'!': type} notation.\n    case 'double':\n    case 'float64':\n        tag('d');\n        buffer.writeDoubleBE(val, offset);\n        offset += 8;\n        break;\n    case 'byte':\n    case 'int8':\n        tag('b');\n        buffer.writeInt8(val, offset); offset++;\n        break;\n    case 'short':\n    case 'int16':\n        tag('s');\n        buffer.writeInt16BE(val, offset); offset += 2;\n        break;\n    case 'int':\n    case 'int32':\n        tag('I');\n        buffer.writeInt32BE(val, offset); offset += 4;\n        break;\n    case 'long':\n    case 'int64':\n        tag('l');\n        ints.writeInt64BE(buffer, val, offset); offset += 8;\n        break;\n\n    // Now for exotic types, those can _only_ be denoted by using\n    // `{'!': type, value: val}\n    case 'timestamp':\n        tag('T');\n        ints.writeUInt64BE(buffer, val, offset); offset += 8;\n        break;\n    case 'float':\n        tag('f');\n        buffer.writeFloatBE(val, offset); offset += 4;\n        break;\n    case 'decimal':\n        tag('D');\n        if (val.hasOwnProperty('places') && val.hasOwnProperty('digits')\n            && val.places >= 0 && val.places < 256) {\n            buffer[offset] = val.places; offset++;\n            buffer.writeUInt32BE(val.digits, offset); offset += 4;\n        }\n        else throw new TypeError(\n            \"Decimal value must be {'places': 0..255, 'digits': uint32}, \" +\n                \"got \" + JSON.stringify(val));\n        break;\n    default:\n        throw new TypeError('Unknown type to encode: ' + type);\n    }\n    return offset - start;\n}\n\n// Assume we're given a slice of the buffer that contains just the\n// fields.\nfunction decodeFields(slice) {\n    var fields = {}, offset = 0, size = slice.length;\n    var len, key, val;\n\n    function decodeFieldValue() {\n        var tag = String.fromCharCode(slice[offset]); offset++;\n        switch (tag) {\n        case 'b':\n            val = slice.readInt8(offset); offset++;\n            break;\n        case 'S':\n            len = slice.readUInt32BE(offset); offset += 4;\n            val = slice.toString('utf8', offset, offset + len);\n            offset += len;\n            break;\n        case 'I':\n            val = slice.readInt32BE(offset); offset += 4;\n            break;\n        case 'D': // only positive decimals, apparently.\n            var places = slice[offset]; offset++;\n            var digits = slice.readUInt32BE(offset); offset += 4;\n            val = {'!': 'decimal', value: {places: places, digits: digits}};\n            break;\n        case 'T':\n            val = ints.readUInt64BE(slice, offset); offset += 8;\n            val = {'!': 'timestamp', value: val};\n            break;\n        case 'F':\n            len = slice.readUInt32BE(offset); offset += 4;\n            val = decodeFields(slice.subarray(offset, offset + len));\n            offset += len;\n            break;\n        case 'A':\n            len = slice.readUInt32BE(offset); offset += 4;\n            decodeArray(offset + len);\n            // NB decodeArray will itself update offset and val\n            break;\n        case 'd':\n            val = slice.readDoubleBE(offset); offset += 8;\n            break;\n        case 'f':\n            val = slice.readFloatBE(offset); offset += 4;\n            break;\n        case 'l':\n            val = ints.readInt64BE(slice, offset); offset += 8;\n            break;\n        case 's':\n            val = slice.readInt16BE(offset); offset += 2;\n            break;\n        case 't':\n            val = slice[offset] != 0; offset++;\n            break;\n        case 'V':\n            val = null;\n            break;\n        case 'x':\n            len = slice.readUInt32BE(offset); offset += 4;\n            val = slice.subarray(offset, offset + len);\n            offset += len;\n            break;\n        default:\n            throw new TypeError('Unexpected type tag \"' + tag +'\"');\n        }\n    }\n\n    function decodeArray(until) {\n        var vals = [];\n        while (offset < until) {\n            decodeFieldValue();\n            vals.push(val);\n        }\n        val = vals;\n    }\n\n    while (offset < size) {\n        len = slice.readUInt8(offset); offset++;\n        key = slice.toString('utf8', offset, offset + len);\n        offset += len;\n        decodeFieldValue();\n        fields[key] = val;\n    }\n    return fields;\n}\n\nmodule.exports.encodeTable = encodeTable;\nmodule.exports.decodeFields = decodeFields;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29kZWMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxtRkFBa0I7O0FBRXJDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQyw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLFNBQVM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxzQkFBc0IseUJBQXlCOztBQUUvQztBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQztBQUMzQywyQ0FBMkM7QUFDM0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNEQUFzRDtBQUN0RCxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRDtBQUNsRDtBQUNBO0FBQ0EsbUNBQW1DLFdBQVc7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0RBQWdEO0FBQ2hEOztBQUVBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5Q0FBeUM7QUFDekMsc0RBQXNEO0FBQ3REO0FBQ0E7QUFDQSxvQ0FBb0MsbUNBQW1DO0FBQ3ZFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLG1CQUFtQjtBQUNuQjs7QUFFQTtBQUNBLHNEQUFzRDtBQUN0RDtBQUNBO0FBQ0EsMENBQTBDO0FBQzFDO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxxREFBcUQ7QUFDckQsbUJBQW1CLHdCQUF3QjtBQUMzQztBQUNBO0FBQ0Esb0RBQW9EO0FBQ3BELG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOENBQThDO0FBQzlDO0FBQ0E7QUFDQSw2Q0FBNkM7QUFDN0M7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0EsNkNBQTZDO0FBQzdDO0FBQ0E7QUFDQSxzQ0FBc0M7QUFDdEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsdUNBQXVDO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDBCQUEwQjtBQUMxQiwyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIyLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2NvZGVjLmpzPzUxZDkiXSwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vXG4vL1xuXG4vKlxuXG5UaGUgQU1RUCAwLTktMSBpcyBhIG1lc3Mgd2hlbiBpdCBjb21lcyB0byB0aGUgdHlwZXMgdGhhdCBjYW4gYmVcbmVuY29kZWQgb24gdGhlIHdpcmUuXG5cblRoZXJlIGFyZSBmb3VyIGVuY29kaW5nIHNjaGVtZXMsIGFuZCB0aHJlZSBvdmVybGFwcGluZyBzZXRzIG9mIHR5cGVzOlxuZnJhbWVzLCBtZXRob2RzLCAoZmllbGQtKXRhYmxlcywgYW5kIHByb3BlcnRpZXMuXG5cbkVhY2ggKmZyYW1lIHR5cGUqIGhhcyBhIHNldCBsYXlvdXQgaW4gd2hpY2ggdmFsdWVzIG9mIGdpdmVuIHR5cGVzIGFyZVxuY29uY2F0ZW5hdGVkIGFsb25nIHdpdGggc2VjdGlvbnMgb2YgXCJyYXcgYmluYXJ5XCIgZGF0YS5cblxuSW4gZnJhbWVzIHRoZXJlIGFyZSBgc2hvcnRzdHJgcywgdGhhdCBpcyBsZW5ndGgtcHJlZml4ZWQgc3RyaW5ncyBvZlxuVVRGOCBjaGFycywgOCBiaXQgdW5zaWduZWQgaW50ZWdlcnMgKGNhbGxlZCBgb2N0ZXRgKSwgdW5zaWduZWQgMTYgYml0XG5pbnRlZ2VycyAoY2FsbGVkIGBzaG9ydGAgb3IgYHNob3J0LXVpbnRgKSwgdW5zaWduZWQgMzIgYml0IGludGVnZXJzXG4oY2FsbGVkIGBsb25nYCBvciBgbG9uZy11aW50YCksIHVuc2lnbmVkIDY0IGJpdCBpbnRlZ2VycyAoY2FsbGVkXG5gbG9uZ2xvbmdgIG9yIGBsb25nbG9uZy11aW50YCksIGFuZCBmbGFncyAoY2FsbGVkIGBiaXRgKS5cblxuTWV0aG9kcyBhcmUgZW5jb2RlZCBhcyBhIGZyYW1lIGdpdmluZyBhIG1ldGhvZCBJRCBhbmQgYSBzZXF1ZW5jZSBvZlxuYXJndW1lbnRzIG9mIGtub3duIHR5cGVzLiBUaGUgZW5jb2RlZCBtZXRob2QgYXJndW1lbnQgdmFsdWVzIGFyZVxuY29uY2F0ZW5hdGVkICh3aXRoIHNvbWUgZnVuIGNvbXBsaWNhdGlvbnMgYXJvdW5kIFwicGFja2luZ1wiIGNvbnNlY3V0aXZlXG5iaXQgdmFsdWVzIGludG8gYnl0ZXMpLlxuXG5BbG9uZyB3aXRoIHRoZSB0eXBlcyBnaXZlbiBpbiBmcmFtZXMsIG1ldGhvZCBhcmd1bWVudHMgbWF5IGJlIGxvbmdcbmJ5dGUgc3RyaW5ncyAoYGxvbmdzdHJgLCBub3QgcmVxdWlyZWQgdG8gYmUgVVRGOCkgb3IgNjQgYml0IHVuc2lnbmVkXG5pbnRlZ2VycyB0byBiZSBpbnRlcnByZXRlZCBhcyB0aW1lc3RhbXBzICh5ZWFoIEkgZG9uJ3Qga25vdyB3aHlcbmVpdGhlciksIG9yIGFyYml0cmFyeSBzZXRzIG9mIGtleS12YWx1ZSBwYWlycyAoY2FsbGVkIGBmaWVsZC10YWJsZWApLlxuXG5JbnNpZGUgYSBmaWVsZCB0YWJsZSB0aGUga2V5cyBhcmUgYHNob3J0c3RyYCBhbmQgdGhlIHZhbHVlcyBhcmVcbnByZWZpeGVkIHdpdGggYSBieXRlIHRhZyBnaXZpbmcgdGhlIHR5cGUuIFRoZSB0eXBlcyBhcmUgYW55IG9mIHRoZVxuYWJvdmUgZXhjZXB0IGZvciBiaXRzICh3aGljaCBhcmUgcmVwbGFjZWQgYnkgYnl0ZS13aWRlIGBib29sYCksIGFsb25nXG53aXRoIGEgTlVMTCB2YWx1ZSBgdm9pZGAsIGEgc3BlY2lhbCBmaXhlZC1wcmVjaXNpb24gbnVtYmVyIGVuY29kaW5nXG4oYGRlY2ltYWxgKSwgSUVFRTc1NCBgZmxvYXRgcyBhbmQgYGRvdWJsZWBzLCBzaWduZWQgaW50ZWdlcnMsXG5gZmllbGQtYXJyYXlgIChhIHNlcXVlbmNlIG9mIHRhZ2dlZCB2YWx1ZXMpLCBhbmQgbmVzdGVkIGZpZWxkLXRhYmxlcy5cblxuUmFiYml0TVEgYW5kIFFQaWQgdXNlIGEgc3Vic2V0IG9mIHRoZSBmaWVsZC10YWJsZSB0eXBlcywgYW5kIGRpZmZlcmVudFxudmFsdWUgdGFncywgZXN0YWJsaXNoZWQgYmVmb3JlIHRoZSBBTVFQIDAtOS0xIHNwZWNpZmljYXRpb24gd2FzXG5wdWJsaXNoZWQuIFNvIGZhciBhcyBJIGtub3csIG5vLW9uZSB1c2VzIHRoZSB0eXBlcyBhbmQgdGFncyBhc1xucHVibGlzaGVkLiBodHRwOi8vd3d3LnJhYmJpdG1xLmNvbS9hbXFwLTAtOS0xLWVycmF0YS5odG1sIGdpdmVzIHRoZVxubGlzdCBvZiBmaWVsZC10YWJsZSB0eXBlcy5cblxuTGFzdGx5LCB0aGVyZSBhcmUgKHNldHMgb2YpIHByb3BlcnRpZXMsIG9ubHkgb25lIG9mIHdoaWNoIGlzIGdpdmVuIGluXG5BTVFQIDAtOS0xOiBgQmFzaWNQcm9wZXJ0aWVzYC4gVGhlc2UgYXJlIGFsbW9zdCB0aGUgc2FtZSBhcyBtZXRob2RzLFxuZXhjZXB0IHRoYXQgdGhleSBhcHBlYXIgaW4gY29udGVudCBoZWFkZXIgZnJhbWVzLCB3aGljaCBpbmNsdWRlIGFcbmNvbnRlbnQgc2l6ZSwgYW5kIHRoZXkgY2FycnkgYSBzZXQgb2YgZmxhZ3MgaW5kaWNhdGluZyB3aGljaFxucHJvcGVydGllcyBhcmUgcHJlc2VudC4gVGhpcyBzY2hlbWUgY2FuIHNhdmUgb25lcyBvZiBieXRlcyBwZXIgbWVzc2FnZVxuKG1lc3NhZ2VzIHdoaWNoIHRha2UgYSBtaW5pbXVtIG9mIHRocmVlIGZyYW1lcyBlYWNoIHRvIHNlbmQpLlxuXG4qL1xuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnRzID0gcmVxdWlyZSgnYnVmZmVyLW1vcmUtaW50cycpO1xuXG4vLyBKYXZhU2NyaXB0IHVzZXMgb25seSBkb3VibGVzIHNvIHdoYXQgSSdtIHRlc3RpbmcgZm9yIGlzIHdoZXRoZXJcbi8vIGl0J3MgKmJldHRlciogdG8gZW5jb2RlIGEgbnVtYmVyIGFzIGEgZmxvYXQgb3IgZG91YmxlLiBUaGlzIHJlYWxseVxuLy8ganVzdCBhbW91bnRzIHRvIHRlc3Rpbmcgd2hldGhlciB0aGVyZSdzIGEgZnJhY3Rpb25hbCBwYXJ0IHRvIHRoZVxuLy8gbnVtYmVyLCBleGNlcHQgdGhhdCBzZWUgYmVsb3cuIE5CIEkgZG9uJ3QgdXNlIGJpdHdpc2Ugb3BlcmF0aW9ucyB0b1xuLy8gZG8gdGhpcyAnZWZmaWNpZW50bHknIC0tIGl0IHdvdWxkIG1hc2sgdGhlIG51bWJlciB0byAzMiBiaXRzLlxuLy9cbi8vIEF0IDJeNTAsIGRvdWJsZXMgZG9uJ3QgaGF2ZSBzdWZmaWNpZW50IHByZWNpc2lvbiB0byBkaXN0aW5ndWlzaFxuLy8gYmV0d2VlbiBmbG9hdGluZyBwb2ludCBhbmQgaW50ZWdlciBudW1iZXJzIChgTWF0aC5wb3coMiwgNTApICsgMC4xXG4vLyA9PT0gTWF0aC5wb3coMiwgNTApYCAoYW5kLCBhYm92ZSAyXjUzLCBkb3VibGVzIGNhbm5vdCByZXByZXNlbnQgYWxsXG4vLyBpbnRlZ2VycyAoYE1hdGgucG93KDIsIDUzKSArIDEgPT09IE1hdGgucG93KDIsIDUzKWApKS4gSGVuY2Vcbi8vIGFueXRoaW5nIHdpdGggYSBtYWduaXR1ZGUgYXQgb3IgYWJvdmUgMl41MCBtYXkgYXMgd2VsbCBiZSBlbmNvZGVkXG4vLyBhcyBhIDY0LWJpdCBpbnRlZ2VyLiBFeGNlcHQgdGhhdCBvbmx5IHNpZ25lZCBpbnRlZ2VycyBhcmUgc3VwcG9ydGVkXG4vLyBieSBSYWJiaXRNUSwgc28gYW55dGhpbmcgYWJvdmUgMl42MyAtIDEgbXVzdCBiZSBhIGRvdWJsZS5cbmZ1bmN0aW9uIGlzRmxvYXRpbmdQb2ludChuKSB7XG4gICAgcmV0dXJuIG4gPj0gMHg4MDAwMDAwMDAwMDAwMDAwIHx8XG4gICAgICAgIChNYXRoLmFicyhuKSA8IDB4NDAwMDAwMDAwMDAwMFxuICAgICAgICAgJiYgTWF0aC5mbG9vcihuKSAhPT0gbik7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVRhYmxlKGJ1ZmZlciwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XG4gICAgb2Zmc2V0ICs9IDQ7IC8vIGxlYXZlIHJvb20gZm9yIHRoZSB0YWJsZSBsZW5ndGhcbiAgICBmb3IgKHZhciBrZXkgaW4gdmFsKSB7XG4gICAgICAgIGlmICh2YWxba2V5XSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgdmFyIGxlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKGtleSk7XG4gICAgICAgICAgYnVmZmVyLndyaXRlVUludDgobGVuLCBvZmZzZXQpOyBvZmZzZXQrKztcbiAgICAgICAgICBidWZmZXIud3JpdGUoa2V5LCBvZmZzZXQsICd1dGY4Jyk7IG9mZnNldCArPSBsZW47XG4gICAgICAgICAgb2Zmc2V0ICs9IGVuY29kZUZpZWxkVmFsdWUoYnVmZmVyLCB2YWxba2V5XSwgb2Zmc2V0KTtcbiAgICAgICAgfVxuICAgIH1cbiAgICB2YXIgc2l6ZSA9IG9mZnNldCAtIHN0YXJ0O1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHNpemUgLSA0LCBzdGFydCk7XG4gICAgcmV0dXJuIHNpemU7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUFycmF5KGJ1ZmZlciwgdmFsLCBvZmZzZXQpIHtcbiAgICB2YXIgc3RhcnQgPSBvZmZzZXQ7XG4gICAgb2Zmc2V0ICs9IDQ7XG4gICAgZm9yICh2YXIgaT0wLCBudW09dmFsLmxlbmd0aDsgaSA8IG51bTsgaSsrKSB7XG4gICAgICAgIG9mZnNldCArPSBlbmNvZGVGaWVsZFZhbHVlKGJ1ZmZlciwgdmFsW2ldLCBvZmZzZXQpO1xuICAgIH1cbiAgICB2YXIgc2l6ZSA9IG9mZnNldCAtIHN0YXJ0O1xuICAgIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHNpemUgLSA0LCBzdGFydCk7XG4gICAgcmV0dXJuIHNpemU7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUZpZWxkVmFsdWUoYnVmZmVyLCB2YWx1ZSwgb2Zmc2V0KSB7XG4gICAgdmFyIHN0YXJ0ID0gb2Zmc2V0O1xuICAgIHZhciB0eXBlID0gdHlwZW9mIHZhbHVlLCB2YWwgPSB2YWx1ZTtcbiAgICAvLyBBIHRyYXBkb29yIGZvciBzcGVjaWZ5aW5nIGEgdHlwZSwgZS5nLiwgdGltZXN0YW1wXG4gICAgaWYgKHZhbHVlICYmIHR5cGUgPT09ICdvYmplY3QnICYmIHZhbHVlLmhhc093blByb3BlcnR5KCchJykpIHtcbiAgICAgICAgdmFsID0gdmFsdWUudmFsdWU7XG4gICAgICAgIHR5cGUgPSB2YWx1ZVsnISddO1xuICAgIH1cblxuICAgIC8vIElmIGl0J3MgYSBKUyBudW1iZXIsIHdlJ2xsIGhhdmUgdG8gZ3Vlc3Mgd2hhdCB0eXBlIHRvIGVuY29kZSBpdFxuICAgIC8vIGFzLlxuICAgIGlmICh0eXBlID09ICdudW1iZXInKSB7XG4gICAgICAgIC8vIE1ha2luZyBhc3N1bXB0aW9ucyBhYm91dCB0aGUga2luZCBvZiBudW1iZXIgKGZsb2F0aW5nIHBvaW50XG4gICAgICAgIC8vIHYgaW50ZWdlciwgc2lnbmVkLCB1bnNpZ25lZCwgc2l6ZSkgZGVzaXJlZCBpcyBkYW5nZXJvdXMgaW5cbiAgICAgICAgLy8gZ2VuZXJhbDsgaG93ZXZlciwgaW4gcHJhY3RpY2UgUmFiYml0TVEgdXNlcyBvbmx5XG4gICAgICAgIC8vIGxvbmdzdHJpbmdzIGFuZCB1bnNpZ25lZCBpbnRlZ2VycyBpbiBpdHMgYXJndW1lbnRzLCBhbmRcbiAgICAgICAgLy8gb3RoZXIgY2xpZW50cyBnZW5lcmFsbHkgY29uZmxhdGUgbnVtYmVyIHR5cGVzIGFueXdheS4gU29cbiAgICAgICAgLy8gdGhlIG9ubHkgZGlzdGluY3Rpb24gd2UgY2FyZSBhYm91dCBpcyBmbG9hdGluZyBwb2ludCB2c1xuICAgICAgICAvLyBpbnRlZ2VycywgcHJlZmVycmluZyBpbnRlZ2VycyBzaW5jZSB0aG9zZSBjYW4gYmUgcHJvbW90ZWRcbiAgICAgICAgLy8gaWYgbmVjZXNzYXJ5LiBJZiBmbG9hdGluZyBwb2ludCBpcyByZXF1aXJlZCwgd2UgbWF5IGFzIHdlbGxcbiAgICAgICAgLy8gdXNlIGRvdWJsZSBwcmVjaXNpb24uXG4gICAgICAgIGlmIChpc0Zsb2F0aW5nUG9pbnQodmFsKSkge1xuICAgICAgICAgICAgdHlwZSA9ICdkb3VibGUnO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgeyAvLyBvbmx5IHNpZ25lZCB2YWx1ZXMgYXJlIHVzZWQgaW4gdGFibGVzIGJ5XG4gICAgICAgICAgICAgICAvLyBSYWJiaXRNUS4gSXQgKnVzZWQqIHRvICg8IHYzLjMuMCkgdHJlYXQgdGhlIGJ5dGUgJ2InXG4gICAgICAgICAgICAgICAvLyB0eXBlIGFzIHVuc2lnbmVkLCBidXQgbW9zdCBjbGllbnRzIChhbmQgdGhlIHNwZWMpXG4gICAgICAgICAgICAgICAvLyB0aGluayBpdCdzIHNpZ25lZCwgYW5kIG5vdyBSYWJiaXRNUSBkb2VzIHRvby5cbiAgICAgICAgICAgIGlmICh2YWwgPCAxMjggJiYgdmFsID49IC0xMjgpIHtcbiAgICAgICAgICAgICAgICB0eXBlID0gJ2J5dGUnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSBpZiAodmFsID49IC0weDgwMDAgJiYgdmFsIDwgMHg4MDAwKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdzaG9ydCdcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGVsc2UgaWYgKHZhbCA+PSAtMHg4MDAwMDAwMCAmJiB2YWwgPCAweDgwMDAwMDAwKSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdpbnQnO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgZWxzZSB7XG4gICAgICAgICAgICAgICAgdHlwZSA9ICdsb25nJztcbiAgICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIHRhZyh0KSB7IGJ1ZmZlci53cml0ZSh0LCBvZmZzZXQpOyBvZmZzZXQrKzsgfVxuXG4gICAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnc3RyaW5nJzogLy8gbm8gc2hvcnRzdHIgaW4gZmllbGQgdGFibGVzXG4gICAgICAgIHZhciBsZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsICd1dGY4Jyk7XG4gICAgICAgIHRhZygnUycpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsICd1dGY4Jyk7IG9mZnNldCArPSBsZW47XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ29iamVjdCc6XG4gICAgICAgIGlmICh2YWwgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHRhZygnVicpO1xuICAgICAgICB9XG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsKSkge1xuICAgICAgICAgICAgdGFnKCdBJyk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gZW5jb2RlQXJyYXkoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZSBpZiAoQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHtcbiAgICAgICAgICAgIHRhZygneCcpO1xuICAgICAgICAgICAgYnVmZmVyLndyaXRlVUludDMyQkUodmFsLmxlbmd0aCwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB2YWwuY29weShidWZmZXIsIG9mZnNldCk7IG9mZnNldCArPSB2YWwubGVuZ3RoO1xuICAgICAgICB9XG4gICAgICAgIGVsc2Uge1xuICAgICAgICAgICAgdGFnKCdGJyk7XG4gICAgICAgICAgICBvZmZzZXQgKz0gZW5jb2RlVGFibGUoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gICAgICAgIH1cbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYm9vbGVhbic6XG4gICAgICAgIHRhZygndCcpO1xuICAgICAgICBidWZmZXIud3JpdGVVSW50OCgodmFsKSA/IDEgOiAwLCBvZmZzZXQpOyBvZmZzZXQrKztcbiAgICAgICAgYnJlYWs7XG4gICAgLy8gVGhlc2UgYXJlIHRoZSB0eXBlcyB0aGF0IGFyZSBlaXRoZXIgZ3Vlc3NlZCBhYm92ZSwgb3JcbiAgICAvLyBleHBsaWNpdGx5IGdpdmVuIHVzaW5nIHRoZSB7JyEnOiB0eXBlfSBub3RhdGlvbi5cbiAgICBjYXNlICdkb3VibGUnOlxuICAgIGNhc2UgJ2Zsb2F0NjQnOlxuICAgICAgICB0YWcoJ2QnKTtcbiAgICAgICAgYnVmZmVyLndyaXRlRG91YmxlQkUodmFsLCBvZmZzZXQpO1xuICAgICAgICBvZmZzZXQgKz0gODtcbiAgICAgICAgYnJlYWs7XG4gICAgY2FzZSAnYnl0ZSc6XG4gICAgY2FzZSAnaW50OCc6XG4gICAgICAgIHRhZygnYicpO1xuICAgICAgICBidWZmZXIud3JpdGVJbnQ4KHZhbCwgb2Zmc2V0KTsgb2Zmc2V0Kys7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3Nob3J0JzpcbiAgICBjYXNlICdpbnQxNic6XG4gICAgICAgIHRhZygncycpO1xuICAgICAgICBidWZmZXIud3JpdGVJbnQxNkJFKHZhbCwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ludCc6XG4gICAgY2FzZSAnaW50MzInOlxuICAgICAgICB0YWcoJ0knKTtcbiAgICAgICAgYnVmZmVyLndyaXRlSW50MzJCRSh2YWwsIG9mZnNldCk7IG9mZnNldCArPSA0O1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdsb25nJzpcbiAgICBjYXNlICdpbnQ2NCc6XG4gICAgICAgIHRhZygnbCcpO1xuICAgICAgICBpbnRzLndyaXRlSW50NjRCRShidWZmZXIsIHZhbCwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDg7XG4gICAgICAgIGJyZWFrO1xuXG4gICAgLy8gTm93IGZvciBleG90aWMgdHlwZXMsIHRob3NlIGNhbiBfb25seV8gYmUgZGVub3RlZCBieSB1c2luZ1xuICAgIC8vIGB7JyEnOiB0eXBlLCB2YWx1ZTogdmFsfVxuICAgIGNhc2UgJ3RpbWVzdGFtcCc6XG4gICAgICAgIHRhZygnVCcpO1xuICAgICAgICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7IG9mZnNldCArPSA4O1xuICAgICAgICBicmVhaztcbiAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgIHRhZygnZicpO1xuICAgICAgICBidWZmZXIud3JpdGVGbG9hdEJFKHZhbCwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2RlY2ltYWwnOlxuICAgICAgICB0YWcoJ0QnKTtcbiAgICAgICAgaWYgKHZhbC5oYXNPd25Qcm9wZXJ0eSgncGxhY2VzJykgJiYgdmFsLmhhc093blByb3BlcnR5KCdkaWdpdHMnKVxuICAgICAgICAgICAgJiYgdmFsLnBsYWNlcyA+PSAwICYmIHZhbC5wbGFjZXMgPCAyNTYpIHtcbiAgICAgICAgICAgIGJ1ZmZlcltvZmZzZXRdID0gdmFsLnBsYWNlczsgb2Zmc2V0Kys7XG4gICAgICAgICAgICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwuZGlnaXRzLCBvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgfVxuICAgICAgICBlbHNlIHRocm93IG5ldyBUeXBlRXJyb3IoXG4gICAgICAgICAgICBcIkRlY2ltYWwgdmFsdWUgbXVzdCBiZSB7J3BsYWNlcyc6IDAuLjI1NSwgJ2RpZ2l0cyc6IHVpbnQzMn0sIFwiICtcbiAgICAgICAgICAgICAgICBcImdvdCBcIiArIEpTT04uc3RyaW5naWZ5KHZhbCkpO1xuICAgICAgICBicmVhaztcbiAgICBkZWZhdWx0OlxuICAgICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdVbmtub3duIHR5cGUgdG8gZW5jb2RlOiAnICsgdHlwZSk7XG4gICAgfVxuICAgIHJldHVybiBvZmZzZXQgLSBzdGFydDtcbn1cblxuLy8gQXNzdW1lIHdlJ3JlIGdpdmVuIGEgc2xpY2Ugb2YgdGhlIGJ1ZmZlciB0aGF0IGNvbnRhaW5zIGp1c3QgdGhlXG4vLyBmaWVsZHMuXG5mdW5jdGlvbiBkZWNvZGVGaWVsZHMoc2xpY2UpIHtcbiAgICB2YXIgZmllbGRzID0ge30sIG9mZnNldCA9IDAsIHNpemUgPSBzbGljZS5sZW5ndGg7XG4gICAgdmFyIGxlbiwga2V5LCB2YWw7XG5cbiAgICBmdW5jdGlvbiBkZWNvZGVGaWVsZFZhbHVlKCkge1xuICAgICAgICB2YXIgdGFnID0gU3RyaW5nLmZyb21DaGFyQ29kZShzbGljZVtvZmZzZXRdKTsgb2Zmc2V0Kys7XG4gICAgICAgIHN3aXRjaCAodGFnKSB7XG4gICAgICAgIGNhc2UgJ2InOlxuICAgICAgICAgICAgdmFsID0gc2xpY2UucmVhZEludDgob2Zmc2V0KTsgb2Zmc2V0Kys7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnUyc6XG4gICAgICAgICAgICBsZW4gPSBzbGljZS5yZWFkVUludDMyQkUob2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB2YWwgPSBzbGljZS50b1N0cmluZygndXRmOCcsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBsZW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnSSc6XG4gICAgICAgICAgICB2YWwgPSBzbGljZS5yZWFkSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdEJzogLy8gb25seSBwb3NpdGl2ZSBkZWNpbWFscywgYXBwYXJlbnRseS5cbiAgICAgICAgICAgIHZhciBwbGFjZXMgPSBzbGljZVtvZmZzZXRdOyBvZmZzZXQrKztcbiAgICAgICAgICAgIHZhciBkaWdpdHMgPSBzbGljZS5yZWFkVUludDMyQkUob2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB2YWwgPSB7JyEnOiAnZGVjaW1hbCcsIHZhbHVlOiB7cGxhY2VzOiBwbGFjZXMsIGRpZ2l0czogZGlnaXRzfX07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnVCc6XG4gICAgICAgICAgICB2YWwgPSBpbnRzLnJlYWRVSW50NjRCRShzbGljZSwgb2Zmc2V0KTsgb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICB2YWwgPSB7JyEnOiAndGltZXN0YW1wJywgdmFsdWU6IHZhbH07XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnRic6XG4gICAgICAgICAgICBsZW4gPSBzbGljZS5yZWFkVUludDMyQkUob2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICB2YWwgPSBkZWNvZGVGaWVsZHMoc2xpY2Uuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBsZW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnQSc6XG4gICAgICAgICAgICBsZW4gPSBzbGljZS5yZWFkVUludDMyQkUob2Zmc2V0KTsgb2Zmc2V0ICs9IDQ7XG4gICAgICAgICAgICBkZWNvZGVBcnJheShvZmZzZXQgKyBsZW4pO1xuICAgICAgICAgICAgLy8gTkIgZGVjb2RlQXJyYXkgd2lsbCBpdHNlbGYgdXBkYXRlIG9mZnNldCBhbmQgdmFsXG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZCc6XG4gICAgICAgICAgICB2YWwgPSBzbGljZS5yZWFkRG91YmxlQkUob2Zmc2V0KTsgb2Zmc2V0ICs9IDg7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAnZic6XG4gICAgICAgICAgICB2YWwgPSBzbGljZS5yZWFkRmxvYXRCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICdsJzpcbiAgICAgICAgICAgIHZhbCA9IGludHMucmVhZEludDY0QkUoc2xpY2UsIG9mZnNldCk7IG9mZnNldCArPSA4O1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ3MnOlxuICAgICAgICAgICAgdmFsID0gc2xpY2UucmVhZEludDE2QkUob2Zmc2V0KTsgb2Zmc2V0ICs9IDI7XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAndCc6XG4gICAgICAgICAgICB2YWwgPSBzbGljZVtvZmZzZXRdICE9IDA7IG9mZnNldCsrO1xuICAgICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgJ1YnOlxuICAgICAgICAgICAgdmFsID0gbnVsbDtcbiAgICAgICAgICAgIGJyZWFrO1xuICAgICAgICBjYXNlICd4JzpcbiAgICAgICAgICAgIGxlbiA9IHNsaWNlLnJlYWRVSW50MzJCRShvZmZzZXQpOyBvZmZzZXQgKz0gNDtcbiAgICAgICAgICAgIHZhbCA9IHNsaWNlLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICAgICAgICAgIG9mZnNldCArPSBsZW47XG4gICAgICAgICAgICBicmVhaztcbiAgICAgICAgZGVmYXVsdDpcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1VuZXhwZWN0ZWQgdHlwZSB0YWcgXCInICsgdGFnICsnXCInKTtcbiAgICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIGRlY29kZUFycmF5KHVudGlsKSB7XG4gICAgICAgIHZhciB2YWxzID0gW107XG4gICAgICAgIHdoaWxlIChvZmZzZXQgPCB1bnRpbCkge1xuICAgICAgICAgICAgZGVjb2RlRmllbGRWYWx1ZSgpO1xuICAgICAgICAgICAgdmFscy5wdXNoKHZhbCk7XG4gICAgICAgIH1cbiAgICAgICAgdmFsID0gdmFscztcbiAgICB9XG5cbiAgICB3aGlsZSAob2Zmc2V0IDwgc2l6ZSkge1xuICAgICAgICBsZW4gPSBzbGljZS5yZWFkVUludDgob2Zmc2V0KTsgb2Zmc2V0Kys7XG4gICAgICAgIGtleSA9IHNsaWNlLnRvU3RyaW5nKCd1dGY4Jywgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgICAgICBvZmZzZXQgKz0gbGVuO1xuICAgICAgICBkZWNvZGVGaWVsZFZhbHVlKCk7XG4gICAgICAgIGZpZWxkc1trZXldID0gdmFsO1xuICAgIH1cbiAgICByZXR1cm4gZmllbGRzO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5lbmNvZGVUYWJsZSA9IGVuY29kZVRhYmxlO1xubW9kdWxlLmV4cG9ydHMuZGVjb2RlRmllbGRzID0gZGVjb2RlRmllbGRzO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/codec.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/connect.js":
/*!*********************************************!*\
  !*** ./node_modules/amqplib/lib/connect.js ***!
  \*********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("//\n//\n//\n\n// General-purpose API for glueing everything together.\n\n\n\nvar URL = __webpack_require__(/*! url-parse */ \"(rsc)/./node_modules/url-parse/index.js\");\nvar QS = __webpack_require__(/*! querystring */ \"querystring\");\nvar Connection = (__webpack_require__(/*! ./connection */ \"(rsc)/./node_modules/amqplib/lib/connection.js\").Connection);\nvar fmt = (__webpack_require__(/*! util */ \"util\").format);\nvar credentials = __webpack_require__(/*! ./credentials */ \"(rsc)/./node_modules/amqplib/lib/credentials.js\");\n\nfunction copyInto(obj, target) {\n  var keys = Object.keys(obj);\n  var i = keys.length;\n  while (i--) {\n    var k = keys[i];\n    target[k] = obj[k];\n  }\n  return target;\n}\n\n// Adapted from util._extend, which is too fringe to use.\nfunction clone(obj) {\n  return copyInto(obj, {});\n}\n\nvar CLIENT_PROPERTIES = {\n  \"product\": \"amqplib\",\n  \"version\": (__webpack_require__(/*! ../package.json */ \"(rsc)/./node_modules/amqplib/package.json\").version),\n  \"platform\": fmt('Node.JS %s', process.version),\n  \"information\": \"http://squaremo.github.io/amqp.node\",\n  \"capabilities\": {\n    \"publisher_confirms\": true,\n    \"exchange_exchange_bindings\": true,\n    \"basic.nack\": true,\n    \"consumer_cancel_notify\": true,\n    \"connection.blocked\": true,\n    \"authentication_failure_close\": true\n  }\n};\n\n// Construct the main frames used in the opening handshake\nfunction openFrames(vhost, query, credentials, extraClientProperties) {\n  if (!vhost)\n    vhost = '/';\n  else\n    vhost = QS.unescape(vhost);\n\n  var query = query || {};\n\n  function intOrDefault(val, def) {\n    return (val === undefined) ? def : parseInt(val);\n  }\n\n  var clientProperties = Object.create(CLIENT_PROPERTIES);\n\n  return {\n    // start-ok\n    'clientProperties': copyInto(extraClientProperties, clientProperties),\n    'mechanism': credentials.mechanism,\n    'response': credentials.response(),\n    'locale': query.locale || 'en_US',\n\n    // tune-ok\n    'channelMax': intOrDefault(query.channelMax, 0),\n    'frameMax': intOrDefault(query.frameMax, 0x1000),\n    'heartbeat': intOrDefault(query.heartbeat, 0),\n\n    // open\n    'virtualHost': vhost,\n    'capabilities': '',\n    'insist': 0\n  };\n}\n\n// Decide on credentials based on what we're supplied.\nfunction credentialsFromUrl(parts) {\n  var user = 'guest', passwd = 'guest';\n  if (parts.username != '' || parts.password != '') {\n    user = (parts.username) ? unescape(parts.username) : '';\n    passwd = (parts.password) ? unescape(parts.password) : '';\n  }\n  return credentials.plain(user, passwd);\n}\n\nfunction connect(url, socketOptions, openCallback) {\n  // tls.connect uses `util._extend()` on the options given it, which\n  // copies only properties mentioned in `Object.keys()`, when\n  // processing the options. So I have to make copies too, rather\n  // than using `Object.create()`.\n  var sockopts = clone(socketOptions || {});\n  url = url || 'amqp://localhost';\n\n  var noDelay = !!sockopts.noDelay;\n  var timeout = sockopts.timeout;\n  var keepAlive = !!sockopts.keepAlive;\n  // 0 is default for node\n  var keepAliveDelay = sockopts.keepAliveDelay || 0;\n\n  var extraClientProperties = sockopts.clientProperties || {};\n\n  var protocol, fields;\n  if (typeof url === 'object') {\n    protocol = (url.protocol || 'amqp') + ':';\n    sockopts.host = url.hostname;\n    sockopts.servername = sockopts.servername || url.hostname;\n    sockopts.port = url.port || ((protocol === 'amqp:') ? 5672 : 5671);\n\n    var user, pass;\n    // Only default if both are missing, to have the same behaviour as\n    // the stringly URL.\n    if (url.username == undefined && url.password == undefined) {\n      user = 'guest'; pass = 'guest';\n    } else {\n      user = url.username || '';\n      pass = url.password || '';\n    }\n\n    var config = {\n      locale: url.locale,\n      channelMax: url.channelMax,\n      frameMax: url.frameMax,\n      heartbeat: url.heartbeat,\n    };\n\n    fields = openFrames(url.vhost, config, sockopts.credentials || credentials.plain(user, pass), extraClientProperties);\n  } else {\n    var parts = URL(url, true); // yes, parse the query string\n    protocol = parts.protocol;\n    sockopts.host = parts.hostname;\n    sockopts.servername = sockopts.servername || parts.hostname;\n    sockopts.port = parseInt(parts.port) || ((protocol === 'amqp:') ? 5672 : 5671);\n    var vhost = parts.pathname ? parts.pathname.substr(1) : null;\n    fields = openFrames(vhost, parts.query, sockopts.credentials || credentialsFromUrl(parts), extraClientProperties);\n  }\n\n  var sockok = false;\n  var sock;\n\n  function onConnect() {\n    sockok = true;\n    sock.setNoDelay(noDelay);\n    if (keepAlive) sock.setKeepAlive(keepAlive, keepAliveDelay);\n\n    var c = new Connection(sock);\n    c.open(fields, function(err, ok) {\n      // disable timeout once the connection is open, we don't want\n      // it fouling things\n      if (timeout) sock.setTimeout(0);\n      if (err === null) {\n        openCallback(null, c);\n      } else {\n        // The connection isn't closed by the server on e.g. wrong password\n        sock.end();\n        sock.destroy();\n        openCallback(err);\n      }\n    });\n  }\n\n  if (protocol === 'amqp:') {\n    sock = (__webpack_require__(/*! net */ \"net\").connect)(sockopts, onConnect);\n  }\n  else if (protocol === 'amqps:') {\n    sock = (__webpack_require__(/*! tls */ \"tls\").connect)(sockopts, onConnect);\n  }\n  else {\n    throw new Error(\"Expected amqp: or amqps: as the protocol; got \" + protocol);\n  }\n\n  if (timeout) {\n    sock.setTimeout(timeout, function() {\n      sock.end();\n      sock.destroy();\n      openCallback(new Error('connect ETIMEDOUT'));\n    });\n  }\n\n  sock.once('error', function(err) {\n    if (!sockok) openCallback(err);\n  });\n\n}\n\nmodule.exports.connect = connect;\nmodule.exports.credentialsFromUrl = credentialsFromUrl;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29ubmVjdC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLDBEQUFXO0FBQzdCLFNBQVMsbUJBQU8sQ0FBQyxnQ0FBYTtBQUM5QixpQkFBaUIsc0dBQWtDO0FBQ25ELFVBQVUsZ0RBQXNCO0FBQ2hDLGtCQUFrQixtQkFBTyxDQUFDLHNFQUFlOztBQUV6QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLHlCQUF5QjtBQUN6Qjs7QUFFQTtBQUNBO0FBQ0EsYUFBYSxpR0FBa0M7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwQ0FBMEM7QUFDMUM7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzQkFBc0I7QUFDdEIsTUFBTTtBQUNOO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxJQUFJO0FBQ0osZ0NBQWdDO0FBQ2hDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDs7QUFFQTtBQUNBLFdBQVcsK0NBQXNCO0FBQ2pDO0FBQ0E7QUFDQSxXQUFXLCtDQUFzQjtBQUNqQztBQUNBO0FBQ0EsK0RBQStEO0FBQy9EOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBLEdBQUc7O0FBRUg7O0FBRUEsc0JBQXNCO0FBQ3RCLGlDQUFpQyIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjIvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29ubmVjdC5qcz81NmFmIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vL1xuLy9cblxuLy8gR2VuZXJhbC1wdXJwb3NlIEFQSSBmb3IgZ2x1ZWluZyBldmVyeXRoaW5nIHRvZ2V0aGVyLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBVUkwgPSByZXF1aXJlKCd1cmwtcGFyc2UnKTtcbnZhciBRUyA9IHJlcXVpcmUoJ3F1ZXJ5c3RyaW5nJyk7XG52YXIgQ29ubmVjdGlvbiA9IHJlcXVpcmUoJy4vY29ubmVjdGlvbicpLkNvbm5lY3Rpb247XG52YXIgZm10ID0gcmVxdWlyZSgndXRpbCcpLmZvcm1hdDtcbnZhciBjcmVkZW50aWFscyA9IHJlcXVpcmUoJy4vY3JlZGVudGlhbHMnKTtcblxuZnVuY3Rpb24gY29weUludG8ob2JqLCB0YXJnZXQpIHtcbiAgdmFyIGtleXMgPSBPYmplY3Qua2V5cyhvYmopO1xuICB2YXIgaSA9IGtleXMubGVuZ3RoO1xuICB3aGlsZSAoaS0tKSB7XG4gICAgdmFyIGsgPSBrZXlzW2ldO1xuICAgIHRhcmdldFtrXSA9IG9ialtrXTtcbiAgfVxuICByZXR1cm4gdGFyZ2V0O1xufVxuXG4vLyBBZGFwdGVkIGZyb20gdXRpbC5fZXh0ZW5kLCB3aGljaCBpcyB0b28gZnJpbmdlIHRvIHVzZS5cbmZ1bmN0aW9uIGNsb25lKG9iaikge1xuICByZXR1cm4gY29weUludG8ob2JqLCB7fSk7XG59XG5cbnZhciBDTElFTlRfUFJPUEVSVElFUyA9IHtcbiAgXCJwcm9kdWN0XCI6IFwiYW1xcGxpYlwiLFxuICBcInZlcnNpb25cIjogcmVxdWlyZSgnLi4vcGFja2FnZS5qc29uJykudmVyc2lvbixcbiAgXCJwbGF0Zm9ybVwiOiBmbXQoJ05vZGUuSlMgJXMnLCBwcm9jZXNzLnZlcnNpb24pLFxuICBcImluZm9ybWF0aW9uXCI6IFwiaHR0cDovL3NxdWFyZW1vLmdpdGh1Yi5pby9hbXFwLm5vZGVcIixcbiAgXCJjYXBhYmlsaXRpZXNcIjoge1xuICAgIFwicHVibGlzaGVyX2NvbmZpcm1zXCI6IHRydWUsXG4gICAgXCJleGNoYW5nZV9leGNoYW5nZV9iaW5kaW5nc1wiOiB0cnVlLFxuICAgIFwiYmFzaWMubmFja1wiOiB0cnVlLFxuICAgIFwiY29uc3VtZXJfY2FuY2VsX25vdGlmeVwiOiB0cnVlLFxuICAgIFwiY29ubmVjdGlvbi5ibG9ja2VkXCI6IHRydWUsXG4gICAgXCJhdXRoZW50aWNhdGlvbl9mYWlsdXJlX2Nsb3NlXCI6IHRydWVcbiAgfVxufTtcblxuLy8gQ29uc3RydWN0IHRoZSBtYWluIGZyYW1lcyB1c2VkIGluIHRoZSBvcGVuaW5nIGhhbmRzaGFrZVxuZnVuY3Rpb24gb3BlbkZyYW1lcyh2aG9zdCwgcXVlcnksIGNyZWRlbnRpYWxzLCBleHRyYUNsaWVudFByb3BlcnRpZXMpIHtcbiAgaWYgKCF2aG9zdClcbiAgICB2aG9zdCA9ICcvJztcbiAgZWxzZVxuICAgIHZob3N0ID0gUVMudW5lc2NhcGUodmhvc3QpO1xuXG4gIHZhciBxdWVyeSA9IHF1ZXJ5IHx8IHt9O1xuXG4gIGZ1bmN0aW9uIGludE9yRGVmYXVsdCh2YWwsIGRlZikge1xuICAgIHJldHVybiAodmFsID09PSB1bmRlZmluZWQpID8gZGVmIDogcGFyc2VJbnQodmFsKTtcbiAgfVxuXG4gIHZhciBjbGllbnRQcm9wZXJ0aWVzID0gT2JqZWN0LmNyZWF0ZShDTElFTlRfUFJPUEVSVElFUyk7XG5cbiAgcmV0dXJuIHtcbiAgICAvLyBzdGFydC1va1xuICAgICdjbGllbnRQcm9wZXJ0aWVzJzogY29weUludG8oZXh0cmFDbGllbnRQcm9wZXJ0aWVzLCBjbGllbnRQcm9wZXJ0aWVzKSxcbiAgICAnbWVjaGFuaXNtJzogY3JlZGVudGlhbHMubWVjaGFuaXNtLFxuICAgICdyZXNwb25zZSc6IGNyZWRlbnRpYWxzLnJlc3BvbnNlKCksXG4gICAgJ2xvY2FsZSc6IHF1ZXJ5LmxvY2FsZSB8fCAnZW5fVVMnLFxuXG4gICAgLy8gdHVuZS1va1xuICAgICdjaGFubmVsTWF4JzogaW50T3JEZWZhdWx0KHF1ZXJ5LmNoYW5uZWxNYXgsIDApLFxuICAgICdmcmFtZU1heCc6IGludE9yRGVmYXVsdChxdWVyeS5mcmFtZU1heCwgMHgxMDAwKSxcbiAgICAnaGVhcnRiZWF0JzogaW50T3JEZWZhdWx0KHF1ZXJ5LmhlYXJ0YmVhdCwgMCksXG5cbiAgICAvLyBvcGVuXG4gICAgJ3ZpcnR1YWxIb3N0Jzogdmhvc3QsXG4gICAgJ2NhcGFiaWxpdGllcyc6ICcnLFxuICAgICdpbnNpc3QnOiAwXG4gIH07XG59XG5cbi8vIERlY2lkZSBvbiBjcmVkZW50aWFscyBiYXNlZCBvbiB3aGF0IHdlJ3JlIHN1cHBsaWVkLlxuZnVuY3Rpb24gY3JlZGVudGlhbHNGcm9tVXJsKHBhcnRzKSB7XG4gIHZhciB1c2VyID0gJ2d1ZXN0JywgcGFzc3dkID0gJ2d1ZXN0JztcbiAgaWYgKHBhcnRzLnVzZXJuYW1lICE9ICcnIHx8IHBhcnRzLnBhc3N3b3JkICE9ICcnKSB7XG4gICAgdXNlciA9IChwYXJ0cy51c2VybmFtZSkgPyB1bmVzY2FwZShwYXJ0cy51c2VybmFtZSkgOiAnJztcbiAgICBwYXNzd2QgPSAocGFydHMucGFzc3dvcmQpID8gdW5lc2NhcGUocGFydHMucGFzc3dvcmQpIDogJyc7XG4gIH1cbiAgcmV0dXJuIGNyZWRlbnRpYWxzLnBsYWluKHVzZXIsIHBhc3N3ZCk7XG59XG5cbmZ1bmN0aW9uIGNvbm5lY3QodXJsLCBzb2NrZXRPcHRpb25zLCBvcGVuQ2FsbGJhY2spIHtcbiAgLy8gdGxzLmNvbm5lY3QgdXNlcyBgdXRpbC5fZXh0ZW5kKClgIG9uIHRoZSBvcHRpb25zIGdpdmVuIGl0LCB3aGljaFxuICAvLyBjb3BpZXMgb25seSBwcm9wZXJ0aWVzIG1lbnRpb25lZCBpbiBgT2JqZWN0LmtleXMoKWAsIHdoZW5cbiAgLy8gcHJvY2Vzc2luZyB0aGUgb3B0aW9ucy4gU28gSSBoYXZlIHRvIG1ha2UgY29waWVzIHRvbywgcmF0aGVyXG4gIC8vIHRoYW4gdXNpbmcgYE9iamVjdC5jcmVhdGUoKWAuXG4gIHZhciBzb2Nrb3B0cyA9IGNsb25lKHNvY2tldE9wdGlvbnMgfHwge30pO1xuICB1cmwgPSB1cmwgfHwgJ2FtcXA6Ly9sb2NhbGhvc3QnO1xuXG4gIHZhciBub0RlbGF5ID0gISFzb2Nrb3B0cy5ub0RlbGF5O1xuICB2YXIgdGltZW91dCA9IHNvY2tvcHRzLnRpbWVvdXQ7XG4gIHZhciBrZWVwQWxpdmUgPSAhIXNvY2tvcHRzLmtlZXBBbGl2ZTtcbiAgLy8gMCBpcyBkZWZhdWx0IGZvciBub2RlXG4gIHZhciBrZWVwQWxpdmVEZWxheSA9IHNvY2tvcHRzLmtlZXBBbGl2ZURlbGF5IHx8IDA7XG5cbiAgdmFyIGV4dHJhQ2xpZW50UHJvcGVydGllcyA9IHNvY2tvcHRzLmNsaWVudFByb3BlcnRpZXMgfHwge307XG5cbiAgdmFyIHByb3RvY29sLCBmaWVsZHM7XG4gIGlmICh0eXBlb2YgdXJsID09PSAnb2JqZWN0Jykge1xuICAgIHByb3RvY29sID0gKHVybC5wcm90b2NvbCB8fCAnYW1xcCcpICsgJzonO1xuICAgIHNvY2tvcHRzLmhvc3QgPSB1cmwuaG9zdG5hbWU7XG4gICAgc29ja29wdHMuc2VydmVybmFtZSA9IHNvY2tvcHRzLnNlcnZlcm5hbWUgfHwgdXJsLmhvc3RuYW1lO1xuICAgIHNvY2tvcHRzLnBvcnQgPSB1cmwucG9ydCB8fCAoKHByb3RvY29sID09PSAnYW1xcDonKSA/IDU2NzIgOiA1NjcxKTtcblxuICAgIHZhciB1c2VyLCBwYXNzO1xuICAgIC8vIE9ubHkgZGVmYXVsdCBpZiBib3RoIGFyZSBtaXNzaW5nLCB0byBoYXZlIHRoZSBzYW1lIGJlaGF2aW91ciBhc1xuICAgIC8vIHRoZSBzdHJpbmdseSBVUkwuXG4gICAgaWYgKHVybC51c2VybmFtZSA9PSB1bmRlZmluZWQgJiYgdXJsLnBhc3N3b3JkID09IHVuZGVmaW5lZCkge1xuICAgICAgdXNlciA9ICdndWVzdCc7IHBhc3MgPSAnZ3Vlc3QnO1xuICAgIH0gZWxzZSB7XG4gICAgICB1c2VyID0gdXJsLnVzZXJuYW1lIHx8ICcnO1xuICAgICAgcGFzcyA9IHVybC5wYXNzd29yZCB8fCAnJztcbiAgICB9XG5cbiAgICB2YXIgY29uZmlnID0ge1xuICAgICAgbG9jYWxlOiB1cmwubG9jYWxlLFxuICAgICAgY2hhbm5lbE1heDogdXJsLmNoYW5uZWxNYXgsXG4gICAgICBmcmFtZU1heDogdXJsLmZyYW1lTWF4LFxuICAgICAgaGVhcnRiZWF0OiB1cmwuaGVhcnRiZWF0LFxuICAgIH07XG5cbiAgICBmaWVsZHMgPSBvcGVuRnJhbWVzKHVybC52aG9zdCwgY29uZmlnLCBzb2Nrb3B0cy5jcmVkZW50aWFscyB8fCBjcmVkZW50aWFscy5wbGFpbih1c2VyLCBwYXNzKSwgZXh0cmFDbGllbnRQcm9wZXJ0aWVzKTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgcGFydHMgPSBVUkwodXJsLCB0cnVlKTsgLy8geWVzLCBwYXJzZSB0aGUgcXVlcnkgc3RyaW5nXG4gICAgcHJvdG9jb2wgPSBwYXJ0cy5wcm90b2NvbDtcbiAgICBzb2Nrb3B0cy5ob3N0ID0gcGFydHMuaG9zdG5hbWU7XG4gICAgc29ja29wdHMuc2VydmVybmFtZSA9IHNvY2tvcHRzLnNlcnZlcm5hbWUgfHwgcGFydHMuaG9zdG5hbWU7XG4gICAgc29ja29wdHMucG9ydCA9IHBhcnNlSW50KHBhcnRzLnBvcnQpIHx8ICgocHJvdG9jb2wgPT09ICdhbXFwOicpID8gNTY3MiA6IDU2NzEpO1xuICAgIHZhciB2aG9zdCA9IHBhcnRzLnBhdGhuYW1lID8gcGFydHMucGF0aG5hbWUuc3Vic3RyKDEpIDogbnVsbDtcbiAgICBmaWVsZHMgPSBvcGVuRnJhbWVzKHZob3N0LCBwYXJ0cy5xdWVyeSwgc29ja29wdHMuY3JlZGVudGlhbHMgfHwgY3JlZGVudGlhbHNGcm9tVXJsKHBhcnRzKSwgZXh0cmFDbGllbnRQcm9wZXJ0aWVzKTtcbiAgfVxuXG4gIHZhciBzb2Nrb2sgPSBmYWxzZTtcbiAgdmFyIHNvY2s7XG5cbiAgZnVuY3Rpb24gb25Db25uZWN0KCkge1xuICAgIHNvY2tvayA9IHRydWU7XG4gICAgc29jay5zZXROb0RlbGF5KG5vRGVsYXkpO1xuICAgIGlmIChrZWVwQWxpdmUpIHNvY2suc2V0S2VlcEFsaXZlKGtlZXBBbGl2ZSwga2VlcEFsaXZlRGVsYXkpO1xuXG4gICAgdmFyIGMgPSBuZXcgQ29ubmVjdGlvbihzb2NrKTtcbiAgICBjLm9wZW4oZmllbGRzLCBmdW5jdGlvbihlcnIsIG9rKSB7XG4gICAgICAvLyBkaXNhYmxlIHRpbWVvdXQgb25jZSB0aGUgY29ubmVjdGlvbiBpcyBvcGVuLCB3ZSBkb24ndCB3YW50XG4gICAgICAvLyBpdCBmb3VsaW5nIHRoaW5nc1xuICAgICAgaWYgKHRpbWVvdXQpIHNvY2suc2V0VGltZW91dCgwKTtcbiAgICAgIGlmIChlcnIgPT09IG51bGwpIHtcbiAgICAgICAgb3BlbkNhbGxiYWNrKG51bGwsIGMpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhlIGNvbm5lY3Rpb24gaXNuJ3QgY2xvc2VkIGJ5IHRoZSBzZXJ2ZXIgb24gZS5nLiB3cm9uZyBwYXNzd29yZFxuICAgICAgICBzb2NrLmVuZCgpO1xuICAgICAgICBzb2NrLmRlc3Ryb3koKTtcbiAgICAgICAgb3BlbkNhbGxiYWNrKGVycik7XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICBpZiAocHJvdG9jb2wgPT09ICdhbXFwOicpIHtcbiAgICBzb2NrID0gcmVxdWlyZSgnbmV0JykuY29ubmVjdChzb2Nrb3B0cywgb25Db25uZWN0KTtcbiAgfVxuICBlbHNlIGlmIChwcm90b2NvbCA9PT0gJ2FtcXBzOicpIHtcbiAgICBzb2NrID0gcmVxdWlyZSgndGxzJykuY29ubmVjdChzb2Nrb3B0cywgb25Db25uZWN0KTtcbiAgfVxuICBlbHNlIHtcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJFeHBlY3RlZCBhbXFwOiBvciBhbXFwczogYXMgdGhlIHByb3RvY29sOyBnb3QgXCIgKyBwcm90b2NvbCk7XG4gIH1cblxuICBpZiAodGltZW91dCkge1xuICAgIHNvY2suc2V0VGltZW91dCh0aW1lb3V0LCBmdW5jdGlvbigpIHtcbiAgICAgIHNvY2suZW5kKCk7XG4gICAgICBzb2NrLmRlc3Ryb3koKTtcbiAgICAgIG9wZW5DYWxsYmFjayhuZXcgRXJyb3IoJ2Nvbm5lY3QgRVRJTUVET1VUJykpO1xuICAgIH0pO1xuICB9XG5cbiAgc29jay5vbmNlKCdlcnJvcicsIGZ1bmN0aW9uKGVycikge1xuICAgIGlmICghc29ja29rKSBvcGVuQ2FsbGJhY2soZXJyKTtcbiAgfSk7XG5cbn1cblxubW9kdWxlLmV4cG9ydHMuY29ubmVjdCA9IGNvbm5lY3Q7XG5tb2R1bGUuZXhwb3J0cy5jcmVkZW50aWFsc0Zyb21VcmwgPSBjcmVkZW50aWFsc0Zyb21Vcmw7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/connect.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/connection.js":
/*!************************************************!*\
  !*** ./node_modules/amqplib/lib/connection.js ***!
  \************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("//\n//\n//\n\n\n\nvar defs = __webpack_require__(/*! ./defs */ \"(rsc)/./node_modules/amqplib/lib/defs.js\");\nvar constants = defs.constants;\nvar frame = __webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/amqplib/lib/frame.js\");\nvar HEARTBEAT = frame.HEARTBEAT;\nvar Mux = (__webpack_require__(/*! ./mux */ \"(rsc)/./node_modules/amqplib/lib/mux.js\").Mux);\n\nvar Duplex =\n  (__webpack_require__(/*! stream */ \"stream\").Duplex) ||\n  __webpack_require__(/*! readable-stream/duplex */ \"(rsc)/./node_modules/readable-stream/duplex.js\");\nvar EventEmitter = __webpack_require__(/*! events */ \"events\");\nvar Heart = (__webpack_require__(/*! ./heartbeat */ \"(rsc)/./node_modules/amqplib/lib/heartbeat.js\").Heart);\n\nvar methodName = (__webpack_require__(/*! ./format */ \"(rsc)/./node_modules/amqplib/lib/format.js\").methodName);\nvar closeMsg = (__webpack_require__(/*! ./format */ \"(rsc)/./node_modules/amqplib/lib/format.js\").closeMessage);\nvar inspect = (__webpack_require__(/*! ./format */ \"(rsc)/./node_modules/amqplib/lib/format.js\").inspect);\n\nvar BitSet = (__webpack_require__(/*! ./bitset */ \"(rsc)/./node_modules/amqplib/lib/bitset.js\").BitSet);\nvar fmt = (__webpack_require__(/*! util */ \"util\").format);\nvar PassThrough = (__webpack_require__(/*! stream */ \"stream\").PassThrough) ||\n  __webpack_require__(/*! readable-stream/passthrough */ \"(rsc)/./node_modules/readable-stream/passthrough.js\");\nvar IllegalOperationError = (__webpack_require__(/*! ./error */ \"(rsc)/./node_modules/amqplib/lib/error.js\").IllegalOperationError);\nvar stackCapture = (__webpack_require__(/*! ./error */ \"(rsc)/./node_modules/amqplib/lib/error.js\").stackCapture);\n\n// High-water mark for channel write buffers, in 'objects' (which are\n// encoded frames as buffers).\nvar DEFAULT_WRITE_HWM = 1024;\n// If all the frames of a message (method, properties, content) total\n// to less than this, copy them into a single buffer and write it all\n// at once. Note that this is less than the minimum frame size: if it\n// was greater, we might have to fragment the content.\nvar SINGLE_CHUNK_THRESHOLD = 2048;\n\nclass Connection extends EventEmitter {\n  constructor (underlying) {\n    super();\n\n    var stream = this.stream = wrapStream(underlying);\n    this.muxer = new Mux(stream);\n\n    // frames\n    this.rest = Buffer.alloc(0);\n    this.frameMax = constants.FRAME_MIN_SIZE;\n    this.sentSinceLastCheck = false;\n    this.recvSinceLastCheck = false;\n\n    this.expectSocketClose = false;\n    this.freeChannels = new BitSet();\n    this.channels = [{\n      channel: { accept: channel0(this) },\n      buffer: underlying\n    }];\n  }\n\n  // This changed between versions, as did the codec, methods, etc. AMQP\n  // 0-9-1 is fairly similar to 0.8, but better, and nothing implements\n  // 0.8 that doesn't implement 0-9-1. In other words, it doesn't make\n  // much sense to generalise here.\n  sendProtocolHeader () {\n    this.sendBytes(frame.PROTOCOL_HEADER);\n  }\n\n  /*\n    The frighteningly complicated opening protocol (spec section 2.2.4):\n\n       Client -> Server\n\n         protocol header ->\n           <- start\n         start-ok ->\n       .. next two zero or more times ..\n           <- secure\n         secure-ok ->\n           <- tune\n         tune-ok ->\n         open ->\n           <- open-ok\n\n  If I'm only supporting SASL's PLAIN mechanism (which I am for the time\n  being), it gets a bit easier since the server won't in general send\n  back a `secure`, it'll just send `tune` after the `start-ok`.\n  (SASL PLAIN: http://tools.ietf.org/html/rfc4616)\n\n  */\n  open (allFields, openCallback0) {\n    var self = this;\n    var openCallback = openCallback0 || function () { };\n\n    // This is where we'll put our negotiated values\n    var tunedOptions = Object.create(allFields);\n\n    function wait (k) {\n      self.step(function (err, frame) {\n        if (err !== null)\n          bail(err);\n        else if (frame.channel !== 0) {\n          bail(new Error(\n            fmt(\"Frame on channel != 0 during handshake: %s\",\n              inspect(frame, false))));\n        }\n        else\n          k(frame);\n      });\n    }\n\n    function expect (Method, k) {\n      wait(function (frame) {\n        if (frame.id === Method)\n          k(frame);\n        else {\n          bail(new Error(\n            fmt(\"Expected %s; got %s\",\n              methodName(Method), inspect(frame, false))));\n        }\n      });\n    }\n\n    function bail (err) {\n      openCallback(err);\n    }\n\n    function send (Method) {\n      // This can throw an exception if there's some problem with the\n      // options; e.g., something is a string instead of a number.\n      self.sendMethod(0, Method, tunedOptions);\n    }\n\n    function negotiate (server, desired) {\n      // We get sent values for channelMax, frameMax and heartbeat,\n      // which we may accept or lower (subject to a minimum for\n      // frameMax, but we'll leave that to the server to enforce). In\n      // all cases, `0` really means \"no limit\", or rather the highest\n      // value in the encoding, e.g., unsigned short for channelMax.\n      if (server === 0 || desired === 0) {\n        // i.e., whichever places a limit, if either\n        return Math.max(server, desired);\n      }\n      else {\n        return Math.min(server, desired);\n      }\n    }\n\n    function onStart (start) {\n      var mechanisms = start.fields.mechanisms.toString().split(' ');\n      if (mechanisms.indexOf(allFields.mechanism) < 0) {\n        bail(new Error(fmt('SASL mechanism %s is not provided by the server',\n          allFields.mechanism)));\n        return;\n      }\n      self.serverProperties = start.fields.serverProperties;\n      try {\n        send(defs.ConnectionStartOk);\n      } catch (err) {\n        bail(err);\n        return;\n      }\n      wait(afterStartOk);\n    }\n\n    function afterStartOk (reply) {\n      switch (reply.id) {\n        case defs.ConnectionSecure:\n          bail(new Error(\n            \"Wasn't expecting to have to go through secure\"));\n          break;\n        case defs.ConnectionClose:\n          bail(new Error(fmt(\"Handshake terminated by server: %s\",\n            closeMsg(reply))));\n          break;\n        case defs.ConnectionTune:\n          var fields = reply.fields;\n          tunedOptions.frameMax =\n            negotiate(fields.frameMax, allFields.frameMax);\n          tunedOptions.channelMax =\n            negotiate(fields.channelMax, allFields.channelMax);\n          tunedOptions.heartbeat =\n            negotiate(fields.heartbeat, allFields.heartbeat);\n          try {\n            send(defs.ConnectionTuneOk);\n            send(defs.ConnectionOpen);\n          } catch (err) {\n            bail(err);\n            return;\n          }\n          expect(defs.ConnectionOpenOk, onOpenOk);\n          break;\n        default:\n          bail(new Error(\n            fmt(\"Expected connection.secure, connection.close, \" +\n              \"or connection.tune during handshake; got %s\",\n              inspect(reply, false))));\n          break;\n      }\n    }\n\n    function onOpenOk (openOk) {\n      // Impose the maximum of the encoded value, if the negotiated\n      // value is zero, meaning \"no, no limits\"\n      self.channelMax = tunedOptions.channelMax || 0xffff;\n      self.frameMax = tunedOptions.frameMax || 0xffffffff;\n      // 0 means \"no heartbeat\", rather than \"maximum period of\n      // heartbeating\"\n      self.heartbeat = tunedOptions.heartbeat;\n      self.heartbeater = self.startHeartbeater();\n      self.accept = mainAccept;\n      succeed(openOk);\n    }\n\n    // If the server closes the connection, it's probably because of\n    // something we did\n    function endWhileOpening (err) {\n      bail(err || new Error('Socket closed abruptly ' +\n        'during opening handshake'));\n    }\n\n    this.stream.on('end', endWhileOpening);\n    this.stream.on('error', endWhileOpening);\n\n    function succeed (ok) {\n      self.stream.removeListener('end', endWhileOpening);\n      self.stream.removeListener('error', endWhileOpening);\n      self.stream.on('error', self.onSocketError.bind(self));\n      self.stream.on('end', self.onSocketError.bind(\n        self, new Error('Unexpected close')));\n      self.on('frameError', self.onSocketError.bind(self));\n      self.acceptLoop();\n      openCallback(null, ok);\n    }\n\n    // Now kick off the handshake by prompting the server\n    this.sendProtocolHeader();\n    expect(defs.ConnectionStart, onStart);\n  }\n\n  // Closing things: AMQP has a closing handshake that applies to\n  // closing both connects and channels. As the initiating party, I send\n  // Close, then ignore all frames until I see either CloseOK --\n  // which signifies that the other party has seen the Close and shut\n  // the connection or channel down, so it's fine to free resources; or\n  // Close, which means the other party also wanted to close the\n  // whatever, and I should send CloseOk so it can free resources,\n  // then go back to waiting for the CloseOk. If I receive a Close\n  // out of the blue, I should throw away any unsent frames (they will\n  // be ignored anyway) and send CloseOk, then clean up resources. In\n  // general, Close out of the blue signals an error (or a forced\n  // closure, which may as well be an error).\n  //\n  //  RUNNING [1] --- send Close ---> Closing [2] ---> recv Close --+\n  //     |                               |                         [3]\n  //     |                               +------ send CloseOk ------+\n  //  recv Close                   recv CloseOk\n  //     |                               |\n  //     V                               V\n  //  Ended [4] ---- send CloseOk ---> Closed [5]\n  //\n  // [1] All frames accepted; getting a Close frame from the server\n  // moves to Ended; client may initiate a close by sending Close\n  // itself.\n  // [2] Client has initiated a close; only CloseOk or (simulataneously\n  // sent) Close is accepted.\n  // [3] Simultaneous close\n  // [4] Server won't send any more frames; accept no more frames, send\n  // CloseOk.\n  // [5] Fully closed, client will send no more, server will send no\n  // more. Signal 'close' or 'error'.\n  //\n  // There are two signalling mechanisms used in the API. The first is\n  // that calling `close` will return a promise, that will either\n  // resolve once the connection or channel is cleanly shut down, or\n  // will reject if the shutdown times out.\n  //\n  // The second is the 'close' and 'error' events. These are\n  // emitted as above. The events will fire *before* promises are\n  // resolved.\n  // Close the connection without even giving a reason. Typical.\n  close (closeCallback) {\n    var k = closeCallback && function () { closeCallback(null); };\n    this.closeBecause(\"Cheers, thanks\", constants.REPLY_SUCCESS, k);\n  }\n\n  // Close with a reason and a 'code'. I'm pretty sure RabbitMQ totally\n  // ignores these; maybe it logs them. The continuation will be invoked\n  // when the CloseOk has been received, and before the 'close' event.\n  closeBecause (reason, code, k) {\n    this.sendMethod(0, defs.ConnectionClose, {\n      replyText: reason,\n      replyCode: code,\n      methodId: 0, classId: 0\n    });\n    var s = stackCapture('closeBecause called: ' + reason);\n    this.toClosing(s, k);\n  }\n\n  closeWithError (reason, code, error) {\n    this.emit('error', error);\n    this.closeBecause(reason, code);\n  }\n\n  onSocketError (err) {\n    if (!this.expectSocketClose) {\n      // forestall any more calls to onSocketError, since we're signed\n      // up for `'error'` *and* `'end'`\n      this.expectSocketClose = true;\n      this.emit('error', err);\n      var s = stackCapture('Socket error');\n      this.toClosed(s, err);\n    }\n  }\n\n  // A close has been initiated. Repeat: a close has been initiated.\n  // This means we should not send more frames, anyway they will be\n  // ignored. We also have to shut down all the channels.\n  toClosing (capturedStack, k) {\n    var send = this.sendMethod.bind(this);\n\n    this.accept = function (f) {\n      if (f.id === defs.ConnectionCloseOk) {\n        if (k)\n          k();\n        var s = stackCapture('ConnectionCloseOk received');\n        this.toClosed(s, undefined);\n      }\n      else if (f.id === defs.ConnectionClose) {\n        send(0, defs.ConnectionCloseOk, {});\n      }\n      // else ignore frame\n    };\n    invalidateSend(this, 'Connection closing', capturedStack);\n  }\n\n  _closeChannels (capturedStack) {\n    for (var i = 1; i < this.channels.length; i++) {\n      var ch = this.channels[i];\n      if (ch !== null) {\n        ch.channel.toClosed(capturedStack); // %%% or with an error? not clear\n      }\n    }\n  }\n\n  // A close has been confirmed. Cease all communication.\n  toClosed (capturedStack, maybeErr) {\n    this._closeChannels(capturedStack);\n    var info = fmt('Connection closed (%s)',\n      (maybeErr) ? maybeErr.toString() : 'by client');\n    // Tidy up, invalidate enverything, dynamite the bridges.\n    invalidateSend(this, info, capturedStack);\n    this.accept = invalidOp(info, capturedStack);\n    this.close = function (cb) {\n      cb && cb(new IllegalOperationError(info, capturedStack));\n    };\n    if (this.heartbeater)\n      this.heartbeater.clear();\n    // This is certainly true now, if it wasn't before\n    this.expectSocketClose = true;\n    this.stream.end();\n    this.emit('close', maybeErr);\n  }\n\n  _updateSecret(newSecret, reason, cb) {\n    this.sendMethod(0, defs.ConnectionUpdateSecret, {\n      newSecret,\n      reason\n    });\n    this.once('update-secret-ok', cb);\n  }\n\n  // ===\n  startHeartbeater () {\n    if (this.heartbeat === 0)\n      return null;\n    else {\n      var self = this;\n      var hb = new Heart(this.heartbeat,\n        this.checkSend.bind(this),\n        this.checkRecv.bind(this));\n      hb.on('timeout', function () {\n        var hberr = new Error(\"Heartbeat timeout\");\n        self.emit('error', hberr);\n        var s = stackCapture('Heartbeat timeout');\n        self.toClosed(s, hberr);\n      });\n      hb.on('beat', function () {\n        self.sendHeartbeat();\n      });\n      return hb;\n    }\n  }\n\n  // I use an array to keep track of the channels, rather than an\n  // object. The channel identifiers are numbers, and allocated by the\n  // connection. If I try to allocate low numbers when they are\n  // available (which I do, by looking from the start of the bitset),\n  // this ought to keep the array small, and out of 'sparse array\n  // storage'. I also set entries to null, rather than deleting them, in\n  // the expectation that the next channel allocation will fill the slot\n  // again rather than growing the array. See\n  // http://www.html5rocks.com/en/tutorials/speed/v8/\n  freshChannel (channel, options) {\n    var next = this.freeChannels.nextClearBit(1);\n    if (next < 0 || next > this.channelMax)\n      throw new Error(\"No channels left to allocate\");\n    this.freeChannels.set(next);\n\n    var hwm = (options && options.highWaterMark) || DEFAULT_WRITE_HWM;\n    var writeBuffer = new PassThrough({\n      objectMode: true, highWaterMark: hwm\n    });\n    this.channels[next] = { channel: channel, buffer: writeBuffer };\n    writeBuffer.on('drain', function () {\n      channel.onBufferDrain();\n    });\n    this.muxer.pipeFrom(writeBuffer);\n    return next;\n  }\n\n  releaseChannel (channel) {\n    this.freeChannels.clear(channel);\n    var buffer = this.channels[channel].buffer;\n    buffer.end(); // will also cause it to be unpiped\n    this.channels[channel] = null;\n  }\n\n  acceptLoop () {\n    var self = this;\n\n    function go () {\n      try {\n        var f; while (f = self.recvFrame())\n          self.accept(f);\n      }\n      catch (e) {\n        self.emit('frameError', e);\n      }\n    }\n    self.stream.on('readable', go);\n    go();\n  }\n\n  step (cb) {\n    var self = this;\n    function recv () {\n      var f;\n      try {\n        f = self.recvFrame();\n      }\n      catch (e) {\n        cb(e, null);\n        return;\n      }\n      if (f)\n        cb(null, f);\n      else\n        self.stream.once('readable', recv);\n    }\n    recv();\n  }\n\n  checkSend () {\n    var check = this.sentSinceLastCheck;\n    this.sentSinceLastCheck = false;\n    return check;\n  }\n\n  checkRecv () {\n    var check = this.recvSinceLastCheck;\n    this.recvSinceLastCheck = false;\n    return check;\n  }\n\n  sendBytes (bytes) {\n    this.sentSinceLastCheck = true;\n    this.stream.write(bytes);\n  }\n\n  sendHeartbeat () {\n    return this.sendBytes(frame.HEARTBEAT_BUF);\n  }\n\n  sendMethod (channel, Method, fields) {\n    var frame = encodeMethod(Method, channel, fields);\n    this.sentSinceLastCheck = true;\n    var buffer = this.channels[channel].buffer;\n    return buffer.write(frame);\n  }\n\n  sendMessage (channel, Method, fields, Properties, props, content) {\n    if (!Buffer.isBuffer(content))\n      throw new TypeError('content is not a buffer');\n\n    var mframe = encodeMethod(Method, channel, fields);\n    var pframe = encodeProperties(Properties, channel,\n      content.length, props);\n    var buffer = this.channels[channel].buffer;\n    this.sentSinceLastCheck = true;\n\n    var methodHeaderLen = mframe.length + pframe.length;\n    var bodyLen = (content.length > 0) ?\n      content.length + FRAME_OVERHEAD : 0;\n    var allLen = methodHeaderLen + bodyLen;\n\n    if (allLen < SINGLE_CHUNK_THRESHOLD) {\n      // Use `allocUnsafe` to avoid excessive allocations and CPU usage\n      // from zeroing. The returned Buffer is not zeroed and so must be\n      // completely filled to be used safely.\n      // See https://github.com/amqp-node/amqplib/pull/695\n      var all = Buffer.allocUnsafe(allLen);\n      var offset = mframe.copy(all, 0);\n      offset += pframe.copy(all, offset);\n\n      if (bodyLen > 0)\n        makeBodyFrame(channel, content).copy(all, offset);\n      return buffer.write(all);\n    }\n    else {\n      if (methodHeaderLen < SINGLE_CHUNK_THRESHOLD) {\n        // Use `allocUnsafe` to avoid excessive allocations and CPU usage\n        // from zeroing. The returned Buffer is not zeroed and so must be\n        // completely filled to be used safely.\n        // See https://github.com/amqp-node/amqplib/pull/695\n        var both = Buffer.allocUnsafe(methodHeaderLen);\n        var offset = mframe.copy(both, 0);\n        pframe.copy(both, offset);\n        buffer.write(both);\n      }\n      else {\n        buffer.write(mframe);\n        buffer.write(pframe);\n      }\n      return this.sendContent(channel, content);\n    }\n  }\n\n  sendContent (channel, body) {\n    if (!Buffer.isBuffer(body)) {\n      throw new TypeError(fmt(\"Expected buffer; got %s\", body));\n    }\n    var writeResult = true;\n    var buffer = this.channels[channel].buffer;\n\n    var maxBody = this.frameMax - FRAME_OVERHEAD;\n\n    for (var offset = 0; offset < body.length; offset += maxBody) {\n      var end = offset + maxBody;\n      var slice = (end > body.length) ? body.subarray(offset) : body.subarray(offset, end);\n      var bodyFrame = makeBodyFrame(channel, slice);\n      writeResult = buffer.write(bodyFrame);\n    }\n    this.sentSinceLastCheck = true;\n    return writeResult;\n  }\n\n  recvFrame () {\n    // %%% identifying invariants might help here?\n    var frame = parseFrame(this.rest, this.frameMax);\n\n    if (!frame) {\n      var incoming = this.stream.read();\n      if (incoming === null) {\n        return false;\n      }\n      else {\n        this.recvSinceLastCheck = true;\n        this.rest = Buffer.concat([this.rest, incoming]);\n        return this.recvFrame();\n      }\n    }\n    else {\n      this.rest = frame.rest;\n      return decodeFrame(frame);\n    }\n  }\n}\n\n// Usual frame accept mode\nfunction mainAccept(frame) {\n  var rec = this.channels[frame.channel];\n  if (rec) { return rec.channel.accept(frame); }\n  // NB CHANNEL_ERROR may not be right, but I don't know what is ..\n  else\n    this.closeWithError(\n      fmt('Frame on unknown channel %d', frame.channel),\n      constants.CHANNEL_ERROR,\n      new Error(fmt(\"Frame on unknown channel: %s\",\n                    inspect(frame, false))));\n}\n\n// Handle anything that comes through on channel 0, that's the\n// connection control channel. This is only used once mainAccept is\n// installed as the frame handler, after the opening handshake.\nfunction channel0(connection) {\n  return function(f) {\n    // Once we get a 'close', we know 1. we'll get no more frames, and\n    // 2. anything we send except close, or close-ok, will be\n    // ignored. If we already sent 'close', this won't be invoked since\n    // we're already in closing mode; if we didn't well we're not going\n    // to send it now are we.\n    if (f === HEARTBEAT); // ignore; it's already counted as activity\n                          // on the socket, which is its purpose\n    else if (f.id === defs.ConnectionClose) {\n      // Oh. OK. I guess we're done here then.\n      connection.sendMethod(0, defs.ConnectionCloseOk, {});\n      var emsg = fmt('Connection closed: %s', closeMsg(f));\n      var s = stackCapture(emsg);\n      var e = new Error(emsg);\n      e.code = f.fields.replyCode;\n      if (isFatalError(e)) {\n        connection.emit('error', e);\n      }\n      connection.toClosed(s, e);\n    }\n    else if (f.id === defs.ConnectionBlocked) {\n      connection.emit('blocked', f.fields.reason);\n    }\n    else if (f.id === defs.ConnectionUnblocked) {\n      connection.emit('unblocked');\n    }\n    else if (f.id === defs.ConnectionUpdateSecretOk) {\n      connection.emit('update-secret-ok');\n    }\n    else {\n      connection.closeWithError(\n        fmt(\"Unexpected frame on channel 0\"),\n        constants.UNEXPECTED_FRAME,\n        new Error(fmt(\"Unexpected frame on channel 0: %s\",\n                      inspect(f, false))));\n    }\n  };\n}\n\nfunction invalidOp(msg, stack) {\n  return function() {\n    throw new IllegalOperationError(msg, stack);\n  };\n}\n\nfunction invalidateSend(conn, msg, stack) {\n  conn.sendMethod = conn.sendContent = conn.sendMessage =\n    invalidOp(msg, stack);\n}\n\nvar encodeMethod = defs.encodeMethod;\nvar encodeProperties = defs.encodeProperties;\n\nvar FRAME_OVERHEAD = defs.FRAME_OVERHEAD;\nvar makeBodyFrame = frame.makeBodyFrame;\n\nvar parseFrame = frame.parseFrame;\nvar decodeFrame = frame.decodeFrame;\n\nfunction wrapStream(s) {\n  if (s instanceof Duplex) return s;\n  else {\n    var ws = new Duplex();\n    ws.wrap(s); //wraps the readable side of things\n    ws._write = function(chunk, encoding, callback) {\n      return s.write(chunk, encoding, callback);\n    };\n    return ws;\n  }\n}\n\nfunction isFatalError(error) {\n  switch (error && error.code) {\n  case defs.constants.CONNECTION_FORCED:\n  case defs.constants.REPLY_SUCCESS:\n    return false;\n  default:\n    return true;\n  }\n}\n\nmodule.exports.Connection = Connection;\nmodule.exports.isFatalError = isFatalError;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29ubmVjdGlvbi5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsV0FBVyxtQkFBTyxDQUFDLHdEQUFRO0FBQzNCO0FBQ0EsWUFBWSxtQkFBTyxDQUFDLDBEQUFTO0FBQzdCO0FBQ0EsVUFBVSxpRkFBb0I7O0FBRTlCO0FBQ0EsRUFBRSxvREFBd0I7QUFDMUIsRUFBRSxtQkFBTyxDQUFDLDhFQUF3QjtBQUNsQyxtQkFBbUIsbUJBQU8sQ0FBQyxzQkFBUTtBQUNuQyxZQUFZLCtGQUE0Qjs7QUFFeEMsaUJBQWlCLDhGQUE4QjtBQUMvQyxlQUFlLGdHQUFnQztBQUMvQyxjQUFjLDJGQUEyQjs7QUFFekMsYUFBYSwwRkFBMEI7QUFDdkMsVUFBVSxnREFBc0I7QUFDaEMsa0JBQWtCLHlEQUE2QjtBQUMvQyxFQUFFLG1CQUFPLENBQUMsd0ZBQTZCO0FBQ3ZDLDRCQUE0Qix1R0FBd0M7QUFDcEUsbUJBQW1CLDhGQUErQjs7QUFFbEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQix3QkFBd0I7QUFDekM7QUFDQSxLQUFLO0FBQ0w7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsUUFBUTtBQUNSO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Q7QUFDcEQ7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUVBQXFFO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsOEJBQThCO0FBQzlCLHFCQUFxQjtBQUNyQjtBQUNBLHVDQUF1QztBQUN2QztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkM7QUFDM0M7QUFDQTs7QUFFQTtBQUNBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBDQUEwQztBQUMxQztBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0Esb0JBQW9CLDBCQUEwQjtBQUM5QztBQUNBO0FBQ0EsNENBQTRDO0FBQzVDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsT0FBTztBQUNQO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxrQkFBa0I7QUFDbEI7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxlQUFlO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBOztBQUVBOztBQUVBLHlCQUF5QixzQkFBc0I7QUFDL0M7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDO0FBQ3RDO0FBQ0EsMEJBQTBCLFdBQVc7QUFDckM7QUFDQTtBQUNBO0FBQ0EseURBQXlEO0FBQ3pEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0JBQWdCO0FBQ2hCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCLDJCQUEyQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjIvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY29ubmVjdGlvbi5qcz84MWYyIl0sInNvdXJjZXNDb250ZW50IjpbIi8vXG4vL1xuLy9cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmcyA9IHJlcXVpcmUoJy4vZGVmcycpO1xudmFyIGNvbnN0YW50cyA9IGRlZnMuY29uc3RhbnRzO1xudmFyIGZyYW1lID0gcmVxdWlyZSgnLi9mcmFtZScpO1xudmFyIEhFQVJUQkVBVCA9IGZyYW1lLkhFQVJUQkVBVDtcbnZhciBNdXggPSByZXF1aXJlKCcuL211eCcpLk11eDtcblxudmFyIER1cGxleCA9XG4gIHJlcXVpcmUoJ3N0cmVhbScpLkR1cGxleCB8fFxuICByZXF1aXJlKCdyZWFkYWJsZS1zdHJlYW0vZHVwbGV4Jyk7XG52YXIgRXZlbnRFbWl0dGVyID0gcmVxdWlyZSgnZXZlbnRzJyk7XG52YXIgSGVhcnQgPSByZXF1aXJlKCcuL2hlYXJ0YmVhdCcpLkhlYXJ0O1xuXG52YXIgbWV0aG9kTmFtZSA9IHJlcXVpcmUoJy4vZm9ybWF0JykubWV0aG9kTmFtZTtcbnZhciBjbG9zZU1zZyA9IHJlcXVpcmUoJy4vZm9ybWF0JykuY2xvc2VNZXNzYWdlO1xudmFyIGluc3BlY3QgPSByZXF1aXJlKCcuL2Zvcm1hdCcpLmluc3BlY3Q7XG5cbnZhciBCaXRTZXQgPSByZXF1aXJlKCcuL2JpdHNldCcpLkJpdFNldDtcbnZhciBmbXQgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xudmFyIFBhc3NUaHJvdWdoID0gcmVxdWlyZSgnc3RyZWFtJykuUGFzc1Rocm91Z2ggfHxcbiAgcmVxdWlyZSgncmVhZGFibGUtc3RyZWFtL3Bhc3N0aHJvdWdoJyk7XG52YXIgSWxsZWdhbE9wZXJhdGlvbkVycm9yID0gcmVxdWlyZSgnLi9lcnJvcicpLklsbGVnYWxPcGVyYXRpb25FcnJvcjtcbnZhciBzdGFja0NhcHR1cmUgPSByZXF1aXJlKCcuL2Vycm9yJykuc3RhY2tDYXB0dXJlO1xuXG4vLyBIaWdoLXdhdGVyIG1hcmsgZm9yIGNoYW5uZWwgd3JpdGUgYnVmZmVycywgaW4gJ29iamVjdHMnICh3aGljaCBhcmVcbi8vIGVuY29kZWQgZnJhbWVzIGFzIGJ1ZmZlcnMpLlxudmFyIERFRkFVTFRfV1JJVEVfSFdNID0gMTAyNDtcbi8vIElmIGFsbCB0aGUgZnJhbWVzIG9mIGEgbWVzc2FnZSAobWV0aG9kLCBwcm9wZXJ0aWVzLCBjb250ZW50KSB0b3RhbFxuLy8gdG8gbGVzcyB0aGFuIHRoaXMsIGNvcHkgdGhlbSBpbnRvIGEgc2luZ2xlIGJ1ZmZlciBhbmQgd3JpdGUgaXQgYWxsXG4vLyBhdCBvbmNlLiBOb3RlIHRoYXQgdGhpcyBpcyBsZXNzIHRoYW4gdGhlIG1pbmltdW0gZnJhbWUgc2l6ZTogaWYgaXRcbi8vIHdhcyBncmVhdGVyLCB3ZSBtaWdodCBoYXZlIHRvIGZyYWdtZW50IHRoZSBjb250ZW50LlxudmFyIFNJTkdMRV9DSFVOS19USFJFU0hPTEQgPSAyMDQ4O1xuXG5jbGFzcyBDb25uZWN0aW9uIGV4dGVuZHMgRXZlbnRFbWl0dGVyIHtcbiAgY29uc3RydWN0b3IgKHVuZGVybHlpbmcpIHtcbiAgICBzdXBlcigpO1xuXG4gICAgdmFyIHN0cmVhbSA9IHRoaXMuc3RyZWFtID0gd3JhcFN0cmVhbSh1bmRlcmx5aW5nKTtcbiAgICB0aGlzLm11eGVyID0gbmV3IE11eChzdHJlYW0pO1xuXG4gICAgLy8gZnJhbWVzXG4gICAgdGhpcy5yZXN0ID0gQnVmZmVyLmFsbG9jKDApO1xuICAgIHRoaXMuZnJhbWVNYXggPSBjb25zdGFudHMuRlJBTUVfTUlOX1NJWkU7XG4gICAgdGhpcy5zZW50U2luY2VMYXN0Q2hlY2sgPSBmYWxzZTtcbiAgICB0aGlzLnJlY3ZTaW5jZUxhc3RDaGVjayA9IGZhbHNlO1xuXG4gICAgdGhpcy5leHBlY3RTb2NrZXRDbG9zZSA9IGZhbHNlO1xuICAgIHRoaXMuZnJlZUNoYW5uZWxzID0gbmV3IEJpdFNldCgpO1xuICAgIHRoaXMuY2hhbm5lbHMgPSBbe1xuICAgICAgY2hhbm5lbDogeyBhY2NlcHQ6IGNoYW5uZWwwKHRoaXMpIH0sXG4gICAgICBidWZmZXI6IHVuZGVybHlpbmdcbiAgICB9XTtcbiAgfVxuXG4gIC8vIFRoaXMgY2hhbmdlZCBiZXR3ZWVuIHZlcnNpb25zLCBhcyBkaWQgdGhlIGNvZGVjLCBtZXRob2RzLCBldGMuIEFNUVBcbiAgLy8gMC05LTEgaXMgZmFpcmx5IHNpbWlsYXIgdG8gMC44LCBidXQgYmV0dGVyLCBhbmQgbm90aGluZyBpbXBsZW1lbnRzXG4gIC8vIDAuOCB0aGF0IGRvZXNuJ3QgaW1wbGVtZW50IDAtOS0xLiBJbiBvdGhlciB3b3JkcywgaXQgZG9lc24ndCBtYWtlXG4gIC8vIG11Y2ggc2Vuc2UgdG8gZ2VuZXJhbGlzZSBoZXJlLlxuICBzZW5kUHJvdG9jb2xIZWFkZXIgKCkge1xuICAgIHRoaXMuc2VuZEJ5dGVzKGZyYW1lLlBST1RPQ09MX0hFQURFUik7XG4gIH1cblxuICAvKlxuICAgIFRoZSBmcmlnaHRlbmluZ2x5IGNvbXBsaWNhdGVkIG9wZW5pbmcgcHJvdG9jb2wgKHNwZWMgc2VjdGlvbiAyLjIuNCk6XG5cbiAgICAgICBDbGllbnQgLT4gU2VydmVyXG5cbiAgICAgICAgIHByb3RvY29sIGhlYWRlciAtPlxuICAgICAgICAgICA8LSBzdGFydFxuICAgICAgICAgc3RhcnQtb2sgLT5cbiAgICAgICAuLiBuZXh0IHR3byB6ZXJvIG9yIG1vcmUgdGltZXMgLi5cbiAgICAgICAgICAgPC0gc2VjdXJlXG4gICAgICAgICBzZWN1cmUtb2sgLT5cbiAgICAgICAgICAgPC0gdHVuZVxuICAgICAgICAgdHVuZS1vayAtPlxuICAgICAgICAgb3BlbiAtPlxuICAgICAgICAgICA8LSBvcGVuLW9rXG5cbiAgSWYgSSdtIG9ubHkgc3VwcG9ydGluZyBTQVNMJ3MgUExBSU4gbWVjaGFuaXNtICh3aGljaCBJIGFtIGZvciB0aGUgdGltZVxuICBiZWluZyksIGl0IGdldHMgYSBiaXQgZWFzaWVyIHNpbmNlIHRoZSBzZXJ2ZXIgd29uJ3QgaW4gZ2VuZXJhbCBzZW5kXG4gIGJhY2sgYSBgc2VjdXJlYCwgaXQnbGwganVzdCBzZW5kIGB0dW5lYCBhZnRlciB0aGUgYHN0YXJ0LW9rYC5cbiAgKFNBU0wgUExBSU46IGh0dHA6Ly90b29scy5pZXRmLm9yZy9odG1sL3JmYzQ2MTYpXG5cbiAgKi9cbiAgb3BlbiAoYWxsRmllbGRzLCBvcGVuQ2FsbGJhY2swKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuICAgIHZhciBvcGVuQ2FsbGJhY2sgPSBvcGVuQ2FsbGJhY2swIHx8IGZ1bmN0aW9uICgpIHsgfTtcblxuICAgIC8vIFRoaXMgaXMgd2hlcmUgd2UnbGwgcHV0IG91ciBuZWdvdGlhdGVkIHZhbHVlc1xuICAgIHZhciB0dW5lZE9wdGlvbnMgPSBPYmplY3QuY3JlYXRlKGFsbEZpZWxkcyk7XG5cbiAgICBmdW5jdGlvbiB3YWl0IChrKSB7XG4gICAgICBzZWxmLnN0ZXAoZnVuY3Rpb24gKGVyciwgZnJhbWUpIHtcbiAgICAgICAgaWYgKGVyciAhPT0gbnVsbClcbiAgICAgICAgICBiYWlsKGVycik7XG4gICAgICAgIGVsc2UgaWYgKGZyYW1lLmNoYW5uZWwgIT09IDApIHtcbiAgICAgICAgICBiYWlsKG5ldyBFcnJvcihcbiAgICAgICAgICAgIGZtdChcIkZyYW1lIG9uIGNoYW5uZWwgIT0gMCBkdXJpbmcgaGFuZHNoYWtlOiAlc1wiLFxuICAgICAgICAgICAgICBpbnNwZWN0KGZyYW1lLCBmYWxzZSkpKSk7XG4gICAgICAgIH1cbiAgICAgICAgZWxzZVxuICAgICAgICAgIGsoZnJhbWUpO1xuICAgICAgfSk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gZXhwZWN0IChNZXRob2QsIGspIHtcbiAgICAgIHdhaXQoZnVuY3Rpb24gKGZyYW1lKSB7XG4gICAgICAgIGlmIChmcmFtZS5pZCA9PT0gTWV0aG9kKVxuICAgICAgICAgIGsoZnJhbWUpO1xuICAgICAgICBlbHNlIHtcbiAgICAgICAgICBiYWlsKG5ldyBFcnJvcihcbiAgICAgICAgICAgIGZtdChcIkV4cGVjdGVkICVzOyBnb3QgJXNcIixcbiAgICAgICAgICAgICAgbWV0aG9kTmFtZShNZXRob2QpLCBpbnNwZWN0KGZyYW1lLCBmYWxzZSkpKSk7XG4gICAgICAgIH1cbiAgICAgIH0pO1xuICAgIH1cblxuICAgIGZ1bmN0aW9uIGJhaWwgKGVycikge1xuICAgICAgb3BlbkNhbGxiYWNrKGVycik7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gc2VuZCAoTWV0aG9kKSB7XG4gICAgICAvLyBUaGlzIGNhbiB0aHJvdyBhbiBleGNlcHRpb24gaWYgdGhlcmUncyBzb21lIHByb2JsZW0gd2l0aCB0aGVcbiAgICAgIC8vIG9wdGlvbnM7IGUuZy4sIHNvbWV0aGluZyBpcyBhIHN0cmluZyBpbnN0ZWFkIG9mIGEgbnVtYmVyLlxuICAgICAgc2VsZi5zZW5kTWV0aG9kKDAsIE1ldGhvZCwgdHVuZWRPcHRpb25zKTtcbiAgICB9XG5cbiAgICBmdW5jdGlvbiBuZWdvdGlhdGUgKHNlcnZlciwgZGVzaXJlZCkge1xuICAgICAgLy8gV2UgZ2V0IHNlbnQgdmFsdWVzIGZvciBjaGFubmVsTWF4LCBmcmFtZU1heCBhbmQgaGVhcnRiZWF0LFxuICAgICAgLy8gd2hpY2ggd2UgbWF5IGFjY2VwdCBvciBsb3dlciAoc3ViamVjdCB0byBhIG1pbmltdW0gZm9yXG4gICAgICAvLyBmcmFtZU1heCwgYnV0IHdlJ2xsIGxlYXZlIHRoYXQgdG8gdGhlIHNlcnZlciB0byBlbmZvcmNlKS4gSW5cbiAgICAgIC8vIGFsbCBjYXNlcywgYDBgIHJlYWxseSBtZWFucyBcIm5vIGxpbWl0XCIsIG9yIHJhdGhlciB0aGUgaGlnaGVzdFxuICAgICAgLy8gdmFsdWUgaW4gdGhlIGVuY29kaW5nLCBlLmcuLCB1bnNpZ25lZCBzaG9ydCBmb3IgY2hhbm5lbE1heC5cbiAgICAgIGlmIChzZXJ2ZXIgPT09IDAgfHwgZGVzaXJlZCA9PT0gMCkge1xuICAgICAgICAvLyBpLmUuLCB3aGljaGV2ZXIgcGxhY2VzIGEgbGltaXQsIGlmIGVpdGhlclxuICAgICAgICByZXR1cm4gTWF0aC5tYXgoc2VydmVyLCBkZXNpcmVkKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICByZXR1cm4gTWF0aC5taW4oc2VydmVyLCBkZXNpcmVkKTtcbiAgICAgIH1cbiAgICB9XG5cbiAgICBmdW5jdGlvbiBvblN0YXJ0IChzdGFydCkge1xuICAgICAgdmFyIG1lY2hhbmlzbXMgPSBzdGFydC5maWVsZHMubWVjaGFuaXNtcy50b1N0cmluZygpLnNwbGl0KCcgJyk7XG4gICAgICBpZiAobWVjaGFuaXNtcy5pbmRleE9mKGFsbEZpZWxkcy5tZWNoYW5pc20pIDwgMCkge1xuICAgICAgICBiYWlsKG5ldyBFcnJvcihmbXQoJ1NBU0wgbWVjaGFuaXNtICVzIGlzIG5vdCBwcm92aWRlZCBieSB0aGUgc2VydmVyJyxcbiAgICAgICAgICBhbGxGaWVsZHMubWVjaGFuaXNtKSkpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICBzZWxmLnNlcnZlclByb3BlcnRpZXMgPSBzdGFydC5maWVsZHMuc2VydmVyUHJvcGVydGllcztcbiAgICAgIHRyeSB7XG4gICAgICAgIHNlbmQoZGVmcy5Db25uZWN0aW9uU3RhcnRPayk7XG4gICAgICB9IGNhdGNoIChlcnIpIHtcbiAgICAgICAgYmFpbChlcnIpO1xuICAgICAgICByZXR1cm47XG4gICAgICB9XG4gICAgICB3YWl0KGFmdGVyU3RhcnRPayk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gYWZ0ZXJTdGFydE9rIChyZXBseSkge1xuICAgICAgc3dpdGNoIChyZXBseS5pZCkge1xuICAgICAgICBjYXNlIGRlZnMuQ29ubmVjdGlvblNlY3VyZTpcbiAgICAgICAgICBiYWlsKG5ldyBFcnJvcihcbiAgICAgICAgICAgIFwiV2Fzbid0IGV4cGVjdGluZyB0byBoYXZlIHRvIGdvIHRocm91Z2ggc2VjdXJlXCIpKTtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSBkZWZzLkNvbm5lY3Rpb25DbG9zZTpcbiAgICAgICAgICBiYWlsKG5ldyBFcnJvcihmbXQoXCJIYW5kc2hha2UgdGVybWluYXRlZCBieSBzZXJ2ZXI6ICVzXCIsXG4gICAgICAgICAgICBjbG9zZU1zZyhyZXBseSkpKSk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGNhc2UgZGVmcy5Db25uZWN0aW9uVHVuZTpcbiAgICAgICAgICB2YXIgZmllbGRzID0gcmVwbHkuZmllbGRzO1xuICAgICAgICAgIHR1bmVkT3B0aW9ucy5mcmFtZU1heCA9XG4gICAgICAgICAgICBuZWdvdGlhdGUoZmllbGRzLmZyYW1lTWF4LCBhbGxGaWVsZHMuZnJhbWVNYXgpO1xuICAgICAgICAgIHR1bmVkT3B0aW9ucy5jaGFubmVsTWF4ID1cbiAgICAgICAgICAgIG5lZ290aWF0ZShmaWVsZHMuY2hhbm5lbE1heCwgYWxsRmllbGRzLmNoYW5uZWxNYXgpO1xuICAgICAgICAgIHR1bmVkT3B0aW9ucy5oZWFydGJlYXQgPVxuICAgICAgICAgICAgbmVnb3RpYXRlKGZpZWxkcy5oZWFydGJlYXQsIGFsbEZpZWxkcy5oZWFydGJlYXQpO1xuICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICBzZW5kKGRlZnMuQ29ubmVjdGlvblR1bmVPayk7XG4gICAgICAgICAgICBzZW5kKGRlZnMuQ29ubmVjdGlvbk9wZW4pO1xuICAgICAgICAgIH0gY2F0Y2ggKGVycikge1xuICAgICAgICAgICAgYmFpbChlcnIpO1xuICAgICAgICAgICAgcmV0dXJuO1xuICAgICAgICAgIH1cbiAgICAgICAgICBleHBlY3QoZGVmcy5Db25uZWN0aW9uT3Blbk9rLCBvbk9wZW5Payk7XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgYmFpbChuZXcgRXJyb3IoXG4gICAgICAgICAgICBmbXQoXCJFeHBlY3RlZCBjb25uZWN0aW9uLnNlY3VyZSwgY29ubmVjdGlvbi5jbG9zZSwgXCIgK1xuICAgICAgICAgICAgICBcIm9yIGNvbm5lY3Rpb24udHVuZSBkdXJpbmcgaGFuZHNoYWtlOyBnb3QgJXNcIixcbiAgICAgICAgICAgICAgaW5zcGVjdChyZXBseSwgZmFsc2UpKSkpO1xuICAgICAgICAgIGJyZWFrO1xuICAgICAgfVxuICAgIH1cblxuICAgIGZ1bmN0aW9uIG9uT3Blbk9rIChvcGVuT2spIHtcbiAgICAgIC8vIEltcG9zZSB0aGUgbWF4aW11bSBvZiB0aGUgZW5jb2RlZCB2YWx1ZSwgaWYgdGhlIG5lZ290aWF0ZWRcbiAgICAgIC8vIHZhbHVlIGlzIHplcm8sIG1lYW5pbmcgXCJubywgbm8gbGltaXRzXCJcbiAgICAgIHNlbGYuY2hhbm5lbE1heCA9IHR1bmVkT3B0aW9ucy5jaGFubmVsTWF4IHx8IDB4ZmZmZjtcbiAgICAgIHNlbGYuZnJhbWVNYXggPSB0dW5lZE9wdGlvbnMuZnJhbWVNYXggfHwgMHhmZmZmZmZmZjtcbiAgICAgIC8vIDAgbWVhbnMgXCJubyBoZWFydGJlYXRcIiwgcmF0aGVyIHRoYW4gXCJtYXhpbXVtIHBlcmlvZCBvZlxuICAgICAgLy8gaGVhcnRiZWF0aW5nXCJcbiAgICAgIHNlbGYuaGVhcnRiZWF0ID0gdHVuZWRPcHRpb25zLmhlYXJ0YmVhdDtcbiAgICAgIHNlbGYuaGVhcnRiZWF0ZXIgPSBzZWxmLnN0YXJ0SGVhcnRiZWF0ZXIoKTtcbiAgICAgIHNlbGYuYWNjZXB0ID0gbWFpbkFjY2VwdDtcbiAgICAgIHN1Y2NlZWQob3Blbk9rKTtcbiAgICB9XG5cbiAgICAvLyBJZiB0aGUgc2VydmVyIGNsb3NlcyB0aGUgY29ubmVjdGlvbiwgaXQncyBwcm9iYWJseSBiZWNhdXNlIG9mXG4gICAgLy8gc29tZXRoaW5nIHdlIGRpZFxuICAgIGZ1bmN0aW9uIGVuZFdoaWxlT3BlbmluZyAoZXJyKSB7XG4gICAgICBiYWlsKGVyciB8fCBuZXcgRXJyb3IoJ1NvY2tldCBjbG9zZWQgYWJydXB0bHkgJyArXG4gICAgICAgICdkdXJpbmcgb3BlbmluZyBoYW5kc2hha2UnKSk7XG4gICAgfVxuXG4gICAgdGhpcy5zdHJlYW0ub24oJ2VuZCcsIGVuZFdoaWxlT3BlbmluZyk7XG4gICAgdGhpcy5zdHJlYW0ub24oJ2Vycm9yJywgZW5kV2hpbGVPcGVuaW5nKTtcblxuICAgIGZ1bmN0aW9uIHN1Y2NlZWQgKG9rKSB7XG4gICAgICBzZWxmLnN0cmVhbS5yZW1vdmVMaXN0ZW5lcignZW5kJywgZW5kV2hpbGVPcGVuaW5nKTtcbiAgICAgIHNlbGYuc3RyZWFtLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGVuZFdoaWxlT3BlbmluZyk7XG4gICAgICBzZWxmLnN0cmVhbS5vbignZXJyb3InLCBzZWxmLm9uU29ja2V0RXJyb3IuYmluZChzZWxmKSk7XG4gICAgICBzZWxmLnN0cmVhbS5vbignZW5kJywgc2VsZi5vblNvY2tldEVycm9yLmJpbmQoXG4gICAgICAgIHNlbGYsIG5ldyBFcnJvcignVW5leHBlY3RlZCBjbG9zZScpKSk7XG4gICAgICBzZWxmLm9uKCdmcmFtZUVycm9yJywgc2VsZi5vblNvY2tldEVycm9yLmJpbmQoc2VsZikpO1xuICAgICAgc2VsZi5hY2NlcHRMb29wKCk7XG4gICAgICBvcGVuQ2FsbGJhY2sobnVsbCwgb2spO1xuICAgIH1cblxuICAgIC8vIE5vdyBraWNrIG9mZiB0aGUgaGFuZHNoYWtlIGJ5IHByb21wdGluZyB0aGUgc2VydmVyXG4gICAgdGhpcy5zZW5kUHJvdG9jb2xIZWFkZXIoKTtcbiAgICBleHBlY3QoZGVmcy5Db25uZWN0aW9uU3RhcnQsIG9uU3RhcnQpO1xuICB9XG5cbiAgLy8gQ2xvc2luZyB0aGluZ3M6IEFNUVAgaGFzIGEgY2xvc2luZyBoYW5kc2hha2UgdGhhdCBhcHBsaWVzIHRvXG4gIC8vIGNsb3NpbmcgYm90aCBjb25uZWN0cyBhbmQgY2hhbm5lbHMuIEFzIHRoZSBpbml0aWF0aW5nIHBhcnR5LCBJIHNlbmRcbiAgLy8gQ2xvc2UsIHRoZW4gaWdub3JlIGFsbCBmcmFtZXMgdW50aWwgSSBzZWUgZWl0aGVyIENsb3NlT0sgLS1cbiAgLy8gd2hpY2ggc2lnbmlmaWVzIHRoYXQgdGhlIG90aGVyIHBhcnR5IGhhcyBzZWVuIHRoZSBDbG9zZSBhbmQgc2h1dFxuICAvLyB0aGUgY29ubmVjdGlvbiBvciBjaGFubmVsIGRvd24sIHNvIGl0J3MgZmluZSB0byBmcmVlIHJlc291cmNlczsgb3JcbiAgLy8gQ2xvc2UsIHdoaWNoIG1lYW5zIHRoZSBvdGhlciBwYXJ0eSBhbHNvIHdhbnRlZCB0byBjbG9zZSB0aGVcbiAgLy8gd2hhdGV2ZXIsIGFuZCBJIHNob3VsZCBzZW5kIENsb3NlT2sgc28gaXQgY2FuIGZyZWUgcmVzb3VyY2VzLFxuICAvLyB0aGVuIGdvIGJhY2sgdG8gd2FpdGluZyBmb3IgdGhlIENsb3NlT2suIElmIEkgcmVjZWl2ZSBhIENsb3NlXG4gIC8vIG91dCBvZiB0aGUgYmx1ZSwgSSBzaG91bGQgdGhyb3cgYXdheSBhbnkgdW5zZW50IGZyYW1lcyAodGhleSB3aWxsXG4gIC8vIGJlIGlnbm9yZWQgYW55d2F5KSBhbmQgc2VuZCBDbG9zZU9rLCB0aGVuIGNsZWFuIHVwIHJlc291cmNlcy4gSW5cbiAgLy8gZ2VuZXJhbCwgQ2xvc2Ugb3V0IG9mIHRoZSBibHVlIHNpZ25hbHMgYW4gZXJyb3IgKG9yIGEgZm9yY2VkXG4gIC8vIGNsb3N1cmUsIHdoaWNoIG1heSBhcyB3ZWxsIGJlIGFuIGVycm9yKS5cbiAgLy9cbiAgLy8gIFJVTk5JTkcgWzFdIC0tLSBzZW5kIENsb3NlIC0tLT4gQ2xvc2luZyBbMl0gLS0tPiByZWN2IENsb3NlIC0tK1xuICAvLyAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8ICAgICAgICAgICAgICAgICAgICAgICAgIFszXVxuICAvLyAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICArLS0tLS0tIHNlbmQgQ2xvc2VPayAtLS0tLS0rXG4gIC8vICByZWN2IENsb3NlICAgICAgICAgICAgICAgICAgIHJlY3YgQ2xvc2VPa1xuICAvLyAgICAgfCAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB8XG4gIC8vICAgICBWICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIFZcbiAgLy8gIEVuZGVkIFs0XSAtLS0tIHNlbmQgQ2xvc2VPayAtLS0+IENsb3NlZCBbNV1cbiAgLy9cbiAgLy8gWzFdIEFsbCBmcmFtZXMgYWNjZXB0ZWQ7IGdldHRpbmcgYSBDbG9zZSBmcmFtZSBmcm9tIHRoZSBzZXJ2ZXJcbiAgLy8gbW92ZXMgdG8gRW5kZWQ7IGNsaWVudCBtYXkgaW5pdGlhdGUgYSBjbG9zZSBieSBzZW5kaW5nIENsb3NlXG4gIC8vIGl0c2VsZi5cbiAgLy8gWzJdIENsaWVudCBoYXMgaW5pdGlhdGVkIGEgY2xvc2U7IG9ubHkgQ2xvc2VPayBvciAoc2ltdWxhdGFuZW91c2x5XG4gIC8vIHNlbnQpIENsb3NlIGlzIGFjY2VwdGVkLlxuICAvLyBbM10gU2ltdWx0YW5lb3VzIGNsb3NlXG4gIC8vIFs0XSBTZXJ2ZXIgd29uJ3Qgc2VuZCBhbnkgbW9yZSBmcmFtZXM7IGFjY2VwdCBubyBtb3JlIGZyYW1lcywgc2VuZFxuICAvLyBDbG9zZU9rLlxuICAvLyBbNV0gRnVsbHkgY2xvc2VkLCBjbGllbnQgd2lsbCBzZW5kIG5vIG1vcmUsIHNlcnZlciB3aWxsIHNlbmQgbm9cbiAgLy8gbW9yZS4gU2lnbmFsICdjbG9zZScgb3IgJ2Vycm9yJy5cbiAgLy9cbiAgLy8gVGhlcmUgYXJlIHR3byBzaWduYWxsaW5nIG1lY2hhbmlzbXMgdXNlZCBpbiB0aGUgQVBJLiBUaGUgZmlyc3QgaXNcbiAgLy8gdGhhdCBjYWxsaW5nIGBjbG9zZWAgd2lsbCByZXR1cm4gYSBwcm9taXNlLCB0aGF0IHdpbGwgZWl0aGVyXG4gIC8vIHJlc29sdmUgb25jZSB0aGUgY29ubmVjdGlvbiBvciBjaGFubmVsIGlzIGNsZWFubHkgc2h1dCBkb3duLCBvclxuICAvLyB3aWxsIHJlamVjdCBpZiB0aGUgc2h1dGRvd24gdGltZXMgb3V0LlxuICAvL1xuICAvLyBUaGUgc2Vjb25kIGlzIHRoZSAnY2xvc2UnIGFuZCAnZXJyb3InIGV2ZW50cy4gVGhlc2UgYXJlXG4gIC8vIGVtaXR0ZWQgYXMgYWJvdmUuIFRoZSBldmVudHMgd2lsbCBmaXJlICpiZWZvcmUqIHByb21pc2VzIGFyZVxuICAvLyByZXNvbHZlZC5cbiAgLy8gQ2xvc2UgdGhlIGNvbm5lY3Rpb24gd2l0aG91dCBldmVuIGdpdmluZyBhIHJlYXNvbi4gVHlwaWNhbC5cbiAgY2xvc2UgKGNsb3NlQ2FsbGJhY2spIHtcbiAgICB2YXIgayA9IGNsb3NlQ2FsbGJhY2sgJiYgZnVuY3Rpb24gKCkgeyBjbG9zZUNhbGxiYWNrKG51bGwpOyB9O1xuICAgIHRoaXMuY2xvc2VCZWNhdXNlKFwiQ2hlZXJzLCB0aGFua3NcIiwgY29uc3RhbnRzLlJFUExZX1NVQ0NFU1MsIGspO1xuICB9XG5cbiAgLy8gQ2xvc2Ugd2l0aCBhIHJlYXNvbiBhbmQgYSAnY29kZScuIEknbSBwcmV0dHkgc3VyZSBSYWJiaXRNUSB0b3RhbGx5XG4gIC8vIGlnbm9yZXMgdGhlc2U7IG1heWJlIGl0IGxvZ3MgdGhlbS4gVGhlIGNvbnRpbnVhdGlvbiB3aWxsIGJlIGludm9rZWRcbiAgLy8gd2hlbiB0aGUgQ2xvc2VPayBoYXMgYmVlbiByZWNlaXZlZCwgYW5kIGJlZm9yZSB0aGUgJ2Nsb3NlJyBldmVudC5cbiAgY2xvc2VCZWNhdXNlIChyZWFzb24sIGNvZGUsIGspIHtcbiAgICB0aGlzLnNlbmRNZXRob2QoMCwgZGVmcy5Db25uZWN0aW9uQ2xvc2UsIHtcbiAgICAgIHJlcGx5VGV4dDogcmVhc29uLFxuICAgICAgcmVwbHlDb2RlOiBjb2RlLFxuICAgICAgbWV0aG9kSWQ6IDAsIGNsYXNzSWQ6IDBcbiAgICB9KTtcbiAgICB2YXIgcyA9IHN0YWNrQ2FwdHVyZSgnY2xvc2VCZWNhdXNlIGNhbGxlZDogJyArIHJlYXNvbik7XG4gICAgdGhpcy50b0Nsb3Npbmcocywgayk7XG4gIH1cblxuICBjbG9zZVdpdGhFcnJvciAocmVhc29uLCBjb2RlLCBlcnJvcikge1xuICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnJvcik7XG4gICAgdGhpcy5jbG9zZUJlY2F1c2UocmVhc29uLCBjb2RlKTtcbiAgfVxuXG4gIG9uU29ja2V0RXJyb3IgKGVycikge1xuICAgIGlmICghdGhpcy5leHBlY3RTb2NrZXRDbG9zZSkge1xuICAgICAgLy8gZm9yZXN0YWxsIGFueSBtb3JlIGNhbGxzIHRvIG9uU29ja2V0RXJyb3IsIHNpbmNlIHdlJ3JlIHNpZ25lZFxuICAgICAgLy8gdXAgZm9yIGAnZXJyb3InYCAqYW5kKiBgJ2VuZCdgXG4gICAgICB0aGlzLmV4cGVjdFNvY2tldENsb3NlID0gdHJ1ZTtcbiAgICAgIHRoaXMuZW1pdCgnZXJyb3InLCBlcnIpO1xuICAgICAgdmFyIHMgPSBzdGFja0NhcHR1cmUoJ1NvY2tldCBlcnJvcicpO1xuICAgICAgdGhpcy50b0Nsb3NlZChzLCBlcnIpO1xuICAgIH1cbiAgfVxuXG4gIC8vIEEgY2xvc2UgaGFzIGJlZW4gaW5pdGlhdGVkLiBSZXBlYXQ6IGEgY2xvc2UgaGFzIGJlZW4gaW5pdGlhdGVkLlxuICAvLyBUaGlzIG1lYW5zIHdlIHNob3VsZCBub3Qgc2VuZCBtb3JlIGZyYW1lcywgYW55d2F5IHRoZXkgd2lsbCBiZVxuICAvLyBpZ25vcmVkLiBXZSBhbHNvIGhhdmUgdG8gc2h1dCBkb3duIGFsbCB0aGUgY2hhbm5lbHMuXG4gIHRvQ2xvc2luZyAoY2FwdHVyZWRTdGFjaywgaykge1xuICAgIHZhciBzZW5kID0gdGhpcy5zZW5kTWV0aG9kLmJpbmQodGhpcyk7XG5cbiAgICB0aGlzLmFjY2VwdCA9IGZ1bmN0aW9uIChmKSB7XG4gICAgICBpZiAoZi5pZCA9PT0gZGVmcy5Db25uZWN0aW9uQ2xvc2VPaykge1xuICAgICAgICBpZiAoaylcbiAgICAgICAgICBrKCk7XG4gICAgICAgIHZhciBzID0gc3RhY2tDYXB0dXJlKCdDb25uZWN0aW9uQ2xvc2VPayByZWNlaXZlZCcpO1xuICAgICAgICB0aGlzLnRvQ2xvc2VkKHMsIHVuZGVmaW5lZCk7XG4gICAgICB9XG4gICAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25DbG9zZSkge1xuICAgICAgICBzZW5kKDAsIGRlZnMuQ29ubmVjdGlvbkNsb3NlT2ssIHt9KTtcbiAgICAgIH1cbiAgICAgIC8vIGVsc2UgaWdub3JlIGZyYW1lXG4gICAgfTtcbiAgICBpbnZhbGlkYXRlU2VuZCh0aGlzLCAnQ29ubmVjdGlvbiBjbG9zaW5nJywgY2FwdHVyZWRTdGFjayk7XG4gIH1cblxuICBfY2xvc2VDaGFubmVscyAoY2FwdHVyZWRTdGFjaykge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgdGhpcy5jaGFubmVscy5sZW5ndGg7IGkrKykge1xuICAgICAgdmFyIGNoID0gdGhpcy5jaGFubmVsc1tpXTtcbiAgICAgIGlmIChjaCAhPT0gbnVsbCkge1xuICAgICAgICBjaC5jaGFubmVsLnRvQ2xvc2VkKGNhcHR1cmVkU3RhY2spOyAvLyAlJSUgb3Igd2l0aCBhbiBlcnJvcj8gbm90IGNsZWFyXG4gICAgICB9XG4gICAgfVxuICB9XG5cbiAgLy8gQSBjbG9zZSBoYXMgYmVlbiBjb25maXJtZWQuIENlYXNlIGFsbCBjb21tdW5pY2F0aW9uLlxuICB0b0Nsb3NlZCAoY2FwdHVyZWRTdGFjaywgbWF5YmVFcnIpIHtcbiAgICB0aGlzLl9jbG9zZUNoYW5uZWxzKGNhcHR1cmVkU3RhY2spO1xuICAgIHZhciBpbmZvID0gZm10KCdDb25uZWN0aW9uIGNsb3NlZCAoJXMpJyxcbiAgICAgIChtYXliZUVycikgPyBtYXliZUVyci50b1N0cmluZygpIDogJ2J5IGNsaWVudCcpO1xuICAgIC8vIFRpZHkgdXAsIGludmFsaWRhdGUgZW52ZXJ5dGhpbmcsIGR5bmFtaXRlIHRoZSBicmlkZ2VzLlxuICAgIGludmFsaWRhdGVTZW5kKHRoaXMsIGluZm8sIGNhcHR1cmVkU3RhY2spO1xuICAgIHRoaXMuYWNjZXB0ID0gaW52YWxpZE9wKGluZm8sIGNhcHR1cmVkU3RhY2spO1xuICAgIHRoaXMuY2xvc2UgPSBmdW5jdGlvbiAoY2IpIHtcbiAgICAgIGNiICYmIGNiKG5ldyBJbGxlZ2FsT3BlcmF0aW9uRXJyb3IoaW5mbywgY2FwdHVyZWRTdGFjaykpO1xuICAgIH07XG4gICAgaWYgKHRoaXMuaGVhcnRiZWF0ZXIpXG4gICAgICB0aGlzLmhlYXJ0YmVhdGVyLmNsZWFyKCk7XG4gICAgLy8gVGhpcyBpcyBjZXJ0YWlubHkgdHJ1ZSBub3csIGlmIGl0IHdhc24ndCBiZWZvcmVcbiAgICB0aGlzLmV4cGVjdFNvY2tldENsb3NlID0gdHJ1ZTtcbiAgICB0aGlzLnN0cmVhbS5lbmQoKTtcbiAgICB0aGlzLmVtaXQoJ2Nsb3NlJywgbWF5YmVFcnIpO1xuICB9XG5cbiAgX3VwZGF0ZVNlY3JldChuZXdTZWNyZXQsIHJlYXNvbiwgY2IpIHtcbiAgICB0aGlzLnNlbmRNZXRob2QoMCwgZGVmcy5Db25uZWN0aW9uVXBkYXRlU2VjcmV0LCB7XG4gICAgICBuZXdTZWNyZXQsXG4gICAgICByZWFzb25cbiAgICB9KTtcbiAgICB0aGlzLm9uY2UoJ3VwZGF0ZS1zZWNyZXQtb2snLCBjYik7XG4gIH1cblxuICAvLyA9PT1cbiAgc3RhcnRIZWFydGJlYXRlciAoKSB7XG4gICAgaWYgKHRoaXMuaGVhcnRiZWF0ID09PSAwKVxuICAgICAgcmV0dXJuIG51bGw7XG4gICAgZWxzZSB7XG4gICAgICB2YXIgc2VsZiA9IHRoaXM7XG4gICAgICB2YXIgaGIgPSBuZXcgSGVhcnQodGhpcy5oZWFydGJlYXQsXG4gICAgICAgIHRoaXMuY2hlY2tTZW5kLmJpbmQodGhpcyksXG4gICAgICAgIHRoaXMuY2hlY2tSZWN2LmJpbmQodGhpcykpO1xuICAgICAgaGIub24oJ3RpbWVvdXQnLCBmdW5jdGlvbiAoKSB7XG4gICAgICAgIHZhciBoYmVyciA9IG5ldyBFcnJvcihcIkhlYXJ0YmVhdCB0aW1lb3V0XCIpO1xuICAgICAgICBzZWxmLmVtaXQoJ2Vycm9yJywgaGJlcnIpO1xuICAgICAgICB2YXIgcyA9IHN0YWNrQ2FwdHVyZSgnSGVhcnRiZWF0IHRpbWVvdXQnKTtcbiAgICAgICAgc2VsZi50b0Nsb3NlZChzLCBoYmVycik7XG4gICAgICB9KTtcbiAgICAgIGhiLm9uKCdiZWF0JywgZnVuY3Rpb24gKCkge1xuICAgICAgICBzZWxmLnNlbmRIZWFydGJlYXQoKTtcbiAgICAgIH0pO1xuICAgICAgcmV0dXJuIGhiO1xuICAgIH1cbiAgfVxuXG4gIC8vIEkgdXNlIGFuIGFycmF5IHRvIGtlZXAgdHJhY2sgb2YgdGhlIGNoYW5uZWxzLCByYXRoZXIgdGhhbiBhblxuICAvLyBvYmplY3QuIFRoZSBjaGFubmVsIGlkZW50aWZpZXJzIGFyZSBudW1iZXJzLCBhbmQgYWxsb2NhdGVkIGJ5IHRoZVxuICAvLyBjb25uZWN0aW9uLiBJZiBJIHRyeSB0byBhbGxvY2F0ZSBsb3cgbnVtYmVycyB3aGVuIHRoZXkgYXJlXG4gIC8vIGF2YWlsYWJsZSAod2hpY2ggSSBkbywgYnkgbG9va2luZyBmcm9tIHRoZSBzdGFydCBvZiB0aGUgYml0c2V0KSxcbiAgLy8gdGhpcyBvdWdodCB0byBrZWVwIHRoZSBhcnJheSBzbWFsbCwgYW5kIG91dCBvZiAnc3BhcnNlIGFycmF5XG4gIC8vIHN0b3JhZ2UnLiBJIGFsc28gc2V0IGVudHJpZXMgdG8gbnVsbCwgcmF0aGVyIHRoYW4gZGVsZXRpbmcgdGhlbSwgaW5cbiAgLy8gdGhlIGV4cGVjdGF0aW9uIHRoYXQgdGhlIG5leHQgY2hhbm5lbCBhbGxvY2F0aW9uIHdpbGwgZmlsbCB0aGUgc2xvdFxuICAvLyBhZ2FpbiByYXRoZXIgdGhhbiBncm93aW5nIHRoZSBhcnJheS4gU2VlXG4gIC8vIGh0dHA6Ly93d3cuaHRtbDVyb2Nrcy5jb20vZW4vdHV0b3JpYWxzL3NwZWVkL3Y4L1xuICBmcmVzaENoYW5uZWwgKGNoYW5uZWwsIG9wdGlvbnMpIHtcbiAgICB2YXIgbmV4dCA9IHRoaXMuZnJlZUNoYW5uZWxzLm5leHRDbGVhckJpdCgxKTtcbiAgICBpZiAobmV4dCA8IDAgfHwgbmV4dCA+IHRoaXMuY2hhbm5lbE1heClcbiAgICAgIHRocm93IG5ldyBFcnJvcihcIk5vIGNoYW5uZWxzIGxlZnQgdG8gYWxsb2NhdGVcIik7XG4gICAgdGhpcy5mcmVlQ2hhbm5lbHMuc2V0KG5leHQpO1xuXG4gICAgdmFyIGh3bSA9IChvcHRpb25zICYmIG9wdGlvbnMuaGlnaFdhdGVyTWFyaykgfHwgREVGQVVMVF9XUklURV9IV007XG4gICAgdmFyIHdyaXRlQnVmZmVyID0gbmV3IFBhc3NUaHJvdWdoKHtcbiAgICAgIG9iamVjdE1vZGU6IHRydWUsIGhpZ2hXYXRlck1hcms6IGh3bVxuICAgIH0pO1xuICAgIHRoaXMuY2hhbm5lbHNbbmV4dF0gPSB7IGNoYW5uZWw6IGNoYW5uZWwsIGJ1ZmZlcjogd3JpdGVCdWZmZXIgfTtcbiAgICB3cml0ZUJ1ZmZlci5vbignZHJhaW4nLCBmdW5jdGlvbiAoKSB7XG4gICAgICBjaGFubmVsLm9uQnVmZmVyRHJhaW4oKTtcbiAgICB9KTtcbiAgICB0aGlzLm11eGVyLnBpcGVGcm9tKHdyaXRlQnVmZmVyKTtcbiAgICByZXR1cm4gbmV4dDtcbiAgfVxuXG4gIHJlbGVhc2VDaGFubmVsIChjaGFubmVsKSB7XG4gICAgdGhpcy5mcmVlQ2hhbm5lbHMuY2xlYXIoY2hhbm5lbCk7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uYnVmZmVyO1xuICAgIGJ1ZmZlci5lbmQoKTsgLy8gd2lsbCBhbHNvIGNhdXNlIGl0IHRvIGJlIHVucGlwZWRcbiAgICB0aGlzLmNoYW5uZWxzW2NoYW5uZWxdID0gbnVsbDtcbiAgfVxuXG4gIGFjY2VwdExvb3AgKCkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGdvICgpIHtcbiAgICAgIHRyeSB7XG4gICAgICAgIHZhciBmOyB3aGlsZSAoZiA9IHNlbGYucmVjdkZyYW1lKCkpXG4gICAgICAgICAgc2VsZi5hY2NlcHQoZik7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBzZWxmLmVtaXQoJ2ZyYW1lRXJyb3InLCBlKTtcbiAgICAgIH1cbiAgICB9XG4gICAgc2VsZi5zdHJlYW0ub24oJ3JlYWRhYmxlJywgZ28pO1xuICAgIGdvKCk7XG4gIH1cblxuICBzdGVwIChjYikge1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBmdW5jdGlvbiByZWN2ICgpIHtcbiAgICAgIHZhciBmO1xuICAgICAgdHJ5IHtcbiAgICAgICAgZiA9IHNlbGYucmVjdkZyYW1lKCk7XG4gICAgICB9XG4gICAgICBjYXRjaCAoZSkge1xuICAgICAgICBjYihlLCBudWxsKTtcbiAgICAgICAgcmV0dXJuO1xuICAgICAgfVxuICAgICAgaWYgKGYpXG4gICAgICAgIGNiKG51bGwsIGYpO1xuICAgICAgZWxzZVxuICAgICAgICBzZWxmLnN0cmVhbS5vbmNlKCdyZWFkYWJsZScsIHJlY3YpO1xuICAgIH1cbiAgICByZWN2KCk7XG4gIH1cblxuICBjaGVja1NlbmQgKCkge1xuICAgIHZhciBjaGVjayA9IHRoaXMuc2VudFNpbmNlTGFzdENoZWNrO1xuICAgIHRoaXMuc2VudFNpbmNlTGFzdENoZWNrID0gZmFsc2U7XG4gICAgcmV0dXJuIGNoZWNrO1xuICB9XG5cbiAgY2hlY2tSZWN2ICgpIHtcbiAgICB2YXIgY2hlY2sgPSB0aGlzLnJlY3ZTaW5jZUxhc3RDaGVjaztcbiAgICB0aGlzLnJlY3ZTaW5jZUxhc3RDaGVjayA9IGZhbHNlO1xuICAgIHJldHVybiBjaGVjaztcbiAgfVxuXG4gIHNlbmRCeXRlcyAoYnl0ZXMpIHtcbiAgICB0aGlzLnNlbnRTaW5jZUxhc3RDaGVjayA9IHRydWU7XG4gICAgdGhpcy5zdHJlYW0ud3JpdGUoYnl0ZXMpO1xuICB9XG5cbiAgc2VuZEhlYXJ0YmVhdCAoKSB7XG4gICAgcmV0dXJuIHRoaXMuc2VuZEJ5dGVzKGZyYW1lLkhFQVJUQkVBVF9CVUYpO1xuICB9XG5cbiAgc2VuZE1ldGhvZCAoY2hhbm5lbCwgTWV0aG9kLCBmaWVsZHMpIHtcbiAgICB2YXIgZnJhbWUgPSBlbmNvZGVNZXRob2QoTWV0aG9kLCBjaGFubmVsLCBmaWVsZHMpO1xuICAgIHRoaXMuc2VudFNpbmNlTGFzdENoZWNrID0gdHJ1ZTtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5jaGFubmVsc1tjaGFubmVsXS5idWZmZXI7XG4gICAgcmV0dXJuIGJ1ZmZlci53cml0ZShmcmFtZSk7XG4gIH1cblxuICBzZW5kTWVzc2FnZSAoY2hhbm5lbCwgTWV0aG9kLCBmaWVsZHMsIFByb3BlcnRpZXMsIHByb3BzLCBjb250ZW50KSB7XG4gICAgaWYgKCFCdWZmZXIuaXNCdWZmZXIoY29udGVudCkpXG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKCdjb250ZW50IGlzIG5vdCBhIGJ1ZmZlcicpO1xuXG4gICAgdmFyIG1mcmFtZSA9IGVuY29kZU1ldGhvZChNZXRob2QsIGNoYW5uZWwsIGZpZWxkcyk7XG4gICAgdmFyIHBmcmFtZSA9IGVuY29kZVByb3BlcnRpZXMoUHJvcGVydGllcywgY2hhbm5lbCxcbiAgICAgIGNvbnRlbnQubGVuZ3RoLCBwcm9wcyk7XG4gICAgdmFyIGJ1ZmZlciA9IHRoaXMuY2hhbm5lbHNbY2hhbm5lbF0uYnVmZmVyO1xuICAgIHRoaXMuc2VudFNpbmNlTGFzdENoZWNrID0gdHJ1ZTtcblxuICAgIHZhciBtZXRob2RIZWFkZXJMZW4gPSBtZnJhbWUubGVuZ3RoICsgcGZyYW1lLmxlbmd0aDtcbiAgICB2YXIgYm9keUxlbiA9IChjb250ZW50Lmxlbmd0aCA+IDApID9cbiAgICAgIGNvbnRlbnQubGVuZ3RoICsgRlJBTUVfT1ZFUkhFQUQgOiAwO1xuICAgIHZhciBhbGxMZW4gPSBtZXRob2RIZWFkZXJMZW4gKyBib2R5TGVuO1xuXG4gICAgaWYgKGFsbExlbiA8IFNJTkdMRV9DSFVOS19USFJFU0hPTEQpIHtcbiAgICAgIC8vIFVzZSBgYWxsb2NVbnNhZmVgIHRvIGF2b2lkIGV4Y2Vzc2l2ZSBhbGxvY2F0aW9ucyBhbmQgQ1BVIHVzYWdlXG4gICAgICAvLyBmcm9tIHplcm9pbmcuIFRoZSByZXR1cm5lZCBCdWZmZXIgaXMgbm90IHplcm9lZCBhbmQgc28gbXVzdCBiZVxuICAgICAgLy8gY29tcGxldGVseSBmaWxsZWQgdG8gYmUgdXNlZCBzYWZlbHkuXG4gICAgICAvLyBTZWUgaHR0cHM6Ly9naXRodWIuY29tL2FtcXAtbm9kZS9hbXFwbGliL3B1bGwvNjk1XG4gICAgICB2YXIgYWxsID0gQnVmZmVyLmFsbG9jVW5zYWZlKGFsbExlbik7XG4gICAgICB2YXIgb2Zmc2V0ID0gbWZyYW1lLmNvcHkoYWxsLCAwKTtcbiAgICAgIG9mZnNldCArPSBwZnJhbWUuY29weShhbGwsIG9mZnNldCk7XG5cbiAgICAgIGlmIChib2R5TGVuID4gMClcbiAgICAgICAgbWFrZUJvZHlGcmFtZShjaGFubmVsLCBjb250ZW50KS5jb3B5KGFsbCwgb2Zmc2V0KTtcbiAgICAgIHJldHVybiBidWZmZXIud3JpdGUoYWxsKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBpZiAobWV0aG9kSGVhZGVyTGVuIDwgU0lOR0xFX0NIVU5LX1RIUkVTSE9MRCkge1xuICAgICAgICAvLyBVc2UgYGFsbG9jVW5zYWZlYCB0byBhdm9pZCBleGNlc3NpdmUgYWxsb2NhdGlvbnMgYW5kIENQVSB1c2FnZVxuICAgICAgICAvLyBmcm9tIHplcm9pbmcuIFRoZSByZXR1cm5lZCBCdWZmZXIgaXMgbm90IHplcm9lZCBhbmQgc28gbXVzdCBiZVxuICAgICAgICAvLyBjb21wbGV0ZWx5IGZpbGxlZCB0byBiZSB1c2VkIHNhZmVseS5cbiAgICAgICAgLy8gU2VlIGh0dHBzOi8vZ2l0aHViLmNvbS9hbXFwLW5vZGUvYW1xcGxpYi9wdWxsLzY5NVxuICAgICAgICB2YXIgYm90aCA9IEJ1ZmZlci5hbGxvY1Vuc2FmZShtZXRob2RIZWFkZXJMZW4pO1xuICAgICAgICB2YXIgb2Zmc2V0ID0gbWZyYW1lLmNvcHkoYm90aCwgMCk7XG4gICAgICAgIHBmcmFtZS5jb3B5KGJvdGgsIG9mZnNldCk7XG4gICAgICAgIGJ1ZmZlci53cml0ZShib3RoKTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICBidWZmZXIud3JpdGUobWZyYW1lKTtcbiAgICAgICAgYnVmZmVyLndyaXRlKHBmcmFtZSk7XG4gICAgICB9XG4gICAgICByZXR1cm4gdGhpcy5zZW5kQ29udGVudChjaGFubmVsLCBjb250ZW50KTtcbiAgICB9XG4gIH1cblxuICBzZW5kQ29udGVudCAoY2hhbm5lbCwgYm9keSkge1xuICAgIGlmICghQnVmZmVyLmlzQnVmZmVyKGJvZHkpKSB7XG4gICAgICB0aHJvdyBuZXcgVHlwZUVycm9yKGZtdChcIkV4cGVjdGVkIGJ1ZmZlcjsgZ290ICVzXCIsIGJvZHkpKTtcbiAgICB9XG4gICAgdmFyIHdyaXRlUmVzdWx0ID0gdHJ1ZTtcbiAgICB2YXIgYnVmZmVyID0gdGhpcy5jaGFubmVsc1tjaGFubmVsXS5idWZmZXI7XG5cbiAgICB2YXIgbWF4Qm9keSA9IHRoaXMuZnJhbWVNYXggLSBGUkFNRV9PVkVSSEVBRDtcblxuICAgIGZvciAodmFyIG9mZnNldCA9IDA7IG9mZnNldCA8IGJvZHkubGVuZ3RoOyBvZmZzZXQgKz0gbWF4Qm9keSkge1xuICAgICAgdmFyIGVuZCA9IG9mZnNldCArIG1heEJvZHk7XG4gICAgICB2YXIgc2xpY2UgPSAoZW5kID4gYm9keS5sZW5ndGgpID8gYm9keS5zdWJhcnJheShvZmZzZXQpIDogYm9keS5zdWJhcnJheShvZmZzZXQsIGVuZCk7XG4gICAgICB2YXIgYm9keUZyYW1lID0gbWFrZUJvZHlGcmFtZShjaGFubmVsLCBzbGljZSk7XG4gICAgICB3cml0ZVJlc3VsdCA9IGJ1ZmZlci53cml0ZShib2R5RnJhbWUpO1xuICAgIH1cbiAgICB0aGlzLnNlbnRTaW5jZUxhc3RDaGVjayA9IHRydWU7XG4gICAgcmV0dXJuIHdyaXRlUmVzdWx0O1xuICB9XG5cbiAgcmVjdkZyYW1lICgpIHtcbiAgICAvLyAlJSUgaWRlbnRpZnlpbmcgaW52YXJpYW50cyBtaWdodCBoZWxwIGhlcmU/XG4gICAgdmFyIGZyYW1lID0gcGFyc2VGcmFtZSh0aGlzLnJlc3QsIHRoaXMuZnJhbWVNYXgpO1xuXG4gICAgaWYgKCFmcmFtZSkge1xuICAgICAgdmFyIGluY29taW5nID0gdGhpcy5zdHJlYW0ucmVhZCgpO1xuICAgICAgaWYgKGluY29taW5nID09PSBudWxsKSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICAgIGVsc2Uge1xuICAgICAgICB0aGlzLnJlY3ZTaW5jZUxhc3RDaGVjayA9IHRydWU7XG4gICAgICAgIHRoaXMucmVzdCA9IEJ1ZmZlci5jb25jYXQoW3RoaXMucmVzdCwgaW5jb21pbmddKTtcbiAgICAgICAgcmV0dXJuIHRoaXMucmVjdkZyYW1lKCk7XG4gICAgICB9XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhpcy5yZXN0ID0gZnJhbWUucmVzdDtcbiAgICAgIHJldHVybiBkZWNvZGVGcmFtZShmcmFtZSk7XG4gICAgfVxuICB9XG59XG5cbi8vIFVzdWFsIGZyYW1lIGFjY2VwdCBtb2RlXG5mdW5jdGlvbiBtYWluQWNjZXB0KGZyYW1lKSB7XG4gIHZhciByZWMgPSB0aGlzLmNoYW5uZWxzW2ZyYW1lLmNoYW5uZWxdO1xuICBpZiAocmVjKSB7IHJldHVybiByZWMuY2hhbm5lbC5hY2NlcHQoZnJhbWUpOyB9XG4gIC8vIE5CIENIQU5ORUxfRVJST1IgbWF5IG5vdCBiZSByaWdodCwgYnV0IEkgZG9uJ3Qga25vdyB3aGF0IGlzIC4uXG4gIGVsc2VcbiAgICB0aGlzLmNsb3NlV2l0aEVycm9yKFxuICAgICAgZm10KCdGcmFtZSBvbiB1bmtub3duIGNoYW5uZWwgJWQnLCBmcmFtZS5jaGFubmVsKSxcbiAgICAgIGNvbnN0YW50cy5DSEFOTkVMX0VSUk9SLFxuICAgICAgbmV3IEVycm9yKGZtdChcIkZyYW1lIG9uIHVua25vd24gY2hhbm5lbDogJXNcIixcbiAgICAgICAgICAgICAgICAgICAgaW5zcGVjdChmcmFtZSwgZmFsc2UpKSkpO1xufVxuXG4vLyBIYW5kbGUgYW55dGhpbmcgdGhhdCBjb21lcyB0aHJvdWdoIG9uIGNoYW5uZWwgMCwgdGhhdCdzIHRoZVxuLy8gY29ubmVjdGlvbiBjb250cm9sIGNoYW5uZWwuIFRoaXMgaXMgb25seSB1c2VkIG9uY2UgbWFpbkFjY2VwdCBpc1xuLy8gaW5zdGFsbGVkIGFzIHRoZSBmcmFtZSBoYW5kbGVyLCBhZnRlciB0aGUgb3BlbmluZyBoYW5kc2hha2UuXG5mdW5jdGlvbiBjaGFubmVsMChjb25uZWN0aW9uKSB7XG4gIHJldHVybiBmdW5jdGlvbihmKSB7XG4gICAgLy8gT25jZSB3ZSBnZXQgYSAnY2xvc2UnLCB3ZSBrbm93IDEuIHdlJ2xsIGdldCBubyBtb3JlIGZyYW1lcywgYW5kXG4gICAgLy8gMi4gYW55dGhpbmcgd2Ugc2VuZCBleGNlcHQgY2xvc2UsIG9yIGNsb3NlLW9rLCB3aWxsIGJlXG4gICAgLy8gaWdub3JlZC4gSWYgd2UgYWxyZWFkeSBzZW50ICdjbG9zZScsIHRoaXMgd29uJ3QgYmUgaW52b2tlZCBzaW5jZVxuICAgIC8vIHdlJ3JlIGFscmVhZHkgaW4gY2xvc2luZyBtb2RlOyBpZiB3ZSBkaWRuJ3Qgd2VsbCB3ZSdyZSBub3QgZ29pbmdcbiAgICAvLyB0byBzZW5kIGl0IG5vdyBhcmUgd2UuXG4gICAgaWYgKGYgPT09IEhFQVJUQkVBVCk7IC8vIGlnbm9yZTsgaXQncyBhbHJlYWR5IGNvdW50ZWQgYXMgYWN0aXZpdHlcbiAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gb24gdGhlIHNvY2tldCwgd2hpY2ggaXMgaXRzIHB1cnBvc2VcbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25DbG9zZSkge1xuICAgICAgLy8gT2guIE9LLiBJIGd1ZXNzIHdlJ3JlIGRvbmUgaGVyZSB0aGVuLlxuICAgICAgY29ubmVjdGlvbi5zZW5kTWV0aG9kKDAsIGRlZnMuQ29ubmVjdGlvbkNsb3NlT2ssIHt9KTtcbiAgICAgIHZhciBlbXNnID0gZm10KCdDb25uZWN0aW9uIGNsb3NlZDogJXMnLCBjbG9zZU1zZyhmKSk7XG4gICAgICB2YXIgcyA9IHN0YWNrQ2FwdHVyZShlbXNnKTtcbiAgICAgIHZhciBlID0gbmV3IEVycm9yKGVtc2cpO1xuICAgICAgZS5jb2RlID0gZi5maWVsZHMucmVwbHlDb2RlO1xuICAgICAgaWYgKGlzRmF0YWxFcnJvcihlKSkge1xuICAgICAgICBjb25uZWN0aW9uLmVtaXQoJ2Vycm9yJywgZSk7XG4gICAgICB9XG4gICAgICBjb25uZWN0aW9uLnRvQ2xvc2VkKHMsIGUpO1xuICAgIH1cbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25CbG9ja2VkKSB7XG4gICAgICBjb25uZWN0aW9uLmVtaXQoJ2Jsb2NrZWQnLCBmLmZpZWxkcy5yZWFzb24pO1xuICAgIH1cbiAgICBlbHNlIGlmIChmLmlkID09PSBkZWZzLkNvbm5lY3Rpb25VbmJsb2NrZWQpIHtcbiAgICAgIGNvbm5lY3Rpb24uZW1pdCgndW5ibG9ja2VkJyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKGYuaWQgPT09IGRlZnMuQ29ubmVjdGlvblVwZGF0ZVNlY3JldE9rKSB7XG4gICAgICBjb25uZWN0aW9uLmVtaXQoJ3VwZGF0ZS1zZWNyZXQtb2snKTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBjb25uZWN0aW9uLmNsb3NlV2l0aEVycm9yKFxuICAgICAgICBmbXQoXCJVbmV4cGVjdGVkIGZyYW1lIG9uIGNoYW5uZWwgMFwiKSxcbiAgICAgICAgY29uc3RhbnRzLlVORVhQRUNURURfRlJBTUUsXG4gICAgICAgIG5ldyBFcnJvcihmbXQoXCJVbmV4cGVjdGVkIGZyYW1lIG9uIGNoYW5uZWwgMDogJXNcIixcbiAgICAgICAgICAgICAgICAgICAgICBpbnNwZWN0KGYsIGZhbHNlKSkpKTtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIGludmFsaWRPcChtc2csIHN0YWNrKSB7XG4gIHJldHVybiBmdW5jdGlvbigpIHtcbiAgICB0aHJvdyBuZXcgSWxsZWdhbE9wZXJhdGlvbkVycm9yKG1zZywgc3RhY2spO1xuICB9O1xufVxuXG5mdW5jdGlvbiBpbnZhbGlkYXRlU2VuZChjb25uLCBtc2csIHN0YWNrKSB7XG4gIGNvbm4uc2VuZE1ldGhvZCA9IGNvbm4uc2VuZENvbnRlbnQgPSBjb25uLnNlbmRNZXNzYWdlID1cbiAgICBpbnZhbGlkT3AobXNnLCBzdGFjayk7XG59XG5cbnZhciBlbmNvZGVNZXRob2QgPSBkZWZzLmVuY29kZU1ldGhvZDtcbnZhciBlbmNvZGVQcm9wZXJ0aWVzID0gZGVmcy5lbmNvZGVQcm9wZXJ0aWVzO1xuXG52YXIgRlJBTUVfT1ZFUkhFQUQgPSBkZWZzLkZSQU1FX09WRVJIRUFEO1xudmFyIG1ha2VCb2R5RnJhbWUgPSBmcmFtZS5tYWtlQm9keUZyYW1lO1xuXG52YXIgcGFyc2VGcmFtZSA9IGZyYW1lLnBhcnNlRnJhbWU7XG52YXIgZGVjb2RlRnJhbWUgPSBmcmFtZS5kZWNvZGVGcmFtZTtcblxuZnVuY3Rpb24gd3JhcFN0cmVhbShzKSB7XG4gIGlmIChzIGluc3RhbmNlb2YgRHVwbGV4KSByZXR1cm4gcztcbiAgZWxzZSB7XG4gICAgdmFyIHdzID0gbmV3IER1cGxleCgpO1xuICAgIHdzLndyYXAocyk7IC8vd3JhcHMgdGhlIHJlYWRhYmxlIHNpZGUgb2YgdGhpbmdzXG4gICAgd3MuX3dyaXRlID0gZnVuY3Rpb24oY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjaykge1xuICAgICAgcmV0dXJuIHMud3JpdGUoY2h1bmssIGVuY29kaW5nLCBjYWxsYmFjayk7XG4gICAgfTtcbiAgICByZXR1cm4gd3M7XG4gIH1cbn1cblxuZnVuY3Rpb24gaXNGYXRhbEVycm9yKGVycm9yKSB7XG4gIHN3aXRjaCAoZXJyb3IgJiYgZXJyb3IuY29kZSkge1xuICBjYXNlIGRlZnMuY29uc3RhbnRzLkNPTk5FQ1RJT05fRk9SQ0VEOlxuICBjYXNlIGRlZnMuY29uc3RhbnRzLlJFUExZX1NVQ0NFU1M6XG4gICAgcmV0dXJuIGZhbHNlO1xuICBkZWZhdWx0OlxuICAgIHJldHVybiB0cnVlO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb24gPSBDb25uZWN0aW9uO1xubW9kdWxlLmV4cG9ydHMuaXNGYXRhbEVycm9yID0gaXNGYXRhbEVycm9yO1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/connection.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/credentials.js":
/*!*************************************************!*\
  !*** ./node_modules/amqplib/lib/credentials.js ***!
  \*************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("//\n//\n//\n\n// Different kind of credentials that can be supplied when opening a\n// connection, corresponding to SASL mechanisms There's only two\n// useful mechanisms that RabbitMQ implements:\n//  * PLAIN (send username and password in the plain)\n//  * EXTERNAL (assume the server will figure out who you are from\n//    context, i.e., your SSL certificate)\nvar codec = __webpack_require__(/*! ./codec */ \"(rsc)/./node_modules/amqplib/lib/codec.js\")\n\nmodule.exports.plain = function(user, passwd) {\n  return {\n    mechanism: 'PLAIN',\n    response: function() {\n      return Buffer.from(['', user, passwd].join(String.fromCharCode(0)))\n    },\n    username: user,\n    password: passwd\n  }\n}\n\nmodule.exports.amqplain = function(user, passwd) {\n  return {\n    mechanism: 'AMQPLAIN',\n    response: function() {\n      const buffer = Buffer.alloc(16384);\n      const size = codec.encodeTable(buffer, { LOGIN: user, PASSWORD: passwd}, 0);\n      return buffer.subarray(4, size);\n    },\n    username: user,\n    password: passwd\n  }\n}\n\nmodule.exports.external = function() {\n  return {\n    mechanism: 'EXTERNAL',\n    response: function() { return Buffer.from(''); }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY3JlZGVudGlhbHMuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksbUJBQU8sQ0FBQywwREFBUzs7QUFFN0Isb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1QjtBQUN2QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtDQUErQyw4QkFBOEI7QUFDN0U7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCO0FBQ0E7QUFDQSwyQkFBMkI7QUFDM0I7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjIvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvY3JlZGVudGlhbHMuanM/ZmJmYiJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG5cbi8vIERpZmZlcmVudCBraW5kIG9mIGNyZWRlbnRpYWxzIHRoYXQgY2FuIGJlIHN1cHBsaWVkIHdoZW4gb3BlbmluZyBhXG4vLyBjb25uZWN0aW9uLCBjb3JyZXNwb25kaW5nIHRvIFNBU0wgbWVjaGFuaXNtcyBUaGVyZSdzIG9ubHkgdHdvXG4vLyB1c2VmdWwgbWVjaGFuaXNtcyB0aGF0IFJhYmJpdE1RIGltcGxlbWVudHM6XG4vLyAgKiBQTEFJTiAoc2VuZCB1c2VybmFtZSBhbmQgcGFzc3dvcmQgaW4gdGhlIHBsYWluKVxuLy8gICogRVhURVJOQUwgKGFzc3VtZSB0aGUgc2VydmVyIHdpbGwgZmlndXJlIG91dCB3aG8geW91IGFyZSBmcm9tXG4vLyAgICBjb250ZXh0LCBpLmUuLCB5b3VyIFNTTCBjZXJ0aWZpY2F0ZSlcbnZhciBjb2RlYyA9IHJlcXVpcmUoJy4vY29kZWMnKVxuXG5tb2R1bGUuZXhwb3J0cy5wbGFpbiA9IGZ1bmN0aW9uKHVzZXIsIHBhc3N3ZCkge1xuICByZXR1cm4ge1xuICAgIG1lY2hhbmlzbTogJ1BMQUlOJyxcbiAgICByZXNwb25zZTogZnVuY3Rpb24oKSB7XG4gICAgICByZXR1cm4gQnVmZmVyLmZyb20oWycnLCB1c2VyLCBwYXNzd2RdLmpvaW4oU3RyaW5nLmZyb21DaGFyQ29kZSgwKSkpXG4gICAgfSxcbiAgICB1c2VybmFtZTogdXNlcixcbiAgICBwYXNzd29yZDogcGFzc3dkXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuYW1xcGxhaW4gPSBmdW5jdGlvbih1c2VyLCBwYXNzd2QpIHtcbiAgcmV0dXJuIHtcbiAgICBtZWNoYW5pc206ICdBTVFQTEFJTicsXG4gICAgcmVzcG9uc2U6IGZ1bmN0aW9uKCkge1xuICAgICAgY29uc3QgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2Mzg0KTtcbiAgICAgIGNvbnN0IHNpemUgPSBjb2RlYy5lbmNvZGVUYWJsZShidWZmZXIsIHsgTE9HSU46IHVzZXIsIFBBU1NXT1JEOiBwYXNzd2R9LCAwKTtcbiAgICAgIHJldHVybiBidWZmZXIuc3ViYXJyYXkoNCwgc2l6ZSk7XG4gICAgfSxcbiAgICB1c2VybmFtZTogdXNlcixcbiAgICBwYXNzd29yZDogcGFzc3dkXG4gIH1cbn1cblxubW9kdWxlLmV4cG9ydHMuZXh0ZXJuYWwgPSBmdW5jdGlvbigpIHtcbiAgcmV0dXJuIHtcbiAgICBtZWNoYW5pc206ICdFWFRFUk5BTCcsXG4gICAgcmVzcG9uc2U6IGZ1bmN0aW9uKCkgeyByZXR1cm4gQnVmZmVyLmZyb20oJycpOyB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/credentials.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/defs.js":
/*!******************************************!*\
  !*** ./node_modules/amqplib/lib/defs.js ***!
  \******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("/** @preserve This file is generated by the script\n * ../bin/generate-defs.js, which is not in general included in a\n * distribution, but is available in the source repository e.g. at\n * https://github.com/squaremo/amqp.node/\n */\n\n\nfunction decodeBasicQos(buffer) {\n  var val, offset = 0, fields = {\n    prefetchSize: void 0,\n    prefetchCount: void 0,\n    global: void 0\n  };\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.prefetchSize = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.prefetchCount = val;\n  val = !!(1 & buffer[offset]);\n  fields.global = val;\n  return fields;\n}\n\nfunction encodeBasicQos(channel, fields) {\n  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(19);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932170, 7);\n  offset = 11;\n  val = fields.prefetchSize;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'prefetchSize' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  val = fields.prefetchCount;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'prefetchCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.global;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicQosOk(buffer) {\n  return {};\n}\n\nfunction encodeBasicQosOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932171, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicConsume(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    consumerTag: void 0,\n    noLocal: void 0,\n    noAck: void 0,\n    exclusive: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.consumerTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.noLocal = val;\n  val = !!(2 & buffer[offset]);\n  fields.noAck = val;\n  val = !!(4 & buffer[offset]);\n  fields.exclusive = val;\n  val = !!(8 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.subarray(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeBasicConsume(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  val = fields.consumerTag;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)\");\n  var consumerTag_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += consumerTag_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(17 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932180, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.consumerTag;\n  void 0 === val && (val = \"\");\n  buffer[offset] = consumerTag_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += consumerTag_len;\n  val = fields.noLocal;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.noAck;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  val = fields.exclusive;\n  void 0 === val && (val = !1);\n  val && (bits += 4);\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 8);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicConsumeOk(buffer) {\n  var val, len, offset = 0, fields = {\n    consumerTag: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.consumerTag = val;\n  return fields;\n}\n\nfunction encodeBasicConsumeOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.consumerTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'consumerTag'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)\");\n  var consumerTag_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += consumerTag_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932181, 7);\n  offset = 11;\n  val = fields.consumerTag;\n  void 0 === val && (val = void 0);\n  buffer[offset] = consumerTag_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += consumerTag_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicCancel(buffer) {\n  var val, len, offset = 0, fields = {\n    consumerTag: void 0,\n    nowait: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.consumerTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.nowait = val;\n  return fields;\n}\n\nfunction encodeBasicCancel(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.consumerTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'consumerTag'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)\");\n  var consumerTag_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += consumerTag_len;\n  var buffer = Buffer.alloc(14 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932190, 7);\n  offset = 11;\n  val = fields.consumerTag;\n  void 0 === val && (val = void 0);\n  buffer[offset] = consumerTag_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += consumerTag_len;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicCancelOk(buffer) {\n  var val, len, offset = 0, fields = {\n    consumerTag: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.consumerTag = val;\n  return fields;\n}\n\nfunction encodeBasicCancelOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.consumerTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'consumerTag'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)\");\n  var consumerTag_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += consumerTag_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932191, 7);\n  offset = 11;\n  val = fields.consumerTag;\n  void 0 === val && (val = void 0);\n  buffer[offset] = consumerTag_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += consumerTag_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicPublish(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    exchange: void 0,\n    routingKey: void 0,\n    mandatory: void 0,\n    immediate: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  val = !!(1 & buffer[offset]);\n  fields.mandatory = val;\n  val = !!(2 & buffer[offset]);\n  fields.immediate = val;\n  return fields;\n}\n\nfunction encodeBasicPublish(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.exchange;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  var buffer = Buffer.alloc(17 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932200, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.exchange;\n  void 0 === val && (val = \"\");\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = \"\");\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  val = fields.mandatory;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.immediate;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicReturn(buffer) {\n  var val, len, offset = 0, fields = {\n    replyCode: void 0,\n    replyText: void 0,\n    exchange: void 0,\n    routingKey: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.replyCode = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.replyText = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  return fields;\n}\n\nfunction encodeBasicReturn(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.replyText;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'replyText' is the wrong type; must be a string (up to 255 chars)\");\n  var replyText_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += replyText_len;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'routingKey'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  var buffer = Buffer.alloc(17 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932210, 7);\n  offset = 11;\n  val = fields.replyCode;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'replyCode'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'replyCode' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.replyText;\n  void 0 === val && (val = \"\");\n  buffer[offset] = replyText_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += replyText_len;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = void 0);\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicDeliver(buffer) {\n  var val, len, offset = 0, fields = {\n    consumerTag: void 0,\n    deliveryTag: void 0,\n    redelivered: void 0,\n    exchange: void 0,\n    routingKey: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.consumerTag = val;\n  val = ints.readUInt64BE(buffer, offset);\n  offset += 8;\n  fields.deliveryTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.redelivered = val;\n  offset++;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  return fields;\n}\n\nfunction encodeBasicDeliver(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.consumerTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'consumerTag'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'consumerTag' is the wrong type; must be a string (up to 255 chars)\");\n  var consumerTag_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += consumerTag_len;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'routingKey'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  var buffer = Buffer.alloc(24 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932220, 7);\n  offset = 11;\n  val = fields.consumerTag;\n  void 0 === val && (val = void 0);\n  buffer[offset] = consumerTag_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += consumerTag_len;\n  val = fields.deliveryTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'deliveryTag'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryTag' is the wrong type; must be a number (but not NaN)\");\n  ints.writeUInt64BE(buffer, val, offset);\n  offset += 8;\n  val = fields.redelivered;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = void 0);\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicGet(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    noAck: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  val = !!(1 & buffer[offset]);\n  fields.noAck = val;\n  return fields;\n}\n\nfunction encodeBasicGet(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932230, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.noAck;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicGetOk(buffer) {\n  var val, len, offset = 0, fields = {\n    deliveryTag: void 0,\n    redelivered: void 0,\n    exchange: void 0,\n    routingKey: void 0,\n    messageCount: void 0\n  };\n  val = ints.readUInt64BE(buffer, offset);\n  offset += 8;\n  fields.deliveryTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.redelivered = val;\n  offset++;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.messageCount = val;\n  return fields;\n}\n\nfunction encodeBasicGetOk(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'routingKey'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  var buffer = Buffer.alloc(27 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932231, 7);\n  offset = 11;\n  val = fields.deliveryTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'deliveryTag'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryTag' is the wrong type; must be a number (but not NaN)\");\n  ints.writeUInt64BE(buffer, val, offset);\n  offset += 8;\n  val = fields.redelivered;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = void 0);\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  val = fields.messageCount;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'messageCount'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'messageCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicGetEmpty(buffer) {\n  var val, len, offset = 0, fields = {\n    clusterId: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.clusterId = val;\n  return fields;\n}\n\nfunction encodeBasicGetEmpty(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.clusterId;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'clusterId' is the wrong type; must be a string (up to 255 chars)\");\n  var clusterId_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += clusterId_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932232, 7);\n  offset = 11;\n  val = fields.clusterId;\n  void 0 === val && (val = \"\");\n  buffer[offset] = clusterId_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += clusterId_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicAck(buffer) {\n  var val, offset = 0, fields = {\n    deliveryTag: void 0,\n    multiple: void 0\n  };\n  val = ints.readUInt64BE(buffer, offset);\n  offset += 8;\n  fields.deliveryTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.multiple = val;\n  return fields;\n}\n\nfunction encodeBasicAck(channel, fields) {\n  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932240, 7);\n  offset = 11;\n  val = fields.deliveryTag;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryTag' is the wrong type; must be a number (but not NaN)\");\n  ints.writeUInt64BE(buffer, val, offset);\n  offset += 8;\n  val = fields.multiple;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicReject(buffer) {\n  var val, offset = 0, fields = {\n    deliveryTag: void 0,\n    requeue: void 0\n  };\n  val = ints.readUInt64BE(buffer, offset);\n  offset += 8;\n  fields.deliveryTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.requeue = val;\n  return fields;\n}\n\nfunction encodeBasicReject(channel, fields) {\n  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932250, 7);\n  offset = 11;\n  val = fields.deliveryTag;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'deliveryTag'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryTag' is the wrong type; must be a number (but not NaN)\");\n  ints.writeUInt64BE(buffer, val, offset);\n  offset += 8;\n  val = fields.requeue;\n  void 0 === val && (val = !0);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicRecoverAsync(buffer) {\n  var val, fields = {\n    requeue: void 0\n  };\n  val = !!(1 & buffer[0]);\n  fields.requeue = val;\n  return fields;\n}\n\nfunction encodeBasicRecoverAsync(channel, fields) {\n  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932260, 7);\n  offset = 11;\n  val = fields.requeue;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicRecover(buffer) {\n  var val, fields = {\n    requeue: void 0\n  };\n  val = !!(1 & buffer[0]);\n  fields.requeue = val;\n  return fields;\n}\n\nfunction encodeBasicRecover(channel, fields) {\n  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932270, 7);\n  offset = 11;\n  val = fields.requeue;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicRecoverOk(buffer) {\n  return {};\n}\n\nfunction encodeBasicRecoverOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932271, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeBasicNack(buffer) {\n  var val, offset = 0, fields = {\n    deliveryTag: void 0,\n    multiple: void 0,\n    requeue: void 0\n  };\n  val = ints.readUInt64BE(buffer, offset);\n  offset += 8;\n  fields.deliveryTag = val;\n  val = !!(1 & buffer[offset]);\n  fields.multiple = val;\n  val = !!(2 & buffer[offset]);\n  fields.requeue = val;\n  return fields;\n}\n\nfunction encodeBasicNack(channel, fields) {\n  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(21);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932280, 7);\n  offset = 11;\n  val = fields.deliveryTag;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryTag' is the wrong type; must be a number (but not NaN)\");\n  ints.writeUInt64BE(buffer, val, offset);\n  offset += 8;\n  val = fields.multiple;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.requeue;\n  void 0 === val && (val = !0);\n  val && (bits += 2);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionStart(buffer) {\n  var val, len, offset = 0, fields = {\n    versionMajor: void 0,\n    versionMinor: void 0,\n    serverProperties: void 0,\n    mechanisms: void 0,\n    locales: void 0\n  };\n  val = buffer[offset];\n  offset++;\n  fields.versionMajor = val;\n  val = buffer[offset];\n  offset++;\n  fields.versionMinor = val;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.subarray(offset, offset + len));\n  offset += len;\n  fields.serverProperties = val;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.subarray(offset, offset + len);\n  offset += len;\n  fields.mechanisms = val;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.subarray(offset, offset + len);\n  offset += len;\n  fields.locales = val;\n  return fields;\n}\n\nfunction encodeConnectionStart(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;\n  val = fields.serverProperties;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'serverProperties'\");\n  if (\"object\" != typeof val) throw new TypeError(\"Field 'serverProperties' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var serverProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += serverProperties_encoded.length;\n  val = fields.mechanisms;\n  if (void 0 === val) val = Buffer.from(\"PLAIN\"); else if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'mechanisms' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  val = fields.locales;\n  if (void 0 === val) val = Buffer.from(\"en_US\"); else if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'locales' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  var buffer = Buffer.alloc(22 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655370, 7);\n  offset = 11;\n  val = fields.versionMajor;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'versionMajor' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt8(val, offset);\n  offset++;\n  val = fields.versionMinor;\n  if (void 0 === val) val = 9; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'versionMinor' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt8(val, offset);\n  offset++;\n  offset += serverProperties_encoded.copy(buffer, offset);\n  val = fields.mechanisms;\n  void 0 === val && (val = Buffer.from(\"PLAIN\"));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  val = fields.locales;\n  void 0 === val && (val = Buffer.from(\"en_US\"));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionStartOk(buffer) {\n  var val, len, offset = 0, fields = {\n    clientProperties: void 0,\n    mechanism: void 0,\n    response: void 0,\n    locale: void 0\n  };\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.subarray(offset, offset + len));\n  offset += len;\n  fields.clientProperties = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.mechanism = val;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.subarray(offset, offset + len);\n  offset += len;\n  fields.response = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.locale = val;\n  return fields;\n}\n\nfunction encodeConnectionStartOk(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;\n  val = fields.clientProperties;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'clientProperties'\");\n  if (\"object\" != typeof val) throw new TypeError(\"Field 'clientProperties' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var clientProperties_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += clientProperties_encoded.length;\n  val = fields.mechanism;\n  if (void 0 === val) val = \"PLAIN\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'mechanism' is the wrong type; must be a string (up to 255 chars)\");\n  var mechanism_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += mechanism_len;\n  val = fields.response;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'response'\");\n  if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'response' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  val = fields.locale;\n  if (void 0 === val) val = \"en_US\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'locale' is the wrong type; must be a string (up to 255 chars)\");\n  var locale_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += locale_len;\n  var buffer = Buffer.alloc(18 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655371, 7);\n  offset = 11;\n  offset += clientProperties_encoded.copy(buffer, offset);\n  val = fields.mechanism;\n  void 0 === val && (val = \"PLAIN\");\n  buffer[offset] = mechanism_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += mechanism_len;\n  val = fields.response;\n  void 0 === val && (val = Buffer.from(void 0));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  val = fields.locale;\n  void 0 === val && (val = \"en_US\");\n  buffer[offset] = locale_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += locale_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionSecure(buffer) {\n  var val, len, offset = 0, fields = {\n    challenge: void 0\n  };\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.subarray(offset, offset + len);\n  offset += len;\n  fields.challenge = val;\n  return fields;\n}\n\nfunction encodeConnectionSecure(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0;\n  val = fields.challenge;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'challenge'\");\n  if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'challenge' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655380, 7);\n  offset = 11;\n  val = fields.challenge;\n  void 0 === val && (val = Buffer.from(void 0));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionSecureOk(buffer) {\n  var val, len, offset = 0, fields = {\n    response: void 0\n  };\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.subarray(offset, offset + len);\n  offset += len;\n  fields.response = val;\n  return fields;\n}\n\nfunction encodeConnectionSecureOk(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0;\n  val = fields.response;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'response'\");\n  if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'response' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655381, 7);\n  offset = 11;\n  val = fields.response;\n  void 0 === val && (val = Buffer.from(void 0));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionTune(buffer) {\n  var val, offset = 0, fields = {\n    channelMax: void 0,\n    frameMax: void 0,\n    heartbeat: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.channelMax = val;\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.frameMax = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.heartbeat = val;\n  return fields;\n}\n\nfunction encodeConnectionTune(channel, fields) {\n  var offset = 0, val = null, buffer = Buffer.alloc(20);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655390, 7);\n  offset = 11;\n  val = fields.channelMax;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'channelMax' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.frameMax;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'frameMax' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  val = fields.heartbeat;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'heartbeat' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionTuneOk(buffer) {\n  var val, offset = 0, fields = {\n    channelMax: void 0,\n    frameMax: void 0,\n    heartbeat: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.channelMax = val;\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.frameMax = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.heartbeat = val;\n  return fields;\n}\n\nfunction encodeConnectionTuneOk(channel, fields) {\n  var offset = 0, val = null, buffer = Buffer.alloc(20);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655391, 7);\n  offset = 11;\n  val = fields.channelMax;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'channelMax' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.frameMax;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'frameMax' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  val = fields.heartbeat;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'heartbeat' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionOpen(buffer) {\n  var val, len, offset = 0, fields = {\n    virtualHost: void 0,\n    capabilities: void 0,\n    insist: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.virtualHost = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.capabilities = val;\n  val = !!(1 & buffer[offset]);\n  fields.insist = val;\n  return fields;\n}\n\nfunction encodeConnectionOpen(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.virtualHost;\n  if (void 0 === val) val = \"/\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'virtualHost' is the wrong type; must be a string (up to 255 chars)\");\n  var virtualHost_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += virtualHost_len;\n  val = fields.capabilities;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'capabilities' is the wrong type; must be a string (up to 255 chars)\");\n  var capabilities_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += capabilities_len;\n  var buffer = Buffer.alloc(15 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655400, 7);\n  offset = 11;\n  val = fields.virtualHost;\n  void 0 === val && (val = \"/\");\n  buffer[offset] = virtualHost_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += virtualHost_len;\n  val = fields.capabilities;\n  void 0 === val && (val = \"\");\n  buffer[offset] = capabilities_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += capabilities_len;\n  val = fields.insist;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionOpenOk(buffer) {\n  var val, len, offset = 0, fields = {\n    knownHosts: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.knownHosts = val;\n  return fields;\n}\n\nfunction encodeConnectionOpenOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.knownHosts;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'knownHosts' is the wrong type; must be a string (up to 255 chars)\");\n  var knownHosts_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += knownHosts_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655401, 7);\n  offset = 11;\n  val = fields.knownHosts;\n  void 0 === val && (val = \"\");\n  buffer[offset] = knownHosts_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += knownHosts_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionClose(buffer) {\n  var val, len, offset = 0, fields = {\n    replyCode: void 0,\n    replyText: void 0,\n    classId: void 0,\n    methodId: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.replyCode = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.replyText = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.classId = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.methodId = val;\n  return fields;\n}\n\nfunction encodeConnectionClose(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.replyText;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'replyText' is the wrong type; must be a string (up to 255 chars)\");\n  var replyText_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += replyText_len;\n  var buffer = Buffer.alloc(19 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655410, 7);\n  offset = 11;\n  val = fields.replyCode;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'replyCode'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'replyCode' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.replyText;\n  void 0 === val && (val = \"\");\n  buffer[offset] = replyText_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += replyText_len;\n  val = fields.classId;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'classId'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'classId' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.methodId;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'methodId'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'methodId' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionCloseOk(buffer) {\n  return {};\n}\n\nfunction encodeConnectionCloseOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655411, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionBlocked(buffer) {\n  var val, len, offset = 0, fields = {\n    reason: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.reason = val;\n  return fields;\n}\n\nfunction encodeConnectionBlocked(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.reason;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'reason' is the wrong type; must be a string (up to 255 chars)\");\n  var reason_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += reason_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655420, 7);\n  offset = 11;\n  val = fields.reason;\n  void 0 === val && (val = \"\");\n  buffer[offset] = reason_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += reason_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionUnblocked(buffer) {\n  return {};\n}\n\nfunction encodeConnectionUnblocked(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655421, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionUpdateSecret(buffer) {\n  var val, len, offset = 0, fields = {\n    newSecret: void 0,\n    reason: void 0\n  };\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.subarray(offset, offset + len);\n  offset += len;\n  fields.newSecret = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.reason = val;\n  return fields;\n}\n\nfunction encodeConnectionUpdateSecret(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0;\n  val = fields.newSecret;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'newSecret'\");\n  if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'newSecret' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  val = fields.reason;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'reason'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'reason' is the wrong type; must be a string (up to 255 chars)\");\n  var reason_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += reason_len;\n  var buffer = Buffer.alloc(17 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655430, 7);\n  offset = 11;\n  val = fields.newSecret;\n  void 0 === val && (val = Buffer.from(void 0));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  val = fields.reason;\n  void 0 === val && (val = void 0);\n  buffer[offset] = reason_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += reason_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConnectionUpdateSecretOk(buffer) {\n  return {};\n}\n\nfunction encodeConnectionUpdateSecretOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(655431, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelOpen(buffer) {\n  var val, len, offset = 0, fields = {\n    outOfBand: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.outOfBand = val;\n  return fields;\n}\n\nfunction encodeChannelOpen(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.outOfBand;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'outOfBand' is the wrong type; must be a string (up to 255 chars)\");\n  var outOfBand_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += outOfBand_len;\n  var buffer = Buffer.alloc(13 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310730, 7);\n  offset = 11;\n  val = fields.outOfBand;\n  void 0 === val && (val = \"\");\n  buffer[offset] = outOfBand_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += outOfBand_len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelOpenOk(buffer) {\n  var val, len, offset = 0, fields = {\n    channelId: void 0\n  };\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = buffer.subarray(offset, offset + len);\n  offset += len;\n  fields.channelId = val;\n  return fields;\n}\n\nfunction encodeChannelOpenOk(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0;\n  val = fields.channelId;\n  if (void 0 === val) val = Buffer.from(\"\"); else if (!Buffer.isBuffer(val)) throw new TypeError(\"Field 'channelId' is the wrong type; must be a Buffer\");\n  varyingSize += val.length;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310731, 7);\n  offset = 11;\n  val = fields.channelId;\n  void 0 === val && (val = Buffer.from(\"\"));\n  len = val.length;\n  buffer.writeUInt32BE(len, offset);\n  offset += 4;\n  val.copy(buffer, offset);\n  offset += len;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelFlow(buffer) {\n  var val, fields = {\n    active: void 0\n  };\n  val = !!(1 & buffer[0]);\n  fields.active = val;\n  return fields;\n}\n\nfunction encodeChannelFlow(channel, fields) {\n  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310740, 7);\n  offset = 11;\n  val = fields.active;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'active'\");\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelFlowOk(buffer) {\n  var val, fields = {\n    active: void 0\n  };\n  val = !!(1 & buffer[0]);\n  fields.active = val;\n  return fields;\n}\n\nfunction encodeChannelFlowOk(channel, fields) {\n  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310741, 7);\n  offset = 11;\n  val = fields.active;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'active'\");\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelClose(buffer) {\n  var val, len, offset = 0, fields = {\n    replyCode: void 0,\n    replyText: void 0,\n    classId: void 0,\n    methodId: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.replyCode = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.replyText = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.classId = val;\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.methodId = val;\n  return fields;\n}\n\nfunction encodeChannelClose(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.replyText;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'replyText' is the wrong type; must be a string (up to 255 chars)\");\n  var replyText_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += replyText_len;\n  var buffer = Buffer.alloc(19 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310760, 7);\n  offset = 11;\n  val = fields.replyCode;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'replyCode'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'replyCode' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.replyText;\n  void 0 === val && (val = \"\");\n  buffer[offset] = replyText_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += replyText_len;\n  val = fields.classId;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'classId'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'classId' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.methodId;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'methodId'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'methodId' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeChannelCloseOk(buffer) {\n  return {};\n}\n\nfunction encodeChannelCloseOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1310761, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeAccessRequest(buffer) {\n  var val, len, offset = 0, fields = {\n    realm: void 0,\n    exclusive: void 0,\n    passive: void 0,\n    active: void 0,\n    write: void 0,\n    read: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.realm = val;\n  val = !!(1 & buffer[offset]);\n  fields.exclusive = val;\n  val = !!(2 & buffer[offset]);\n  fields.passive = val;\n  val = !!(4 & buffer[offset]);\n  fields.active = val;\n  val = !!(8 & buffer[offset]);\n  fields.write = val;\n  val = !!(16 & buffer[offset]);\n  fields.read = val;\n  return fields;\n}\n\nfunction encodeAccessRequest(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.realm;\n  if (void 0 === val) val = \"/data\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'realm' is the wrong type; must be a string (up to 255 chars)\");\n  var realm_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += realm_len;\n  var buffer = Buffer.alloc(14 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1966090, 7);\n  offset = 11;\n  val = fields.realm;\n  void 0 === val && (val = \"/data\");\n  buffer[offset] = realm_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += realm_len;\n  val = fields.exclusive;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.passive;\n  void 0 === val && (val = !0);\n  val && (bits += 2);\n  val = fields.active;\n  void 0 === val && (val = !0);\n  val && (bits += 4);\n  val = fields.write;\n  void 0 === val && (val = !0);\n  val && (bits += 8);\n  val = fields.read;\n  void 0 === val && (val = !0);\n  val && (bits += 16);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeAccessRequestOk(buffer) {\n  var val, offset = 0, fields = {\n    ticket: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  return fields;\n}\n\nfunction encodeAccessRequestOk(channel, fields) {\n  var offset = 0, val = null, buffer = Buffer.alloc(14);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(1966091, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 1; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeDeclare(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    exchange: void 0,\n    type: void 0,\n    passive: void 0,\n    durable: void 0,\n    autoDelete: void 0,\n    internal: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.type = val;\n  val = !!(1 & buffer[offset]);\n  fields.passive = val;\n  val = !!(2 & buffer[offset]);\n  fields.durable = val;\n  val = !!(4 & buffer[offset]);\n  fields.autoDelete = val;\n  val = !!(8 & buffer[offset]);\n  fields.internal = val;\n  val = !!(16 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.subarray(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeExchangeDeclare(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.type;\n  if (void 0 === val) val = \"direct\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'type' is the wrong type; must be a string (up to 255 chars)\");\n  var type_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += type_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(17 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621450, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.type;\n  void 0 === val && (val = \"direct\");\n  buffer[offset] = type_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += type_len;\n  val = fields.passive;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.durable;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  val = fields.autoDelete;\n  void 0 === val && (val = !1);\n  val && (bits += 4);\n  val = fields.internal;\n  void 0 === val && (val = !1);\n  val && (bits += 8);\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 16);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeDeclareOk(buffer) {\n  return {};\n}\n\nfunction encodeExchangeDeclareOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621451, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeDelete(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    exchange: void 0,\n    ifUnused: void 0,\n    nowait: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  val = !!(1 & buffer[offset]);\n  fields.ifUnused = val;\n  val = !!(2 & buffer[offset]);\n  fields.nowait = val;\n  return fields;\n}\n\nfunction encodeExchangeDelete(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621460, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.ifUnused;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeDeleteOk(buffer) {\n  return {};\n}\n\nfunction encodeExchangeDeleteOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621461, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeBind(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    destination: void 0,\n    source: void 0,\n    routingKey: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.destination = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.source = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  val = !!(1 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.subarray(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeExchangeBind(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.destination;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'destination'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'destination' is the wrong type; must be a string (up to 255 chars)\");\n  var destination_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += destination_len;\n  val = fields.source;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'source'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'source' is the wrong type; must be a string (up to 255 chars)\");\n  var source_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += source_len;\n  val = fields.routingKey;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(18 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621470, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.destination;\n  void 0 === val && (val = void 0);\n  buffer[offset] = destination_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += destination_len;\n  val = fields.source;\n  void 0 === val && (val = void 0);\n  buffer[offset] = source_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += source_len;\n  val = fields.routingKey;\n  void 0 === val && (val = \"\");\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeBindOk(buffer) {\n  return {};\n}\n\nfunction encodeExchangeBindOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621471, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeUnbind(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    destination: void 0,\n    source: void 0,\n    routingKey: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.destination = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.source = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  val = !!(1 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.subarray(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeExchangeUnbind(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.destination;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'destination'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'destination' is the wrong type; must be a string (up to 255 chars)\");\n  var destination_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += destination_len;\n  val = fields.source;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'source'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'source' is the wrong type; must be a string (up to 255 chars)\");\n  var source_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += source_len;\n  val = fields.routingKey;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(18 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621480, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.destination;\n  void 0 === val && (val = void 0);\n  buffer[offset] = destination_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += destination_len;\n  val = fields.source;\n  void 0 === val && (val = void 0);\n  buffer[offset] = source_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += source_len;\n  val = fields.routingKey;\n  void 0 === val && (val = \"\");\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeExchangeUnbindOk(buffer) {\n  return {};\n}\n\nfunction encodeExchangeUnbindOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(2621491, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueDeclare(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    passive: void 0,\n    durable: void 0,\n    exclusive: void 0,\n    autoDelete: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  val = !!(1 & buffer[offset]);\n  fields.passive = val;\n  val = !!(2 & buffer[offset]);\n  fields.durable = val;\n  val = !!(4 & buffer[offset]);\n  fields.exclusive = val;\n  val = !!(8 & buffer[offset]);\n  fields.autoDelete = val;\n  val = !!(16 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.subarray(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeQueueDeclare(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276810, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.passive;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.durable;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  val = fields.exclusive;\n  void 0 === val && (val = !1);\n  val && (bits += 4);\n  val = fields.autoDelete;\n  void 0 === val && (val = !1);\n  val && (bits += 8);\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 16);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueDeclareOk(buffer) {\n  var val, len, offset = 0, fields = {\n    queue: void 0,\n    messageCount: void 0,\n    consumerCount: void 0\n  };\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.messageCount = val;\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.consumerCount = val;\n  return fields;\n}\n\nfunction encodeQueueDeclareOk(channel, fields) {\n  var offset = 0, val = null, varyingSize = 0;\n  val = fields.queue;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'queue'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  var buffer = Buffer.alloc(21 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276811, 7);\n  offset = 11;\n  val = fields.queue;\n  void 0 === val && (val = void 0);\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.messageCount;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'messageCount'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'messageCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  val = fields.consumerCount;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'consumerCount'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'consumerCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueBind(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    exchange: void 0,\n    routingKey: void 0,\n    nowait: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  val = !!(1 & buffer[offset]);\n  fields.nowait = val;\n  offset++;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.subarray(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeQueueBind(channel, fields) {\n  var len, offset = 0, val = null, bits = 0, varyingSize = 0, scratchOffset = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(18 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276820, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = \"\");\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  bits = 0;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueBindOk(buffer) {\n  return {};\n}\n\nfunction encodeQueueBindOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276821, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueuePurge(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    nowait: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  val = !!(1 & buffer[offset]);\n  fields.nowait = val;\n  return fields;\n}\n\nfunction encodeQueuePurge(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276830, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueuePurgeOk(buffer) {\n  var val, offset = 0, fields = {\n    messageCount: void 0\n  };\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.messageCount = val;\n  return fields;\n}\n\nfunction encodeQueuePurgeOk(channel, fields) {\n  var offset = 0, val = null, buffer = Buffer.alloc(16);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276831, 7);\n  offset = 11;\n  val = fields.messageCount;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'messageCount'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'messageCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueDelete(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    ifUnused: void 0,\n    ifEmpty: void 0,\n    nowait: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  val = !!(1 & buffer[offset]);\n  fields.ifUnused = val;\n  val = !!(2 & buffer[offset]);\n  fields.ifEmpty = val;\n  val = !!(4 & buffer[offset]);\n  fields.nowait = val;\n  return fields;\n}\n\nfunction encodeQueueDelete(channel, fields) {\n  var offset = 0, val = null, bits = 0, varyingSize = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  var buffer = Buffer.alloc(16 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276840, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.ifUnused;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  val = fields.ifEmpty;\n  void 0 === val && (val = !1);\n  val && (bits += 2);\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 4);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueDeleteOk(buffer) {\n  var val, offset = 0, fields = {\n    messageCount: void 0\n  };\n  val = buffer.readUInt32BE(offset);\n  offset += 4;\n  fields.messageCount = val;\n  return fields;\n}\n\nfunction encodeQueueDeleteOk(channel, fields) {\n  var offset = 0, val = null, buffer = Buffer.alloc(16);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276841, 7);\n  offset = 11;\n  val = fields.messageCount;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'messageCount'\");\n  if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'messageCount' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt32BE(val, offset);\n  offset += 4;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueUnbind(buffer) {\n  var val, len, offset = 0, fields = {\n    ticket: void 0,\n    queue: void 0,\n    exchange: void 0,\n    routingKey: void 0,\n    arguments: void 0\n  };\n  val = buffer.readUInt16BE(offset);\n  offset += 2;\n  fields.ticket = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.queue = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.exchange = val;\n  len = buffer.readUInt8(offset);\n  offset++;\n  val = buffer.toString(\"utf8\", offset, offset + len);\n  offset += len;\n  fields.routingKey = val;\n  len = buffer.readUInt32BE(offset);\n  offset += 4;\n  val = decodeFields(buffer.subarray(offset, offset + len));\n  offset += len;\n  fields.arguments = val;\n  return fields;\n}\n\nfunction encodeQueueUnbind(channel, fields) {\n  var len, offset = 0, val = null, varyingSize = 0, scratchOffset = 0;\n  val = fields.queue;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'queue' is the wrong type; must be a string (up to 255 chars)\");\n  var queue_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += queue_len;\n  val = fields.exchange;\n  if (void 0 === val) throw new Error(\"Missing value for mandatory field 'exchange'\");\n  if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'exchange' is the wrong type; must be a string (up to 255 chars)\");\n  var exchange_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += exchange_len;\n  val = fields.routingKey;\n  if (void 0 === val) val = \"\"; else if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'routingKey' is the wrong type; must be a string (up to 255 chars)\");\n  var routingKey_len = Buffer.byteLength(val, \"utf8\");\n  varyingSize += routingKey_len;\n  val = fields.arguments;\n  if (void 0 === val) val = {}; else if (\"object\" != typeof val) throw new TypeError(\"Field 'arguments' is the wrong type; must be an object\");\n  len = encodeTable(SCRATCH, val, scratchOffset);\n  var arguments_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n  scratchOffset += len;\n  varyingSize += arguments_encoded.length;\n  var buffer = Buffer.alloc(17 + varyingSize);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276850, 7);\n  offset = 11;\n  val = fields.ticket;\n  if (void 0 === val) val = 0; else if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'ticket' is the wrong type; must be a number (but not NaN)\");\n  buffer.writeUInt16BE(val, offset);\n  offset += 2;\n  val = fields.queue;\n  void 0 === val && (val = \"\");\n  buffer[offset] = queue_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += queue_len;\n  val = fields.exchange;\n  void 0 === val && (val = void 0);\n  buffer[offset] = exchange_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += exchange_len;\n  val = fields.routingKey;\n  void 0 === val && (val = \"\");\n  buffer[offset] = routingKey_len;\n  offset++;\n  buffer.write(val, offset, \"utf8\");\n  offset += routingKey_len;\n  offset += arguments_encoded.copy(buffer, offset);\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeQueueUnbindOk(buffer) {\n  return {};\n}\n\nfunction encodeQueueUnbindOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3276851, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxSelect(buffer) {\n  return {};\n}\n\nfunction encodeTxSelect(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898250, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxSelectOk(buffer) {\n  return {};\n}\n\nfunction encodeTxSelectOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898251, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxCommit(buffer) {\n  return {};\n}\n\nfunction encodeTxCommit(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898260, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxCommitOk(buffer) {\n  return {};\n}\n\nfunction encodeTxCommitOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898261, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxRollback(buffer) {\n  return {};\n}\n\nfunction encodeTxRollback(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898270, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeTxRollbackOk(buffer) {\n  return {};\n}\n\nfunction encodeTxRollbackOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5898271, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConfirmSelect(buffer) {\n  var val, fields = {\n    nowait: void 0\n  };\n  val = !!(1 & buffer[0]);\n  fields.nowait = val;\n  return fields;\n}\n\nfunction encodeConfirmSelect(channel, fields) {\n  var offset = 0, val = null, bits = 0, buffer = Buffer.alloc(13);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5570570, 7);\n  offset = 11;\n  val = fields.nowait;\n  void 0 === val && (val = !1);\n  val && (bits += 1);\n  buffer[offset] = bits;\n  offset++;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction decodeConfirmSelectOk(buffer) {\n  return {};\n}\n\nfunction encodeConfirmSelectOk(channel, fields) {\n  var offset = 0, buffer = Buffer.alloc(12);\n  buffer[0] = 1;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(5570571, 7);\n  offset = 11;\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  return buffer;\n}\n\nfunction encodeBasicProperties(channel, size, fields) {\n  var val, len, offset = 0, flags = 0, scratchOffset = 0, varyingSize = 0;\n  val = fields.contentType;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'contentType' is the wrong type; must be a string (up to 255 chars)\");\n    var contentType_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += contentType_len;\n  }\n  val = fields.contentEncoding;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'contentEncoding' is the wrong type; must be a string (up to 255 chars)\");\n    var contentEncoding_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += contentEncoding_len;\n  }\n  val = fields.headers;\n  if (void 0 != val) {\n    if (\"object\" != typeof val) throw new TypeError(\"Field 'headers' is the wrong type; must be an object\");\n    len = encodeTable(SCRATCH, val, scratchOffset);\n    var headers_encoded = SCRATCH.slice(scratchOffset, scratchOffset + len);\n    scratchOffset += len;\n    varyingSize += headers_encoded.length;\n  }\n  val = fields.deliveryMode;\n  if (void 0 != val) {\n    if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'deliveryMode' is the wrong type; must be a number (but not NaN)\");\n    varyingSize += 1;\n  }\n  val = fields.priority;\n  if (void 0 != val) {\n    if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'priority' is the wrong type; must be a number (but not NaN)\");\n    varyingSize += 1;\n  }\n  val = fields.correlationId;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'correlationId' is the wrong type; must be a string (up to 255 chars)\");\n    var correlationId_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += correlationId_len;\n  }\n  val = fields.replyTo;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'replyTo' is the wrong type; must be a string (up to 255 chars)\");\n    var replyTo_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += replyTo_len;\n  }\n  val = fields.expiration;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'expiration' is the wrong type; must be a string (up to 255 chars)\");\n    var expiration_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += expiration_len;\n  }\n  val = fields.messageId;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'messageId' is the wrong type; must be a string (up to 255 chars)\");\n    var messageId_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += messageId_len;\n  }\n  val = fields.timestamp;\n  if (void 0 != val) {\n    if (\"number\" != typeof val || isNaN(val)) throw new TypeError(\"Field 'timestamp' is the wrong type; must be a number (but not NaN)\");\n    varyingSize += 8;\n  }\n  val = fields.type;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'type' is the wrong type; must be a string (up to 255 chars)\");\n    var type_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += type_len;\n  }\n  val = fields.userId;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'userId' is the wrong type; must be a string (up to 255 chars)\");\n    var userId_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += userId_len;\n  }\n  val = fields.appId;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'appId' is the wrong type; must be a string (up to 255 chars)\");\n    var appId_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += appId_len;\n  }\n  val = fields.clusterId;\n  if (void 0 != val) {\n    if (!(\"string\" == typeof val && Buffer.byteLength(val) < 256)) throw new TypeError(\"Field 'clusterId' is the wrong type; must be a string (up to 255 chars)\");\n    var clusterId_len = Buffer.byteLength(val, \"utf8\");\n    varyingSize += 1;\n    varyingSize += clusterId_len;\n  }\n  var buffer = Buffer.alloc(22 + varyingSize);\n  buffer[0] = 2;\n  buffer.writeUInt16BE(channel, 1);\n  buffer.writeUInt32BE(3932160, 7);\n  ints.writeUInt64BE(buffer, size, 11);\n  flags = 0;\n  offset = 21;\n  val = fields.contentType;\n  if (void 0 != val) {\n    flags += 32768;\n    buffer[offset] = contentType_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += contentType_len;\n  }\n  val = fields.contentEncoding;\n  if (void 0 != val) {\n    flags += 16384;\n    buffer[offset] = contentEncoding_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += contentEncoding_len;\n  }\n  val = fields.headers;\n  if (void 0 != val) {\n    flags += 8192;\n    offset += headers_encoded.copy(buffer, offset);\n  }\n  val = fields.deliveryMode;\n  if (void 0 != val) {\n    flags += 4096;\n    buffer.writeUInt8(val, offset);\n    offset++;\n  }\n  val = fields.priority;\n  if (void 0 != val) {\n    flags += 2048;\n    buffer.writeUInt8(val, offset);\n    offset++;\n  }\n  val = fields.correlationId;\n  if (void 0 != val) {\n    flags += 1024;\n    buffer[offset] = correlationId_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += correlationId_len;\n  }\n  val = fields.replyTo;\n  if (void 0 != val) {\n    flags += 512;\n    buffer[offset] = replyTo_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += replyTo_len;\n  }\n  val = fields.expiration;\n  if (void 0 != val) {\n    flags += 256;\n    buffer[offset] = expiration_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += expiration_len;\n  }\n  val = fields.messageId;\n  if (void 0 != val) {\n    flags += 128;\n    buffer[offset] = messageId_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += messageId_len;\n  }\n  val = fields.timestamp;\n  if (void 0 != val) {\n    flags += 64;\n    ints.writeUInt64BE(buffer, val, offset);\n    offset += 8;\n  }\n  val = fields.type;\n  if (void 0 != val) {\n    flags += 32;\n    buffer[offset] = type_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += type_len;\n  }\n  val = fields.userId;\n  if (void 0 != val) {\n    flags += 16;\n    buffer[offset] = userId_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += userId_len;\n  }\n  val = fields.appId;\n  if (void 0 != val) {\n    flags += 8;\n    buffer[offset] = appId_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += appId_len;\n  }\n  val = fields.clusterId;\n  if (void 0 != val) {\n    flags += 4;\n    buffer[offset] = clusterId_len;\n    offset++;\n    buffer.write(val, offset, \"utf8\");\n    offset += clusterId_len;\n  }\n  buffer[offset] = 206;\n  buffer.writeUInt32BE(offset - 7, 3);\n  buffer.writeUInt16BE(flags, 19);\n  return buffer.subarray(0, offset + 1);\n}\n\nfunction decodeBasicProperties(buffer) {\n  var flags, val, len, offset = 2;\n  flags = buffer.readUInt16BE(0);\n  if (0 === flags) return {};\n  var fields = {\n    contentType: void 0,\n    contentEncoding: void 0,\n    headers: void 0,\n    deliveryMode: void 0,\n    priority: void 0,\n    correlationId: void 0,\n    replyTo: void 0,\n    expiration: void 0,\n    messageId: void 0,\n    timestamp: void 0,\n    type: void 0,\n    userId: void 0,\n    appId: void 0,\n    clusterId: void 0\n  };\n  if (32768 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.contentType = val;\n  }\n  if (16384 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.contentEncoding = val;\n  }\n  if (8192 & flags) {\n    len = buffer.readUInt32BE(offset);\n    offset += 4;\n    val = decodeFields(buffer.subarray(offset, offset + len));\n    offset += len;\n    fields.headers = val;\n  }\n  if (4096 & flags) {\n    val = buffer[offset];\n    offset++;\n    fields.deliveryMode = val;\n  }\n  if (2048 & flags) {\n    val = buffer[offset];\n    offset++;\n    fields.priority = val;\n  }\n  if (1024 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.correlationId = val;\n  }\n  if (512 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.replyTo = val;\n  }\n  if (256 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.expiration = val;\n  }\n  if (128 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.messageId = val;\n  }\n  if (64 & flags) {\n    val = ints.readUInt64BE(buffer, offset);\n    offset += 8;\n    fields.timestamp = val;\n  }\n  if (32 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.type = val;\n  }\n  if (16 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.userId = val;\n  }\n  if (8 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.appId = val;\n  }\n  if (4 & flags) {\n    len = buffer.readUInt8(offset);\n    offset++;\n    val = buffer.toString(\"utf8\", offset, offset + len);\n    offset += len;\n    fields.clusterId = val;\n  }\n  return fields;\n}\n\nvar codec = __webpack_require__(/*! ./codec */ \"(rsc)/./node_modules/amqplib/lib/codec.js\"), ints = __webpack_require__(/*! buffer-more-ints */ \"(rsc)/./node_modules/buffer-more-ints/buffer-more-ints.js\"), encodeTable = codec.encodeTable, decodeFields = codec.decodeFields, SCRATCH = Buffer.alloc(65536), EMPTY_OBJECT = Object.freeze({});\n\nmodule.exports.constants = {\n  FRAME_METHOD: 1,\n  FRAME_HEADER: 2,\n  FRAME_BODY: 3,\n  FRAME_HEARTBEAT: 8,\n  FRAME_MIN_SIZE: 4096,\n  FRAME_END: 206,\n  REPLY_SUCCESS: 200,\n  CONTENT_TOO_LARGE: 311,\n  NO_ROUTE: 312,\n  NO_CONSUMERS: 313,\n  ACCESS_REFUSED: 403,\n  NOT_FOUND: 404,\n  RESOURCE_LOCKED: 405,\n  PRECONDITION_FAILED: 406,\n  CONNECTION_FORCED: 320,\n  INVALID_PATH: 402,\n  FRAME_ERROR: 501,\n  SYNTAX_ERROR: 502,\n  COMMAND_INVALID: 503,\n  CHANNEL_ERROR: 504,\n  UNEXPECTED_FRAME: 505,\n  RESOURCE_ERROR: 506,\n  NOT_ALLOWED: 530,\n  NOT_IMPLEMENTED: 540,\n  INTERNAL_ERROR: 541\n};\n\nmodule.exports.constant_strs = {\n  \"1\": \"FRAME-METHOD\",\n  \"2\": \"FRAME-HEADER\",\n  \"3\": \"FRAME-BODY\",\n  \"8\": \"FRAME-HEARTBEAT\",\n  \"200\": \"REPLY-SUCCESS\",\n  \"206\": \"FRAME-END\",\n  \"311\": \"CONTENT-TOO-LARGE\",\n  \"312\": \"NO-ROUTE\",\n  \"313\": \"NO-CONSUMERS\",\n  \"320\": \"CONNECTION-FORCED\",\n  \"402\": \"INVALID-PATH\",\n  \"403\": \"ACCESS-REFUSED\",\n  \"404\": \"NOT-FOUND\",\n  \"405\": \"RESOURCE-LOCKED\",\n  \"406\": \"PRECONDITION-FAILED\",\n  \"501\": \"FRAME-ERROR\",\n  \"502\": \"SYNTAX-ERROR\",\n  \"503\": \"COMMAND-INVALID\",\n  \"504\": \"CHANNEL-ERROR\",\n  \"505\": \"UNEXPECTED-FRAME\",\n  \"506\": \"RESOURCE-ERROR\",\n  \"530\": \"NOT-ALLOWED\",\n  \"540\": \"NOT-IMPLEMENTED\",\n  \"541\": \"INTERNAL-ERROR\",\n  \"4096\": \"FRAME-MIN-SIZE\"\n};\n\nmodule.exports.FRAME_OVERHEAD = 8;\n\nmodule.exports.decode = function(id, buf) {\n  switch (id) {\n   case 3932170:\n    return decodeBasicQos(buf);\n\n   case 3932171:\n    return decodeBasicQosOk(buf);\n\n   case 3932180:\n    return decodeBasicConsume(buf);\n\n   case 3932181:\n    return decodeBasicConsumeOk(buf);\n\n   case 3932190:\n    return decodeBasicCancel(buf);\n\n   case 3932191:\n    return decodeBasicCancelOk(buf);\n\n   case 3932200:\n    return decodeBasicPublish(buf);\n\n   case 3932210:\n    return decodeBasicReturn(buf);\n\n   case 3932220:\n    return decodeBasicDeliver(buf);\n\n   case 3932230:\n    return decodeBasicGet(buf);\n\n   case 3932231:\n    return decodeBasicGetOk(buf);\n\n   case 3932232:\n    return decodeBasicGetEmpty(buf);\n\n   case 3932240:\n    return decodeBasicAck(buf);\n\n   case 3932250:\n    return decodeBasicReject(buf);\n\n   case 3932260:\n    return decodeBasicRecoverAsync(buf);\n\n   case 3932270:\n    return decodeBasicRecover(buf);\n\n   case 3932271:\n    return decodeBasicRecoverOk(buf);\n\n   case 3932280:\n    return decodeBasicNack(buf);\n\n   case 655370:\n    return decodeConnectionStart(buf);\n\n   case 655371:\n    return decodeConnectionStartOk(buf);\n\n   case 655380:\n    return decodeConnectionSecure(buf);\n\n   case 655381:\n    return decodeConnectionSecureOk(buf);\n\n   case 655390:\n    return decodeConnectionTune(buf);\n\n   case 655391:\n    return decodeConnectionTuneOk(buf);\n\n   case 655400:\n    return decodeConnectionOpen(buf);\n\n   case 655401:\n    return decodeConnectionOpenOk(buf);\n\n   case 655410:\n    return decodeConnectionClose(buf);\n\n   case 655411:\n    return decodeConnectionCloseOk(buf);\n\n   case 655420:\n    return decodeConnectionBlocked(buf);\n\n   case 655421:\n    return decodeConnectionUnblocked(buf);\n\n   case 655430:\n    return decodeConnectionUpdateSecret(buf);\n\n   case 655431:\n    return decodeConnectionUpdateSecretOk(buf);\n\n   case 1310730:\n    return decodeChannelOpen(buf);\n\n   case 1310731:\n    return decodeChannelOpenOk(buf);\n\n   case 1310740:\n    return decodeChannelFlow(buf);\n\n   case 1310741:\n    return decodeChannelFlowOk(buf);\n\n   case 1310760:\n    return decodeChannelClose(buf);\n\n   case 1310761:\n    return decodeChannelCloseOk(buf);\n\n   case 1966090:\n    return decodeAccessRequest(buf);\n\n   case 1966091:\n    return decodeAccessRequestOk(buf);\n\n   case 2621450:\n    return decodeExchangeDeclare(buf);\n\n   case 2621451:\n    return decodeExchangeDeclareOk(buf);\n\n   case 2621460:\n    return decodeExchangeDelete(buf);\n\n   case 2621461:\n    return decodeExchangeDeleteOk(buf);\n\n   case 2621470:\n    return decodeExchangeBind(buf);\n\n   case 2621471:\n    return decodeExchangeBindOk(buf);\n\n   case 2621480:\n    return decodeExchangeUnbind(buf);\n\n   case 2621491:\n    return decodeExchangeUnbindOk(buf);\n\n   case 3276810:\n    return decodeQueueDeclare(buf);\n\n   case 3276811:\n    return decodeQueueDeclareOk(buf);\n\n   case 3276820:\n    return decodeQueueBind(buf);\n\n   case 3276821:\n    return decodeQueueBindOk(buf);\n\n   case 3276830:\n    return decodeQueuePurge(buf);\n\n   case 3276831:\n    return decodeQueuePurgeOk(buf);\n\n   case 3276840:\n    return decodeQueueDelete(buf);\n\n   case 3276841:\n    return decodeQueueDeleteOk(buf);\n\n   case 3276850:\n    return decodeQueueUnbind(buf);\n\n   case 3276851:\n    return decodeQueueUnbindOk(buf);\n\n   case 5898250:\n    return decodeTxSelect(buf);\n\n   case 5898251:\n    return decodeTxSelectOk(buf);\n\n   case 5898260:\n    return decodeTxCommit(buf);\n\n   case 5898261:\n    return decodeTxCommitOk(buf);\n\n   case 5898270:\n    return decodeTxRollback(buf);\n\n   case 5898271:\n    return decodeTxRollbackOk(buf);\n\n   case 5570570:\n    return decodeConfirmSelect(buf);\n\n   case 5570571:\n    return decodeConfirmSelectOk(buf);\n\n   case 60:\n    return decodeBasicProperties(buf);\n\n   default:\n    throw new Error(\"Unknown class/method ID\");\n  }\n};\n\nmodule.exports.encodeMethod = function(id, channel, fields) {\n  switch (id) {\n   case 3932170:\n    return encodeBasicQos(channel, fields);\n\n   case 3932171:\n    return encodeBasicQosOk(channel, fields);\n\n   case 3932180:\n    return encodeBasicConsume(channel, fields);\n\n   case 3932181:\n    return encodeBasicConsumeOk(channel, fields);\n\n   case 3932190:\n    return encodeBasicCancel(channel, fields);\n\n   case 3932191:\n    return encodeBasicCancelOk(channel, fields);\n\n   case 3932200:\n    return encodeBasicPublish(channel, fields);\n\n   case 3932210:\n    return encodeBasicReturn(channel, fields);\n\n   case 3932220:\n    return encodeBasicDeliver(channel, fields);\n\n   case 3932230:\n    return encodeBasicGet(channel, fields);\n\n   case 3932231:\n    return encodeBasicGetOk(channel, fields);\n\n   case 3932232:\n    return encodeBasicGetEmpty(channel, fields);\n\n   case 3932240:\n    return encodeBasicAck(channel, fields);\n\n   case 3932250:\n    return encodeBasicReject(channel, fields);\n\n   case 3932260:\n    return encodeBasicRecoverAsync(channel, fields);\n\n   case 3932270:\n    return encodeBasicRecover(channel, fields);\n\n   case 3932271:\n    return encodeBasicRecoverOk(channel, fields);\n\n   case 3932280:\n    return encodeBasicNack(channel, fields);\n\n   case 655370:\n    return encodeConnectionStart(channel, fields);\n\n   case 655371:\n    return encodeConnectionStartOk(channel, fields);\n\n   case 655380:\n    return encodeConnectionSecure(channel, fields);\n\n   case 655381:\n    return encodeConnectionSecureOk(channel, fields);\n\n   case 655390:\n    return encodeConnectionTune(channel, fields);\n\n   case 655391:\n    return encodeConnectionTuneOk(channel, fields);\n\n   case 655400:\n    return encodeConnectionOpen(channel, fields);\n\n   case 655401:\n    return encodeConnectionOpenOk(channel, fields);\n\n   case 655410:\n    return encodeConnectionClose(channel, fields);\n\n   case 655411:\n    return encodeConnectionCloseOk(channel, fields);\n\n   case 655420:\n    return encodeConnectionBlocked(channel, fields);\n\n   case 655421:\n    return encodeConnectionUnblocked(channel, fields);\n\n   case 655430:\n    return encodeConnectionUpdateSecret(channel, fields);\n\n   case 655431:\n    return encodeConnectionUpdateSecretOk(channel, fields);\n\n   case 1310730:\n    return encodeChannelOpen(channel, fields);\n\n   case 1310731:\n    return encodeChannelOpenOk(channel, fields);\n\n   case 1310740:\n    return encodeChannelFlow(channel, fields);\n\n   case 1310741:\n    return encodeChannelFlowOk(channel, fields);\n\n   case 1310760:\n    return encodeChannelClose(channel, fields);\n\n   case 1310761:\n    return encodeChannelCloseOk(channel, fields);\n\n   case 1966090:\n    return encodeAccessRequest(channel, fields);\n\n   case 1966091:\n    return encodeAccessRequestOk(channel, fields);\n\n   case 2621450:\n    return encodeExchangeDeclare(channel, fields);\n\n   case 2621451:\n    return encodeExchangeDeclareOk(channel, fields);\n\n   case 2621460:\n    return encodeExchangeDelete(channel, fields);\n\n   case 2621461:\n    return encodeExchangeDeleteOk(channel, fields);\n\n   case 2621470:\n    return encodeExchangeBind(channel, fields);\n\n   case 2621471:\n    return encodeExchangeBindOk(channel, fields);\n\n   case 2621480:\n    return encodeExchangeUnbind(channel, fields);\n\n   case 2621491:\n    return encodeExchangeUnbindOk(channel, fields);\n\n   case 3276810:\n    return encodeQueueDeclare(channel, fields);\n\n   case 3276811:\n    return encodeQueueDeclareOk(channel, fields);\n\n   case 3276820:\n    return encodeQueueBind(channel, fields);\n\n   case 3276821:\n    return encodeQueueBindOk(channel, fields);\n\n   case 3276830:\n    return encodeQueuePurge(channel, fields);\n\n   case 3276831:\n    return encodeQueuePurgeOk(channel, fields);\n\n   case 3276840:\n    return encodeQueueDelete(channel, fields);\n\n   case 3276841:\n    return encodeQueueDeleteOk(channel, fields);\n\n   case 3276850:\n    return encodeQueueUnbind(channel, fields);\n\n   case 3276851:\n    return encodeQueueUnbindOk(channel, fields);\n\n   case 5898250:\n    return encodeTxSelect(channel, fields);\n\n   case 5898251:\n    return encodeTxSelectOk(channel, fields);\n\n   case 5898260:\n    return encodeTxCommit(channel, fields);\n\n   case 5898261:\n    return encodeTxCommitOk(channel, fields);\n\n   case 5898270:\n    return encodeTxRollback(channel, fields);\n\n   case 5898271:\n    return encodeTxRollbackOk(channel, fields);\n\n   case 5570570:\n    return encodeConfirmSelect(channel, fields);\n\n   case 5570571:\n    return encodeConfirmSelectOk(channel, fields);\n\n   default:\n    throw new Error(\"Unknown class/method ID\");\n  }\n};\n\nmodule.exports.encodeProperties = function(id, channel, size, fields) {\n  switch (id) {\n   case 60:\n    return encodeBasicProperties(channel, size, fields);\n\n   default:\n    throw new Error(\"Unknown class/properties ID\");\n  }\n};\n\nmodule.exports.info = function(id) {\n  switch (id) {\n   case 3932170:\n    return methodInfoBasicQos;\n\n   case 3932171:\n    return methodInfoBasicQosOk;\n\n   case 3932180:\n    return methodInfoBasicConsume;\n\n   case 3932181:\n    return methodInfoBasicConsumeOk;\n\n   case 3932190:\n    return methodInfoBasicCancel;\n\n   case 3932191:\n    return methodInfoBasicCancelOk;\n\n   case 3932200:\n    return methodInfoBasicPublish;\n\n   case 3932210:\n    return methodInfoBasicReturn;\n\n   case 3932220:\n    return methodInfoBasicDeliver;\n\n   case 3932230:\n    return methodInfoBasicGet;\n\n   case 3932231:\n    return methodInfoBasicGetOk;\n\n   case 3932232:\n    return methodInfoBasicGetEmpty;\n\n   case 3932240:\n    return methodInfoBasicAck;\n\n   case 3932250:\n    return methodInfoBasicReject;\n\n   case 3932260:\n    return methodInfoBasicRecoverAsync;\n\n   case 3932270:\n    return methodInfoBasicRecover;\n\n   case 3932271:\n    return methodInfoBasicRecoverOk;\n\n   case 3932280:\n    return methodInfoBasicNack;\n\n   case 655370:\n    return methodInfoConnectionStart;\n\n   case 655371:\n    return methodInfoConnectionStartOk;\n\n   case 655380:\n    return methodInfoConnectionSecure;\n\n   case 655381:\n    return methodInfoConnectionSecureOk;\n\n   case 655390:\n    return methodInfoConnectionTune;\n\n   case 655391:\n    return methodInfoConnectionTuneOk;\n\n   case 655400:\n    return methodInfoConnectionOpen;\n\n   case 655401:\n    return methodInfoConnectionOpenOk;\n\n   case 655410:\n    return methodInfoConnectionClose;\n\n   case 655411:\n    return methodInfoConnectionCloseOk;\n\n   case 655420:\n    return methodInfoConnectionBlocked;\n\n   case 655421:\n    return methodInfoConnectionUnblocked;\n\n   case 655430:\n    return methodInfoConnectionUpdateSecret;\n\n   case 655431:\n    return methodInfoConnectionUpdateSecretOk;\n\n   case 1310730:\n    return methodInfoChannelOpen;\n\n   case 1310731:\n    return methodInfoChannelOpenOk;\n\n   case 1310740:\n    return methodInfoChannelFlow;\n\n   case 1310741:\n    return methodInfoChannelFlowOk;\n\n   case 1310760:\n    return methodInfoChannelClose;\n\n   case 1310761:\n    return methodInfoChannelCloseOk;\n\n   case 1966090:\n    return methodInfoAccessRequest;\n\n   case 1966091:\n    return methodInfoAccessRequestOk;\n\n   case 2621450:\n    return methodInfoExchangeDeclare;\n\n   case 2621451:\n    return methodInfoExchangeDeclareOk;\n\n   case 2621460:\n    return methodInfoExchangeDelete;\n\n   case 2621461:\n    return methodInfoExchangeDeleteOk;\n\n   case 2621470:\n    return methodInfoExchangeBind;\n\n   case 2621471:\n    return methodInfoExchangeBindOk;\n\n   case 2621480:\n    return methodInfoExchangeUnbind;\n\n   case 2621491:\n    return methodInfoExchangeUnbindOk;\n\n   case 3276810:\n    return methodInfoQueueDeclare;\n\n   case 3276811:\n    return methodInfoQueueDeclareOk;\n\n   case 3276820:\n    return methodInfoQueueBind;\n\n   case 3276821:\n    return methodInfoQueueBindOk;\n\n   case 3276830:\n    return methodInfoQueuePurge;\n\n   case 3276831:\n    return methodInfoQueuePurgeOk;\n\n   case 3276840:\n    return methodInfoQueueDelete;\n\n   case 3276841:\n    return methodInfoQueueDeleteOk;\n\n   case 3276850:\n    return methodInfoQueueUnbind;\n\n   case 3276851:\n    return methodInfoQueueUnbindOk;\n\n   case 5898250:\n    return methodInfoTxSelect;\n\n   case 5898251:\n    return methodInfoTxSelectOk;\n\n   case 5898260:\n    return methodInfoTxCommit;\n\n   case 5898261:\n    return methodInfoTxCommitOk;\n\n   case 5898270:\n    return methodInfoTxRollback;\n\n   case 5898271:\n    return methodInfoTxRollbackOk;\n\n   case 5570570:\n    return methodInfoConfirmSelect;\n\n   case 5570571:\n    return methodInfoConfirmSelectOk;\n\n   case 60:\n    return propertiesInfoBasicProperties;\n\n   default:\n    throw new Error(\"Unknown class/method ID\");\n  }\n};\n\nmodule.exports.BasicQos = 3932170;\n\nvar methodInfoBasicQos = module.exports.methodInfoBasicQos = {\n  id: 3932170,\n  classId: 60,\n  methodId: 10,\n  name: \"BasicQos\",\n  args: [ {\n    type: \"long\",\n    name: \"prefetchSize\",\n    default: 0\n  }, {\n    type: \"short\",\n    name: \"prefetchCount\",\n    default: 0\n  }, {\n    type: \"bit\",\n    name: \"global\",\n    default: !1\n  } ]\n};\n\nmodule.exports.BasicQosOk = 3932171;\n\nvar methodInfoBasicQosOk = module.exports.methodInfoBasicQosOk = {\n  id: 3932171,\n  classId: 60,\n  methodId: 11,\n  name: \"BasicQosOk\",\n  args: []\n};\n\nmodule.exports.BasicConsume = 3932180;\n\nvar methodInfoBasicConsume = module.exports.methodInfoBasicConsume = {\n  id: 3932180,\n  classId: 60,\n  methodId: 20,\n  name: \"BasicConsume\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    default: \"\"\n  }, {\n    type: \"shortstr\",\n    name: \"consumerTag\",\n    default: \"\"\n  }, {\n    type: \"bit\",\n    name: \"noLocal\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"noAck\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"exclusive\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    default: !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    default: {}\n  } ]\n};\n\nmodule.exports.BasicConsumeOk = 3932181;\n\nvar methodInfoBasicConsumeOk = module.exports.methodInfoBasicConsumeOk = {\n  id: 3932181,\n  classId: 60,\n  methodId: 21,\n  name: \"BasicConsumeOk\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"consumerTag\"\n  } ]\n};\n\nmodule.exports.BasicCancel = 3932190;\n\nvar methodInfoBasicCancel = module.exports.methodInfoBasicCancel = {\n  id: 3932190,\n  classId: 60,\n  methodId: 30,\n  name: \"BasicCancel\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"consumerTag\"\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    default: !1\n  } ]\n};\n\nmodule.exports.BasicCancelOk = 3932191;\n\nvar methodInfoBasicCancelOk = module.exports.methodInfoBasicCancelOk = {\n  id: 3932191,\n  classId: 60,\n  methodId: 31,\n  name: \"BasicCancelOk\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"consumerTag\"\n  } ]\n};\n\nmodule.exports.BasicPublish = 3932200;\n\nvar methodInfoBasicPublish = module.exports.methodInfoBasicPublish = {\n  id: 3932200,\n  classId: 60,\n  methodId: 40,\n  name: \"BasicPublish\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\",\n    default: \"\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\",\n    default: \"\"\n  }, {\n    type: \"bit\",\n    name: \"mandatory\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"immediate\",\n    default: !1\n  } ]\n};\n\nmodule.exports.BasicReturn = 3932210;\n\nvar methodInfoBasicReturn = module.exports.methodInfoBasicReturn = {\n  id: 3932210,\n  classId: 60,\n  methodId: 50,\n  name: \"BasicReturn\",\n  args: [ {\n    type: \"short\",\n    name: \"replyCode\"\n  }, {\n    type: \"shortstr\",\n    name: \"replyText\",\n    default: \"\"\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\"\n  } ]\n};\n\nmodule.exports.BasicDeliver = 3932220;\n\nvar methodInfoBasicDeliver = module.exports.methodInfoBasicDeliver = {\n  id: 3932220,\n  classId: 60,\n  methodId: 60,\n  name: \"BasicDeliver\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"consumerTag\"\n  }, {\n    type: \"longlong\",\n    name: \"deliveryTag\"\n  }, {\n    type: \"bit\",\n    name: \"redelivered\",\n    default: !1\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\"\n  } ]\n};\n\nmodule.exports.BasicGet = 3932230;\n\nvar methodInfoBasicGet = module.exports.methodInfoBasicGet = {\n  id: 3932230,\n  classId: 60,\n  methodId: 70,\n  name: \"BasicGet\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    default: \"\"\n  }, {\n    type: \"bit\",\n    name: \"noAck\",\n    default: !1\n  } ]\n};\n\nmodule.exports.BasicGetOk = 3932231;\n\nvar methodInfoBasicGetOk = module.exports.methodInfoBasicGetOk = {\n  id: 3932231,\n  classId: 60,\n  methodId: 71,\n  name: \"BasicGetOk\",\n  args: [ {\n    type: \"longlong\",\n    name: \"deliveryTag\"\n  }, {\n    type: \"bit\",\n    name: \"redelivered\",\n    default: !1\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\"\n  }, {\n    type: \"long\",\n    name: \"messageCount\"\n  } ]\n};\n\nmodule.exports.BasicGetEmpty = 3932232;\n\nvar methodInfoBasicGetEmpty = module.exports.methodInfoBasicGetEmpty = {\n  id: 3932232,\n  classId: 60,\n  methodId: 72,\n  name: \"BasicGetEmpty\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"clusterId\",\n    default: \"\"\n  } ]\n};\n\nmodule.exports.BasicAck = 3932240;\n\nvar methodInfoBasicAck = module.exports.methodInfoBasicAck = {\n  id: 3932240,\n  classId: 60,\n  methodId: 80,\n  name: \"BasicAck\",\n  args: [ {\n    type: \"longlong\",\n    name: \"deliveryTag\",\n    default: 0\n  }, {\n    type: \"bit\",\n    name: \"multiple\",\n    default: !1\n  } ]\n};\n\nmodule.exports.BasicReject = 3932250;\n\nvar methodInfoBasicReject = module.exports.methodInfoBasicReject = {\n  id: 3932250,\n  classId: 60,\n  methodId: 90,\n  name: \"BasicReject\",\n  args: [ {\n    type: \"longlong\",\n    name: \"deliveryTag\"\n  }, {\n    type: \"bit\",\n    name: \"requeue\",\n    default: !0\n  } ]\n};\n\nmodule.exports.BasicRecoverAsync = 3932260;\n\nvar methodInfoBasicRecoverAsync = module.exports.methodInfoBasicRecoverAsync = {\n  id: 3932260,\n  classId: 60,\n  methodId: 100,\n  name: \"BasicRecoverAsync\",\n  args: [ {\n    type: \"bit\",\n    name: \"requeue\",\n    default: !1\n  } ]\n};\n\nmodule.exports.BasicRecover = 3932270;\n\nvar methodInfoBasicRecover = module.exports.methodInfoBasicRecover = {\n  id: 3932270,\n  classId: 60,\n  methodId: 110,\n  name: \"BasicRecover\",\n  args: [ {\n    type: \"bit\",\n    name: \"requeue\",\n    default: !1\n  } ]\n};\n\nmodule.exports.BasicRecoverOk = 3932271;\n\nvar methodInfoBasicRecoverOk = module.exports.methodInfoBasicRecoverOk = {\n  id: 3932271,\n  classId: 60,\n  methodId: 111,\n  name: \"BasicRecoverOk\",\n  args: []\n};\n\nmodule.exports.BasicNack = 3932280;\n\nvar methodInfoBasicNack = module.exports.methodInfoBasicNack = {\n  id: 3932280,\n  classId: 60,\n  methodId: 120,\n  name: \"BasicNack\",\n  args: [ {\n    type: \"longlong\",\n    name: \"deliveryTag\",\n    default: 0\n  }, {\n    type: \"bit\",\n    name: \"multiple\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"requeue\",\n    default: !0\n  } ]\n};\n\nmodule.exports.ConnectionStart = 655370;\n\nvar methodInfoConnectionStart = module.exports.methodInfoConnectionStart = {\n  id: 655370,\n  classId: 10,\n  methodId: 10,\n  name: \"ConnectionStart\",\n  args: [ {\n    type: \"octet\",\n    name: \"versionMajor\",\n    default: 0\n  }, {\n    type: \"octet\",\n    name: \"versionMinor\",\n    default: 9\n  }, {\n    type: \"table\",\n    name: \"serverProperties\"\n  }, {\n    type: \"longstr\",\n    name: \"mechanisms\",\n    default: \"PLAIN\"\n  }, {\n    type: \"longstr\",\n    name: \"locales\",\n    default: \"en_US\"\n  } ]\n};\n\nmodule.exports.ConnectionStartOk = 655371;\n\nvar methodInfoConnectionStartOk = module.exports.methodInfoConnectionStartOk = {\n  id: 655371,\n  classId: 10,\n  methodId: 11,\n  name: \"ConnectionStartOk\",\n  args: [ {\n    type: \"table\",\n    name: \"clientProperties\"\n  }, {\n    type: \"shortstr\",\n    name: \"mechanism\",\n    default: \"PLAIN\"\n  }, {\n    type: \"longstr\",\n    name: \"response\"\n  }, {\n    type: \"shortstr\",\n    name: \"locale\",\n    default: \"en_US\"\n  } ]\n};\n\nmodule.exports.ConnectionSecure = 655380;\n\nvar methodInfoConnectionSecure = module.exports.methodInfoConnectionSecure = {\n  id: 655380,\n  classId: 10,\n  methodId: 20,\n  name: \"ConnectionSecure\",\n  args: [ {\n    type: \"longstr\",\n    name: \"challenge\"\n  } ]\n};\n\nmodule.exports.ConnectionSecureOk = 655381;\n\nvar methodInfoConnectionSecureOk = module.exports.methodInfoConnectionSecureOk = {\n  id: 655381,\n  classId: 10,\n  methodId: 21,\n  name: \"ConnectionSecureOk\",\n  args: [ {\n    type: \"longstr\",\n    name: \"response\"\n  } ]\n};\n\nmodule.exports.ConnectionTune = 655390;\n\nvar methodInfoConnectionTune = module.exports.methodInfoConnectionTune = {\n  id: 655390,\n  classId: 10,\n  methodId: 30,\n  name: \"ConnectionTune\",\n  args: [ {\n    type: \"short\",\n    name: \"channelMax\",\n    default: 0\n  }, {\n    type: \"long\",\n    name: \"frameMax\",\n    default: 0\n  }, {\n    type: \"short\",\n    name: \"heartbeat\",\n    default: 0\n  } ]\n};\n\nmodule.exports.ConnectionTuneOk = 655391;\n\nvar methodInfoConnectionTuneOk = module.exports.methodInfoConnectionTuneOk = {\n  id: 655391,\n  classId: 10,\n  methodId: 31,\n  name: \"ConnectionTuneOk\",\n  args: [ {\n    type: \"short\",\n    name: \"channelMax\",\n    default: 0\n  }, {\n    type: \"long\",\n    name: \"frameMax\",\n    default: 0\n  }, {\n    type: \"short\",\n    name: \"heartbeat\",\n    default: 0\n  } ]\n};\n\nmodule.exports.ConnectionOpen = 655400;\n\nvar methodInfoConnectionOpen = module.exports.methodInfoConnectionOpen = {\n  id: 655400,\n  classId: 10,\n  methodId: 40,\n  name: \"ConnectionOpen\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"virtualHost\",\n    default: \"/\"\n  }, {\n    type: \"shortstr\",\n    name: \"capabilities\",\n    default: \"\"\n  }, {\n    type: \"bit\",\n    name: \"insist\",\n    default: !1\n  } ]\n};\n\nmodule.exports.ConnectionOpenOk = 655401;\n\nvar methodInfoConnectionOpenOk = module.exports.methodInfoConnectionOpenOk = {\n  id: 655401,\n  classId: 10,\n  methodId: 41,\n  name: \"ConnectionOpenOk\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"knownHosts\",\n    default: \"\"\n  } ]\n};\n\nmodule.exports.ConnectionClose = 655410;\n\nvar methodInfoConnectionClose = module.exports.methodInfoConnectionClose = {\n  id: 655410,\n  classId: 10,\n  methodId: 50,\n  name: \"ConnectionClose\",\n  args: [ {\n    type: \"short\",\n    name: \"replyCode\"\n  }, {\n    type: \"shortstr\",\n    name: \"replyText\",\n    default: \"\"\n  }, {\n    type: \"short\",\n    name: \"classId\"\n  }, {\n    type: \"short\",\n    name: \"methodId\"\n  } ]\n};\n\nmodule.exports.ConnectionCloseOk = 655411;\n\nvar methodInfoConnectionCloseOk = module.exports.methodInfoConnectionCloseOk = {\n  id: 655411,\n  classId: 10,\n  methodId: 51,\n  name: \"ConnectionCloseOk\",\n  args: []\n};\n\nmodule.exports.ConnectionBlocked = 655420;\n\nvar methodInfoConnectionBlocked = module.exports.methodInfoConnectionBlocked = {\n  id: 655420,\n  classId: 10,\n  methodId: 60,\n  name: \"ConnectionBlocked\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"reason\",\n    default: \"\"\n  } ]\n};\n\nmodule.exports.ConnectionUnblocked = 655421;\n\nvar methodInfoConnectionUnblocked = module.exports.methodInfoConnectionUnblocked = {\n  id: 655421,\n  classId: 10,\n  methodId: 61,\n  name: \"ConnectionUnblocked\",\n  args: []\n};\n\nmodule.exports.ConnectionUpdateSecret = 655430;\n\nvar methodInfoConnectionUpdateSecret = module.exports.methodInfoConnectionUpdateSecret = {\n  id: 655430,\n  classId: 10,\n  methodId: 70,\n  name: \"ConnectionUpdateSecret\",\n  args: [ {\n    type: \"longstr\",\n    name: \"newSecret\"\n  }, {\n    type: \"shortstr\",\n    name: \"reason\"\n  } ]\n};\n\nmodule.exports.ConnectionUpdateSecretOk = 655431;\n\nvar methodInfoConnectionUpdateSecretOk = module.exports.methodInfoConnectionUpdateSecretOk = {\n  id: 655431,\n  classId: 10,\n  methodId: 71,\n  name: \"ConnectionUpdateSecretOk\",\n  args: []\n};\n\nmodule.exports.ChannelOpen = 1310730;\n\nvar methodInfoChannelOpen = module.exports.methodInfoChannelOpen = {\n  id: 1310730,\n  classId: 20,\n  methodId: 10,\n  name: \"ChannelOpen\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"outOfBand\",\n    default: \"\"\n  } ]\n};\n\nmodule.exports.ChannelOpenOk = 1310731;\n\nvar methodInfoChannelOpenOk = module.exports.methodInfoChannelOpenOk = {\n  id: 1310731,\n  classId: 20,\n  methodId: 11,\n  name: \"ChannelOpenOk\",\n  args: [ {\n    type: \"longstr\",\n    name: \"channelId\",\n    default: \"\"\n  } ]\n};\n\nmodule.exports.ChannelFlow = 1310740;\n\nvar methodInfoChannelFlow = module.exports.methodInfoChannelFlow = {\n  id: 1310740,\n  classId: 20,\n  methodId: 20,\n  name: \"ChannelFlow\",\n  args: [ {\n    type: \"bit\",\n    name: \"active\"\n  } ]\n};\n\nmodule.exports.ChannelFlowOk = 1310741;\n\nvar methodInfoChannelFlowOk = module.exports.methodInfoChannelFlowOk = {\n  id: 1310741,\n  classId: 20,\n  methodId: 21,\n  name: \"ChannelFlowOk\",\n  args: [ {\n    type: \"bit\",\n    name: \"active\"\n  } ]\n};\n\nmodule.exports.ChannelClose = 1310760;\n\nvar methodInfoChannelClose = module.exports.methodInfoChannelClose = {\n  id: 1310760,\n  classId: 20,\n  methodId: 40,\n  name: \"ChannelClose\",\n  args: [ {\n    type: \"short\",\n    name: \"replyCode\"\n  }, {\n    type: \"shortstr\",\n    name: \"replyText\",\n    default: \"\"\n  }, {\n    type: \"short\",\n    name: \"classId\"\n  }, {\n    type: \"short\",\n    name: \"methodId\"\n  } ]\n};\n\nmodule.exports.ChannelCloseOk = 1310761;\n\nvar methodInfoChannelCloseOk = module.exports.methodInfoChannelCloseOk = {\n  id: 1310761,\n  classId: 20,\n  methodId: 41,\n  name: \"ChannelCloseOk\",\n  args: []\n};\n\nmodule.exports.AccessRequest = 1966090;\n\nvar methodInfoAccessRequest = module.exports.methodInfoAccessRequest = {\n  id: 1966090,\n  classId: 30,\n  methodId: 10,\n  name: \"AccessRequest\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"realm\",\n    default: \"/data\"\n  }, {\n    type: \"bit\",\n    name: \"exclusive\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"passive\",\n    default: !0\n  }, {\n    type: \"bit\",\n    name: \"active\",\n    default: !0\n  }, {\n    type: \"bit\",\n    name: \"write\",\n    default: !0\n  }, {\n    type: \"bit\",\n    name: \"read\",\n    default: !0\n  } ]\n};\n\nmodule.exports.AccessRequestOk = 1966091;\n\nvar methodInfoAccessRequestOk = module.exports.methodInfoAccessRequestOk = {\n  id: 1966091,\n  classId: 30,\n  methodId: 11,\n  name: \"AccessRequestOk\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 1\n  } ]\n};\n\nmodule.exports.ExchangeDeclare = 2621450;\n\nvar methodInfoExchangeDeclare = module.exports.methodInfoExchangeDeclare = {\n  id: 2621450,\n  classId: 40,\n  methodId: 10,\n  name: \"ExchangeDeclare\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"type\",\n    default: \"direct\"\n  }, {\n    type: \"bit\",\n    name: \"passive\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"durable\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"autoDelete\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"internal\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    default: !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    default: {}\n  } ]\n};\n\nmodule.exports.ExchangeDeclareOk = 2621451;\n\nvar methodInfoExchangeDeclareOk = module.exports.methodInfoExchangeDeclareOk = {\n  id: 2621451,\n  classId: 40,\n  methodId: 11,\n  name: \"ExchangeDeclareOk\",\n  args: []\n};\n\nmodule.exports.ExchangeDelete = 2621460;\n\nvar methodInfoExchangeDelete = module.exports.methodInfoExchangeDelete = {\n  id: 2621460,\n  classId: 40,\n  methodId: 20,\n  name: \"ExchangeDelete\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"bit\",\n    name: \"ifUnused\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    default: !1\n  } ]\n};\n\nmodule.exports.ExchangeDeleteOk = 2621461;\n\nvar methodInfoExchangeDeleteOk = module.exports.methodInfoExchangeDeleteOk = {\n  id: 2621461,\n  classId: 40,\n  methodId: 21,\n  name: \"ExchangeDeleteOk\",\n  args: []\n};\n\nmodule.exports.ExchangeBind = 2621470;\n\nvar methodInfoExchangeBind = module.exports.methodInfoExchangeBind = {\n  id: 2621470,\n  classId: 40,\n  methodId: 30,\n  name: \"ExchangeBind\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"destination\"\n  }, {\n    type: \"shortstr\",\n    name: \"source\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\",\n    default: \"\"\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    default: !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    default: {}\n  } ]\n};\n\nmodule.exports.ExchangeBindOk = 2621471;\n\nvar methodInfoExchangeBindOk = module.exports.methodInfoExchangeBindOk = {\n  id: 2621471,\n  classId: 40,\n  methodId: 31,\n  name: \"ExchangeBindOk\",\n  args: []\n};\n\nmodule.exports.ExchangeUnbind = 2621480;\n\nvar methodInfoExchangeUnbind = module.exports.methodInfoExchangeUnbind = {\n  id: 2621480,\n  classId: 40,\n  methodId: 40,\n  name: \"ExchangeUnbind\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"destination\"\n  }, {\n    type: \"shortstr\",\n    name: \"source\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\",\n    default: \"\"\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    default: !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    default: {}\n  } ]\n};\n\nmodule.exports.ExchangeUnbindOk = 2621491;\n\nvar methodInfoExchangeUnbindOk = module.exports.methodInfoExchangeUnbindOk = {\n  id: 2621491,\n  classId: 40,\n  methodId: 51,\n  name: \"ExchangeUnbindOk\",\n  args: []\n};\n\nmodule.exports.QueueDeclare = 3276810;\n\nvar methodInfoQueueDeclare = module.exports.methodInfoQueueDeclare = {\n  id: 3276810,\n  classId: 50,\n  methodId: 10,\n  name: \"QueueDeclare\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    default: \"\"\n  }, {\n    type: \"bit\",\n    name: \"passive\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"durable\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"exclusive\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"autoDelete\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    default: !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    default: {}\n  } ]\n};\n\nmodule.exports.QueueDeclareOk = 3276811;\n\nvar methodInfoQueueDeclareOk = module.exports.methodInfoQueueDeclareOk = {\n  id: 3276811,\n  classId: 50,\n  methodId: 11,\n  name: \"QueueDeclareOk\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"queue\"\n  }, {\n    type: \"long\",\n    name: \"messageCount\"\n  }, {\n    type: \"long\",\n    name: \"consumerCount\"\n  } ]\n};\n\nmodule.exports.QueueBind = 3276820;\n\nvar methodInfoQueueBind = module.exports.methodInfoQueueBind = {\n  id: 3276820,\n  classId: 50,\n  methodId: 20,\n  name: \"QueueBind\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    default: \"\"\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\",\n    default: \"\"\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    default: !1\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    default: {}\n  } ]\n};\n\nmodule.exports.QueueBindOk = 3276821;\n\nvar methodInfoQueueBindOk = module.exports.methodInfoQueueBindOk = {\n  id: 3276821,\n  classId: 50,\n  methodId: 21,\n  name: \"QueueBindOk\",\n  args: []\n};\n\nmodule.exports.QueuePurge = 3276830;\n\nvar methodInfoQueuePurge = module.exports.methodInfoQueuePurge = {\n  id: 3276830,\n  classId: 50,\n  methodId: 30,\n  name: \"QueuePurge\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    default: \"\"\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    default: !1\n  } ]\n};\n\nmodule.exports.QueuePurgeOk = 3276831;\n\nvar methodInfoQueuePurgeOk = module.exports.methodInfoQueuePurgeOk = {\n  id: 3276831,\n  classId: 50,\n  methodId: 31,\n  name: \"QueuePurgeOk\",\n  args: [ {\n    type: \"long\",\n    name: \"messageCount\"\n  } ]\n};\n\nmodule.exports.QueueDelete = 3276840;\n\nvar methodInfoQueueDelete = module.exports.methodInfoQueueDelete = {\n  id: 3276840,\n  classId: 50,\n  methodId: 40,\n  name: \"QueueDelete\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    default: \"\"\n  }, {\n    type: \"bit\",\n    name: \"ifUnused\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"ifEmpty\",\n    default: !1\n  }, {\n    type: \"bit\",\n    name: \"nowait\",\n    default: !1\n  } ]\n};\n\nmodule.exports.QueueDeleteOk = 3276841;\n\nvar methodInfoQueueDeleteOk = module.exports.methodInfoQueueDeleteOk = {\n  id: 3276841,\n  classId: 50,\n  methodId: 41,\n  name: \"QueueDeleteOk\",\n  args: [ {\n    type: \"long\",\n    name: \"messageCount\"\n  } ]\n};\n\nmodule.exports.QueueUnbind = 3276850;\n\nvar methodInfoQueueUnbind = module.exports.methodInfoQueueUnbind = {\n  id: 3276850,\n  classId: 50,\n  methodId: 50,\n  name: \"QueueUnbind\",\n  args: [ {\n    type: \"short\",\n    name: \"ticket\",\n    default: 0\n  }, {\n    type: \"shortstr\",\n    name: \"queue\",\n    default: \"\"\n  }, {\n    type: \"shortstr\",\n    name: \"exchange\"\n  }, {\n    type: \"shortstr\",\n    name: \"routingKey\",\n    default: \"\"\n  }, {\n    type: \"table\",\n    name: \"arguments\",\n    default: {}\n  } ]\n};\n\nmodule.exports.QueueUnbindOk = 3276851;\n\nvar methodInfoQueueUnbindOk = module.exports.methodInfoQueueUnbindOk = {\n  id: 3276851,\n  classId: 50,\n  methodId: 51,\n  name: \"QueueUnbindOk\",\n  args: []\n};\n\nmodule.exports.TxSelect = 5898250;\n\nvar methodInfoTxSelect = module.exports.methodInfoTxSelect = {\n  id: 5898250,\n  classId: 90,\n  methodId: 10,\n  name: \"TxSelect\",\n  args: []\n};\n\nmodule.exports.TxSelectOk = 5898251;\n\nvar methodInfoTxSelectOk = module.exports.methodInfoTxSelectOk = {\n  id: 5898251,\n  classId: 90,\n  methodId: 11,\n  name: \"TxSelectOk\",\n  args: []\n};\n\nmodule.exports.TxCommit = 5898260;\n\nvar methodInfoTxCommit = module.exports.methodInfoTxCommit = {\n  id: 5898260,\n  classId: 90,\n  methodId: 20,\n  name: \"TxCommit\",\n  args: []\n};\n\nmodule.exports.TxCommitOk = 5898261;\n\nvar methodInfoTxCommitOk = module.exports.methodInfoTxCommitOk = {\n  id: 5898261,\n  classId: 90,\n  methodId: 21,\n  name: \"TxCommitOk\",\n  args: []\n};\n\nmodule.exports.TxRollback = 5898270;\n\nvar methodInfoTxRollback = module.exports.methodInfoTxRollback = {\n  id: 5898270,\n  classId: 90,\n  methodId: 30,\n  name: \"TxRollback\",\n  args: []\n};\n\nmodule.exports.TxRollbackOk = 5898271;\n\nvar methodInfoTxRollbackOk = module.exports.methodInfoTxRollbackOk = {\n  id: 5898271,\n  classId: 90,\n  methodId: 31,\n  name: \"TxRollbackOk\",\n  args: []\n};\n\nmodule.exports.ConfirmSelect = 5570570;\n\nvar methodInfoConfirmSelect = module.exports.methodInfoConfirmSelect = {\n  id: 5570570,\n  classId: 85,\n  methodId: 10,\n  name: \"ConfirmSelect\",\n  args: [ {\n    type: \"bit\",\n    name: \"nowait\",\n    default: !1\n  } ]\n};\n\nmodule.exports.ConfirmSelectOk = 5570571;\n\nvar methodInfoConfirmSelectOk = module.exports.methodInfoConfirmSelectOk = {\n  id: 5570571,\n  classId: 85,\n  methodId: 11,\n  name: \"ConfirmSelectOk\",\n  args: []\n};\n\nmodule.exports.BasicProperties = 60;\n\nvar propertiesInfoBasicProperties = module.exports.propertiesInfoBasicProperties = {\n  id: 60,\n  name: \"BasicProperties\",\n  args: [ {\n    type: \"shortstr\",\n    name: \"contentType\"\n  }, {\n    type: \"shortstr\",\n    name: \"contentEncoding\"\n  }, {\n    type: \"table\",\n    name: \"headers\"\n  }, {\n    type: \"octet\",\n    name: \"deliveryMode\"\n  }, {\n    type: \"octet\",\n    name: \"priority\"\n  }, {\n    type: \"shortstr\",\n    name: \"correlationId\"\n  }, {\n    type: \"shortstr\",\n    name: \"replyTo\"\n  }, {\n    type: \"shortstr\",\n    name: \"expiration\"\n  }, {\n    type: \"shortstr\",\n    name: \"messageId\"\n  }, {\n    type: \"timestamp\",\n    name: \"timestamp\"\n  }, {\n    type: \"shortstr\",\n    name: \"type\"\n  }, {\n    type: \"shortstr\",\n    name: \"userId\"\n  }, {\n    type: \"shortstr\",\n    name: \"appId\"\n  }, {\n    type: \"shortstr\",\n    name: \"clusterId\"\n  } ]\n};//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZGVmcy5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ2E7O0FBRWI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNEdBQTRHO0FBQzNJO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw2R0FBNkc7QUFDNUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDBIQUEwSDtBQUMxSjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsZ0lBQWdJO0FBQ2hLO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywyRkFBMkY7QUFDM0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0dBQXNHO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2SEFBNkg7QUFDN0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDZIQUE2SDtBQUM3SjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0hBQStIO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0dBQXNHO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyw4SEFBOEg7QUFDOUo7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0SEFBNEg7QUFDNUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esc0dBQXNHO0FBQ3RHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEhBQTBIO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0dBQXNHO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBIQUEwSDtBQUMxSDtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRIQUE0SDtBQUM1SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3R0FBd0c7QUFDeEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhIQUE4SDtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiwyR0FBMkc7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMkdBQTJHO0FBQzFJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtEQUFrRCwyRkFBMkY7QUFDN0k7QUFDQTtBQUNBLGtEQUFrRCx3RkFBd0Y7QUFDMUk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsNEdBQTRHO0FBQzNJO0FBQ0E7QUFDQTtBQUNBLCtCQUErQiw0R0FBNEc7QUFDM0k7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRkFBK0Y7QUFDL0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQyw4SEFBOEg7QUFDbks7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBLHFDQUFxQywySEFBMkg7QUFDaEs7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVGQUF1RjtBQUN2RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzRkFBc0Y7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLDBHQUEwRztBQUN6STtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isd0dBQXdHO0FBQ3ZJO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix5R0FBeUc7QUFDeEk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0IsMEdBQTBHO0FBQ3pJO0FBQ0E7QUFDQTtBQUNBLCtCQUErQix3R0FBd0c7QUFDdkk7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHlHQUF5RztBQUN4STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsZ0lBQWdJO0FBQ2pLO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQyxpSUFBaUk7QUFDaks7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsK0hBQStIO0FBQy9KO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsOEhBQThIO0FBQzlKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHNHQUFzRztBQUN0RztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9HQUFvRztBQUNwRztBQUNBO0FBQ0E7QUFDQTtBQUNBLHFHQUFxRztBQUNyRztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJIQUEySDtBQUMzSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUZBQXVGO0FBQ3ZGO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SDtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhIQUE4SDtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsNkNBQTZDLDBGQUEwRjtBQUN2STtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDhIQUE4SDtBQUM5SjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxzR0FBc0c7QUFDdEc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvR0FBb0c7QUFDcEc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxR0FBcUc7QUFDckc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQywwSEFBMEg7QUFDL0o7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNHQUFzRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0Esc0NBQXNDLHlIQUF5SDtBQUMvSjtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMkZBQTJGO0FBQzNIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0JBQStCLHNHQUFzRztBQUNySTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0dBQXNHO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdIO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrSEFBK0g7QUFDL0o7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJGQUEyRjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzR0FBc0c7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0hBQXdIO0FBQ3hIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrSEFBK0g7QUFDL0o7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJGQUEyRjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzR0FBc0c7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywwSEFBMEg7QUFDMUo7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJGQUEyRjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzR0FBc0c7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1SEFBdUg7QUFDdkg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUdBQXlHO0FBQ3pHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEdBQTBHO0FBQzFHO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEhBQTBIO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrSEFBK0g7QUFDL0o7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJGQUEyRjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzR0FBc0c7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEhBQTBIO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0dBQXNHO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEhBQTBIO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQkFBK0Isc0dBQXNHO0FBQ3JJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5R0FBeUc7QUFDekc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0MsMEhBQTBIO0FBQzFKO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEhBQTBIO0FBQzFIO0FBQ0E7QUFDQTtBQUNBLGdDQUFnQywrSEFBK0g7QUFDL0o7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLDJGQUEyRjtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtCQUErQixzR0FBc0c7QUFDckk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtIQUErSDtBQUMvSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxtSUFBbUk7QUFDbkk7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0ZBQXdGO0FBQ3hGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMkdBQTJHO0FBQzNHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsdUdBQXVHO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUlBQWlJO0FBQ2pJO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJIQUEySDtBQUMzSDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4SEFBOEg7QUFDOUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNkhBQTZIO0FBQzdIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdHQUF3RztBQUN4RztBQUNBO0FBQ0E7QUFDQTtBQUNBLHdIQUF3SDtBQUN4SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwwSEFBMEg7QUFDMUg7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUhBQXlIO0FBQ3pIO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZIQUE2SDtBQUM3SDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSxZQUFZLG1CQUFPLENBQUMsMERBQVMsVUFBVSxtQkFBTyxDQUFDLG1GQUFrQixxSUFBcUk7O0FBRXRNLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0IscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwyQkFBMkI7QUFDM0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2Qix5QkFBeUIsaUNBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSx5QkFBeUI7O0FBRXpCLDJCQUEyQixtQ0FBbUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0IsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSw2QkFBNkI7O0FBRTdCLCtCQUErQix1Q0FBdUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsMEJBQTBCOztBQUUxQiw0QkFBNEIsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSw0QkFBNEI7O0FBRTVCLDhCQUE4QixzQ0FBc0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsMkJBQTJCOztBQUUzQiw2QkFBNkIscUNBQXFDO0FBQ2xFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLDBCQUEwQjs7QUFFMUIsNEJBQTRCLG9DQUFvQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLDJCQUEyQjs7QUFFM0IsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsdUJBQXVCOztBQUV2Qix5QkFBeUIsaUNBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSx5QkFBeUI7O0FBRXpCLDJCQUEyQixtQ0FBbUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLDRCQUE0Qjs7QUFFNUIsOEJBQThCLHNDQUFzQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLHVCQUF1Qjs7QUFFdkIseUJBQXlCLGlDQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSwwQkFBMEI7O0FBRTFCLDRCQUE0QixvQ0FBb0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLGdDQUFnQzs7QUFFaEMsa0NBQWtDLDBDQUEwQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLDJCQUEyQjs7QUFFM0IsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLDZCQUE2Qjs7QUFFN0IsK0JBQStCLHVDQUF1QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsd0JBQXdCOztBQUV4QiwwQkFBMEIsa0NBQWtDO0FBQzVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSw4QkFBOEI7O0FBRTlCLGdDQUFnQyx3Q0FBd0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLGdDQUFnQzs7QUFFaEMsa0NBQWtDLDBDQUEwQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsK0JBQStCOztBQUUvQixpQ0FBaUMseUNBQXlDO0FBQzFFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLGlDQUFpQzs7QUFFakMsbUNBQW1DLDJDQUEyQztBQUM5RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSw2QkFBNkI7O0FBRTdCLCtCQUErQix1Q0FBdUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLCtCQUErQjs7QUFFL0IsaUNBQWlDLHlDQUF5QztBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsNkJBQTZCOztBQUU3QiwrQkFBK0IsdUNBQXVDO0FBQ3RFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSwrQkFBK0I7O0FBRS9CLGlDQUFpQyx5Q0FBeUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSw4QkFBOEI7O0FBRTlCLGdDQUFnQyx3Q0FBd0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSxnQ0FBZ0M7O0FBRWhDLGtDQUFrQywwQ0FBMEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGdDQUFnQzs7QUFFaEMsa0NBQWtDLDBDQUEwQztBQUM1RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLGtDQUFrQzs7QUFFbEMsb0NBQW9DLDRDQUE0QztBQUNoRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEscUNBQXFDOztBQUVyQyx1Q0FBdUMsK0NBQStDO0FBQ3RGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsdUNBQXVDOztBQUV2Qyx5Q0FBeUMsaURBQWlEO0FBQzFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSwwQkFBMEI7O0FBRTFCLDRCQUE0QixvQ0FBb0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSw0QkFBNEI7O0FBRTVCLDhCQUE4QixzQ0FBc0M7QUFDcEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSwwQkFBMEI7O0FBRTFCLDRCQUE0QixvQ0FBb0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsNEJBQTRCOztBQUU1Qiw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLDJCQUEyQjs7QUFFM0IsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLDZCQUE2Qjs7QUFFN0IsK0JBQStCLHVDQUF1QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1Qiw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSw4QkFBOEI7O0FBRTlCLGdDQUFnQyx3Q0FBd0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSw4QkFBOEI7O0FBRTlCLGdDQUFnQyx3Q0FBd0M7QUFDeEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSxnQ0FBZ0M7O0FBRWhDLGtDQUFrQywwQ0FBMEM7QUFDNUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0IsK0JBQStCLHVDQUF1QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSwrQkFBK0I7O0FBRS9CLGlDQUFpQyx5Q0FBeUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0IsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSw2QkFBNkI7O0FBRTdCLCtCQUErQix1Q0FBdUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDZCQUE2Qjs7QUFFN0IsK0JBQStCLHVDQUF1QztBQUN0RTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSwrQkFBK0I7O0FBRS9CLGlDQUFpQyx5Q0FBeUM7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0IsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSw2QkFBNkI7O0FBRTdCLCtCQUErQix1Q0FBdUM7QUFDdEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLHdCQUF3Qjs7QUFFeEIsMEJBQTBCLGtDQUFrQztBQUM1RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLDBCQUEwQjs7QUFFMUIsNEJBQTRCLG9DQUFvQztBQUNoRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QiwyQkFBMkIsbUNBQW1DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSwyQkFBMkI7O0FBRTNCLDZCQUE2QixxQ0FBcUM7QUFDbEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsMEJBQTBCOztBQUUxQiw0QkFBNEIsb0NBQW9DO0FBQ2hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLDRCQUE0Qjs7QUFFNUIsOEJBQThCLHNDQUFzQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjs7QUFFQSwwQkFBMEI7O0FBRTFCLDRCQUE0QixvQ0FBb0M7QUFDaEU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKOztBQUVBLDRCQUE0Qjs7QUFFNUIsOEJBQThCLHNDQUFzQztBQUNwRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCOztBQUV2Qix5QkFBeUIsaUNBQWlDO0FBQzFEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCLDJCQUEyQixtQ0FBbUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLHVCQUF1Qjs7QUFFdkIseUJBQXlCLGlDQUFpQztBQUMxRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QiwyQkFBMkIsbUNBQW1DO0FBQzlEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSx5QkFBeUI7O0FBRXpCLDJCQUEyQixtQ0FBbUM7QUFDOUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLDJCQUEyQjs7QUFFM0IsNkJBQTZCLHFDQUFxQztBQUNsRTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsNEJBQTRCOztBQUU1Qiw4QkFBOEIsc0NBQXNDO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxJQUFJO0FBQ0o7O0FBRUEsOEJBQThCOztBQUU5QixnQ0FBZ0Msd0NBQXdDO0FBQ3hFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw4QkFBOEI7O0FBRTlCLG9DQUFvQyw0Q0FBNEM7QUFDaEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsSUFBSTtBQUNKIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMi8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9kZWZzLmpzPzkyZjAiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqIEBwcmVzZXJ2ZSBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGJ5IHRoZSBzY3JpcHRcbiAqIC4uL2Jpbi9nZW5lcmF0ZS1kZWZzLmpzLCB3aGljaCBpcyBub3QgaW4gZ2VuZXJhbCBpbmNsdWRlZCBpbiBhXG4gKiBkaXN0cmlidXRpb24sIGJ1dCBpcyBhdmFpbGFibGUgaW4gdGhlIHNvdXJjZSByZXBvc2l0b3J5IGUuZy4gYXRcbiAqIGh0dHBzOi8vZ2l0aHViLmNvbS9zcXVhcmVtby9hbXFwLm5vZGUvXG4gKi9cblwidXNlIHN0cmljdFwiO1xuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY1FvcyhidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHByZWZldGNoU2l6ZTogdm9pZCAwLFxuICAgIHByZWZldGNoQ291bnQ6IHZvaWQgMCxcbiAgICBnbG9iYWw6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBmaWVsZHMucHJlZmV0Y2hTaXplID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMucHJlZmV0Y2hDb3VudCA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmdsb2JhbCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNRb3MoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE5KTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIxNzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnByZWZldGNoU2l6ZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdwcmVmZXRjaFNpemUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGZpZWxkcy5wcmVmZXRjaENvdW50O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3ByZWZldGNoQ291bnQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5nbG9iYWw7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY1Fvc09rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUW9zT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE3MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljQ29uc3VtZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgcXVldWU6IHZvaWQgMCxcbiAgICBjb25zdW1lclRhZzogdm9pZCAwLFxuICAgIG5vTG9jYWw6IHZvaWQgMCxcbiAgICBub0Fjazogdm9pZCAwLFxuICAgIGV4Y2x1c2l2ZTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuY29uc3VtZXJUYWcgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub0xvY2FsID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm9BY2sgPSB2YWw7XG4gIHZhbCA9ICEhKDQgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5leGNsdXNpdmUgPSB2YWw7XG4gIHZhbCA9ICEhKDggJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIG9mZnNldCsrO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljQ29uc3VtZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdxdWV1ZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBxdWV1ZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29uc3VtZXJUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgY29uc3VtZXJUYWdfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNvbnN1bWVyVGFnX2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE3ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE4MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcXVldWVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGNvbnN1bWVyVGFnX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YWwgPSBmaWVsZHMubm9Mb2NhbDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMubm9BY2s7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAyKTtcbiAgdmFsID0gZmllbGRzLmV4Y2x1c2l2ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDQpO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gOCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJpdHMgPSAwO1xuICBvZmZzZXQgKz0gYXJndW1lbnRzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNDb25zdW1lT2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNvbnN1bWVyVGFnOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jb25zdW1lclRhZyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNDb25zdW1lT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2NvbnN1bWVyVGFnJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvbnN1bWVyVGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGNvbnN1bWVyVGFnX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBjb25zdW1lclRhZ19sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMTgxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gY29uc3VtZXJUYWdfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBjb25zdW1lclRhZ19sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNDYW5jZWwoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNvbnN1bWVyVGFnOiB2b2lkIDAsXG4gICAgbm93YWl0OiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5jb25zdW1lclRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNDYW5jZWwoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjb25zdW1lclRhZydcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb25zdW1lclRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjb25zdW1lclRhZ19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE0ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE5MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGNvbnN1bWVyVGFnX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNDYW5jZWxPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY29uc3VtZXJUYWc6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNvbnN1bWVyVGFnID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0NhbmNlbE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjb25zdW1lclRhZydcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb25zdW1lclRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjb25zdW1lclRhZ19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gY29uc3VtZXJUYWdfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEzICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjE5MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuY29uc3VtZXJUYWc7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGNvbnN1bWVyVGFnX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gY29uc3VtZXJUYWdfbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUHVibGlzaChidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgZXhjaGFuZ2U6IHZvaWQgMCxcbiAgICByb3V0aW5nS2V5OiB2b2lkIDAsXG4gICAgbWFuZGF0b3J5OiB2b2lkIDAsXG4gICAgaW1tZWRpYXRlOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubWFuZGF0b3J5ID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuaW1tZWRpYXRlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY1B1Ymxpc2goY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncm91dGluZ0tleScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByb3V0aW5nS2V5X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyMDAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLm1hbmRhdG9yeTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMuaW1tZWRpYXRlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNSZXR1cm4oYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHJlcGx5Q29kZTogdm9pZCAwLFxuICAgIHJlcGx5VGV4dDogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5yZXBseUNvZGUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucmVwbHlUZXh0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmV4Y2hhbmdlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJvdXRpbmdLZXkgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUmV0dXJuKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVwbHlUZXh0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5VGV4dCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZXBseVRleHRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncm91dGluZ0tleSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyb3V0aW5nS2V5JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJvdXRpbmdLZXlfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE3ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjIxMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVwbHlDb2RlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncmVwbHlDb2RlJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5Q29kZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnJlcGx5VGV4dDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJlcGx5VGV4dF9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNEZWxpdmVyKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBjb25zdW1lclRhZzogdm9pZCAwLFxuICAgIGRlbGl2ZXJ5VGFnOiB2b2lkIDAsXG4gICAgcmVkZWxpdmVyZWQ6IHZvaWQgMCxcbiAgICBleGNoYW5nZTogdm9pZCAwLFxuICAgIHJvdXRpbmdLZXk6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNvbnN1bWVyVGFnID0gdmFsO1xuICB2YWwgPSBpbnRzLnJlYWRVSW50NjRCRShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICBmaWVsZHMuZGVsaXZlcnlUYWcgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5yZWRlbGl2ZXJlZCA9IHZhbDtcbiAgb2Zmc2V0Kys7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZXhjaGFuZ2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucm91dGluZ0tleSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNEZWxpdmVyKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmNvbnN1bWVyVGFnO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY29uc3VtZXJUYWcnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29uc3VtZXJUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgY29uc3VtZXJUYWdfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNvbnN1bWVyVGFnX2xlbjtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyb3V0aW5nS2V5J1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjQgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjIwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jb25zdW1lclRhZztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gY29uc3VtZXJUYWdfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBjb25zdW1lclRhZ19sZW47XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeVRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2RlbGl2ZXJ5VGFnJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2RlbGl2ZXJ5VGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICB2YWwgPSBmaWVsZHMucmVkZWxpdmVyZWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNHZXQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIHF1ZXVlOiB2b2lkIDAsXG4gICAgbm9BY2s6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnF1ZXVlID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm9BY2sgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljR2V0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3F1ZXVlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHF1ZXVlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBxdWV1ZV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTYgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjMwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBxdWV1ZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLm5vQWNrO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNHZXRPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgZGVsaXZlcnlUYWc6IHZvaWQgMCxcbiAgICByZWRlbGl2ZXJlZDogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIG1lc3NhZ2VDb3VudDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIGZpZWxkcy5kZWxpdmVyeVRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLnJlZGVsaXZlcmVkID0gdmFsO1xuICBvZmZzZXQrKztcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBmaWVsZHMubWVzc2FnZUNvdW50ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0dldE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyb3V0aW5nS2V5J1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjcgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjMxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeVRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2RlbGl2ZXJ5VGFnJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2RlbGl2ZXJ5VGFnJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCB2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA4O1xuICB2YWwgPSBmaWVsZHMucmVkZWxpdmVyZWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5tZXNzYWdlQ291bnQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdtZXNzYWdlQ291bnQnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnbWVzc2FnZUNvdW50JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljR2V0RW1wdHkoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNsdXN0ZXJJZDogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuY2x1c3RlcklkID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0dldEVtcHR5KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY2x1c3RlcklkO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NsdXN0ZXJJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBjbHVzdGVySWRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGNsdXN0ZXJJZF9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjMyLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jbHVzdGVySWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBjbHVzdGVySWRfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBjbHVzdGVySWRfbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljQWNrKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgZGVsaXZlcnlUYWc6IHZvaWQgMCxcbiAgICBtdWx0aXBsZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIGZpZWxkcy5kZWxpdmVyeVRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm11bHRpcGxlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY0FjayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMjEpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjI0MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMuZGVsaXZlcnlUYWc7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZGVsaXZlcnlUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGludHMud3JpdGVVSW50NjRCRShidWZmZXIsIHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIHZhbCA9IGZpZWxkcy5tdWx0aXBsZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUmVqZWN0KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgZGVsaXZlcnlUYWc6IHZvaWQgMCxcbiAgICByZXF1ZXVlOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gaW50cy5yZWFkVUludDY0QkUoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gODtcbiAgZmllbGRzLmRlbGl2ZXJ5VGFnID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMucmVxdWV1ZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNSZWplY3QoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIxKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyNTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmRlbGl2ZXJ5VGFnO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZGVsaXZlcnlUYWcnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZGVsaXZlcnlUYWcnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGludHMud3JpdGVVSW50NjRCRShidWZmZXIsIHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIHZhbCA9IGZpZWxkcy5yZXF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQmFzaWNSZWNvdmVyQXN5bmMoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGZpZWxkcyA9IHtcbiAgICByZXF1ZXVlOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlclswXSk7XG4gIGZpZWxkcy5yZXF1ZXVlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVCYXNpY1JlY292ZXJBc3luYyhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjI2MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVxdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUmVjb3ZlcihidWZmZXIpIHtcbiAgdmFyIHZhbCwgZmllbGRzID0ge1xuICAgIHJlcXVldWU6IHZvaWQgMFxuICB9O1xuICB2YWwgPSAhISgxICYgYnVmZmVyWzBdKTtcbiAgZmllbGRzLnJlcXVldWUgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUmVjb3ZlcihjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzkzMjI3MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVxdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUmVjb3Zlck9rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZUJhc2ljUmVjb3Zlck9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIyNzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVCYXNpY05hY2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBkZWxpdmVyeVRhZzogdm9pZCAwLFxuICAgIG11bHRpcGxlOiB2b2lkIDAsXG4gICAgcmVxdWV1ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGludHMucmVhZFVJbnQ2NEJFKGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDg7XG4gIGZpZWxkcy5kZWxpdmVyeVRhZyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm11bHRpcGxlID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMucmVxdWV1ZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNOYWNrKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgzOTMyMjgwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeVRhZztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdkZWxpdmVyeVRhZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgaW50cy53cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgdmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gODtcbiAgdmFsID0gZmllbGRzLm11bHRpcGxlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIHZhbCA9IGZpZWxkcy5yZXF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblN0YXJ0KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB2ZXJzaW9uTWFqb3I6IHZvaWQgMCxcbiAgICB2ZXJzaW9uTWlub3I6IHZvaWQgMCxcbiAgICBzZXJ2ZXJQcm9wZXJ0aWVzOiB2b2lkIDAsXG4gICAgbWVjaGFuaXNtczogdm9pZCAwLFxuICAgIGxvY2FsZXM6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXJbb2Zmc2V0XTtcbiAgb2Zmc2V0Kys7XG4gIGZpZWxkcy52ZXJzaW9uTWFqb3IgPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlcltvZmZzZXRdO1xuICBvZmZzZXQrKztcbiAgZmllbGRzLnZlcnNpb25NaW5vciA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuc2VydmVyUHJvcGVydGllcyA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLm1lY2hhbmlzbXMgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5sb2NhbGVzID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uU3RhcnQoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5zZXJ2ZXJQcm9wZXJ0aWVzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnc2VydmVyUHJvcGVydGllcydcIik7XG4gIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnc2VydmVyUHJvcGVydGllcycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgc2VydmVyUHJvcGVydGllc19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IHNlcnZlclByb3BlcnRpZXNfZW5jb2RlZC5sZW5ndGg7XG4gIHZhbCA9IGZpZWxkcy5tZWNoYW5pc21zO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IEJ1ZmZlci5mcm9tKFwiUExBSU5cIik7IGVsc2UgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZWNoYW5pc21zJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIEJ1ZmZlclwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdmFsLmxlbmd0aDtcbiAgdmFsID0gZmllbGRzLmxvY2FsZXM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gQnVmZmVyLmZyb20oXCJlbl9VU1wiKTsgZWxzZSBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2xvY2FsZXMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgQnVmZmVyXCIpO1xuICB2YXJ5aW5nU2l6ZSArPSB2YWwubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIyICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1MzcwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy52ZXJzaW9uTWFqb3I7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndmVyc2lvbk1ham9yJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50OCh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBmaWVsZHMudmVyc2lvbk1pbm9yO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDk7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3ZlcnNpb25NaW5vcicgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDgodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgb2Zmc2V0ICs9IHNlcnZlclByb3BlcnRpZXNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgdmFsID0gZmllbGRzLm1lY2hhbmlzbXM7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBCdWZmZXIuZnJvbShcIlBMQUlOXCIpKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gbGVuO1xuICB2YWwgPSBmaWVsZHMubG9jYWxlcztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IEJ1ZmZlci5mcm9tKFwiZW5fVVNcIikpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwuY29weShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSBsZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblN0YXJ0T2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIGNsaWVudFByb3BlcnRpZXM6IHZvaWQgMCxcbiAgICBtZWNoYW5pc206IHZvaWQgMCxcbiAgICByZXNwb25zZTogdm9pZCAwLFxuICAgIGxvY2FsZTogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGRlY29kZUZpZWxkcyhidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNsaWVudFByb3BlcnRpZXMgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMubWVjaGFuaXNtID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucmVzcG9uc2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMubG9jYWxlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uU3RhcnRPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMDtcbiAgdmFsID0gZmllbGRzLmNsaWVudFByb3BlcnRpZXM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjbGllbnRQcm9wZXJ0aWVzJ1wiKTtcbiAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjbGllbnRQcm9wZXJ0aWVzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIGxlbiA9IGVuY29kZVRhYmxlKFNDUkFUQ0gsIHZhbCwgc2NyYXRjaE9mZnNldCk7XG4gIHZhciBjbGllbnRQcm9wZXJ0aWVzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gY2xpZW50UHJvcGVydGllc19lbmNvZGVkLmxlbmd0aDtcbiAgdmFsID0gZmllbGRzLm1lY2hhbmlzbTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlBMQUlOXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21lY2hhbmlzbScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBtZWNoYW5pc21fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IG1lY2hhbmlzbV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yZXNwb25zZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ3Jlc3BvbnNlJ1wiKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZXNwb25zZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gIHZhcnlpbmdTaXplICs9IHZhbC5sZW5ndGg7XG4gIHZhbCA9IGZpZWxkcy5sb2NhbGU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJlbl9VU1wiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdsb2NhbGUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgbG9jYWxlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBsb2NhbGVfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE4ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1MzcxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIG9mZnNldCArPSBjbGllbnRQcm9wZXJ0aWVzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIHZhbCA9IGZpZWxkcy5tZWNoYW5pc207XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlBMQUlOXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IG1lY2hhbmlzbV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IG1lY2hhbmlzbV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yZXNwb25zZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IEJ1ZmZlci5mcm9tKHZvaWQgMCkpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwuY29weShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSBsZW47XG4gIHZhbCA9IGZpZWxkcy5sb2NhbGU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcImVuX1VTXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGxvY2FsZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IGxvY2FsZV9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblNlY3VyZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY2hhbGxlbmdlOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNoYWxsZW5nZSA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvblNlY3VyZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY2hhbGxlbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY2hhbGxlbmdlJ1wiKTtcbiAgaWYgKCFCdWZmZXIuaXNCdWZmZXIodmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjaGFsbGVuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgQnVmZmVyXCIpO1xuICB2YXJ5aW5nU2l6ZSArPSB2YWwubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1MzgwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5jaGFsbGVuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBCdWZmZXIuZnJvbSh2b2lkIDApKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbm5lY3Rpb25TZWN1cmVPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgcmVzcG9uc2U6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucmVzcG9uc2UgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25TZWN1cmVPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVzcG9uc2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyZXNwb25zZSdcIik7XG4gIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVzcG9uc2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgQnVmZmVyXCIpO1xuICB2YXJ5aW5nU2l6ZSArPSB2YWwubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNjU1MzgxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5yZXNwb25zZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IEJ1ZmZlci5mcm9tKHZvaWQgMCkpO1xuICBsZW4gPSB2YWwubGVuZ3RoO1xuICBidWZmZXIud3JpdGVVSW50MzJCRShsZW4sIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwuY29weShidWZmZXIsIG9mZnNldCk7XG4gIG9mZnNldCArPSBsZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblR1bmUoYnVmZmVyKSB7XG4gIHZhciB2YWwsIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBjaGFubmVsTWF4OiB2b2lkIDAsXG4gICAgZnJhbWVNYXg6IHZvaWQgMCxcbiAgICBoZWFydGJlYXQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMuY2hhbm5lbE1heCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLmZyYW1lTWF4ID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMuaGVhcnRiZWF0ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uVHVuZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMCk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTUzOTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmNoYW5uZWxNYXg7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2hhbm5lbE1heCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLmZyYW1lTWF4O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2ZyYW1lTWF4JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBmaWVsZHMuaGVhcnRiZWF0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2hlYXJ0YmVhdCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uVHVuZU9rKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY2hhbm5lbE1heDogdm9pZCAwLFxuICAgIGZyYW1lTWF4OiB2b2lkIDAsXG4gICAgaGVhcnRiZWF0OiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmNoYW5uZWxNYXggPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGZpZWxkcy5mcmFtZU1heCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmhlYXJ0YmVhdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvblR1bmVPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMCk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTUzOTEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmNoYW5uZWxNYXg7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2hhbm5lbE1heCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLmZyYW1lTWF4O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2ZyYW1lTWF4JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBmaWVsZHMuaGVhcnRiZWF0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2hlYXJ0YmVhdCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uT3BlbihidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdmlydHVhbEhvc3Q6IHZvaWQgMCxcbiAgICBjYXBhYmlsaXRpZXM6IHZvaWQgMCxcbiAgICBpbnNpc3Q6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnZpcnR1YWxIb3N0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNhcGFiaWxpdGllcyA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmluc2lzdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvbk9wZW4oY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMudmlydHVhbEhvc3Q7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCIvXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3ZpcnR1YWxIb3N0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHZpcnR1YWxIb3N0X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSB2aXJ0dWFsSG9zdF9sZW47XG4gIHZhbCA9IGZpZWxkcy5jYXBhYmlsaXRpZXM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2FwYWJpbGl0aWVzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGNhcGFiaWxpdGllc19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gY2FwYWJpbGl0aWVzX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNSArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQwMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudmlydHVhbEhvc3Q7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIi9cIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gdmlydHVhbEhvc3RfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSB2aXJ0dWFsSG9zdF9sZW47XG4gIHZhbCA9IGZpZWxkcy5jYXBhYmlsaXRpZXM7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSBjYXBhYmlsaXRpZXNfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBjYXBhYmlsaXRpZXNfbGVuO1xuICB2YWwgPSBmaWVsZHMuaW5zaXN0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvbk9wZW5PayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAga25vd25Ib3N0czogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMua25vd25Ib3N0cyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvbk9wZW5PayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmtub3duSG9zdHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAna25vd25Ib3N0cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBrbm93bkhvc3RzX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBrbm93bkhvc3RzX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQwMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMua25vd25Ib3N0cztcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGtub3duSG9zdHNfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBrbm93bkhvc3RzX2xlbjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uQ2xvc2UoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHJlcGx5Q29kZTogdm9pZCAwLFxuICAgIHJlcGx5VGV4dDogdm9pZCAwLFxuICAgIGNsYXNzSWQ6IHZvaWQgMCxcbiAgICBtZXRob2RJZDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5yZXBseUNvZGUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucmVwbHlUZXh0ID0gdmFsO1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMuY2xhc3NJZCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLm1ldGhvZElkID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uQ2xvc2UoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5yZXBseVRleHQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVwbHlUZXh0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJlcGx5VGV4dF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcmVwbHlUZXh0X2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxOSArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQxMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVwbHlDb2RlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAncmVwbHlDb2RlJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5Q29kZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnJlcGx5VGV4dDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJlcGx5VGV4dF9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhbCA9IGZpZWxkcy5jbGFzc0lkO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnY2xhc3NJZCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjbGFzc0lkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMubWV0aG9kSWQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdtZXRob2RJZCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZXRob2RJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uQ2xvc2VPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uQ2xvc2VPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTU0MTEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uQmxvY2tlZChidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgcmVhc29uOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yZWFzb24gPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbm5lY3Rpb25CbG9ja2VkKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVhc29uO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlYXNvbicgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZWFzb25fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlYXNvbl9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg2NTU0MjAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnJlYXNvbjtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJlYXNvbl9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJlYXNvbl9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29ubmVjdGlvblVuYmxvY2tlZChidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uVW5ibG9ja2VkKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQyMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbm5lY3Rpb25VcGRhdGVTZWNyZXQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIG5ld1NlY3JldDogdm9pZCAwLFxuICAgIHJlYXNvbjogdm9pZCAwXG4gIH07XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5uZXdTZWNyZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucmVhc29uID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDb25uZWN0aW9uVXBkYXRlU2VjcmV0KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5uZXdTZWNyZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICduZXdTZWNyZXQnXCIpO1xuICBpZiAoIUJ1ZmZlci5pc0J1ZmZlcih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ25ld1NlY3JldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBCdWZmZXJcIik7XG4gIHZhcnlpbmdTaXplICs9IHZhbC5sZW5ndGg7XG4gIHZhbCA9IGZpZWxkcy5yZWFzb247XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyZWFzb24nXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVhc29uJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJlYXNvbl9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcmVhc29uX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQzMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMubmV3U2VjcmV0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gQnVmZmVyLmZyb20odm9pZCAwKSk7XG4gIGxlbiA9IHZhbC5sZW5ndGg7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKGxlbiwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgdmFsID0gZmllbGRzLnJlYXNvbjtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcmVhc29uX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcmVhc29uX2xlbjtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVDb25uZWN0aW9uVXBkYXRlU2VjcmV0T2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29ubmVjdGlvblVwZGF0ZVNlY3JldE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDY1NTQzMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxPcGVuKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBvdXRPZkJhbmQ6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLm91dE9mQmFuZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhbm5lbE9wZW4oY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDA7XG4gIHZhbCA9IGZpZWxkcy5vdXRPZkJhbmQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnb3V0T2ZCYW5kJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIG91dE9mQmFuZF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gb3V0T2ZCYW5kX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDEzMTA3MzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLm91dE9mQmFuZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IG91dE9mQmFuZF9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IG91dE9mQmFuZF9sZW47XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ2hhbm5lbE9wZW5PayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgY2hhbm5lbElkOiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmNoYW5uZWxJZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhbm5lbE9wZW5PayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMuY2hhbm5lbElkO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IEJ1ZmZlci5mcm9tKFwiXCIpOyBlbHNlIGlmICghQnVmZmVyLmlzQnVmZmVyKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY2hhbm5lbElkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIEJ1ZmZlclwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdmFsLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDEzMTA3MzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLmNoYW5uZWxJZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IEJ1ZmZlci5mcm9tKFwiXCIpKTtcbiAgbGVuID0gdmFsLmxlbmd0aDtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUobGVuLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxGbG93KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBmaWVsZHMgPSB7XG4gICAgYWN0aXZlOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlclswXSk7XG4gIGZpZWxkcy5hY3RpdmUgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNoYW5uZWxGbG93KGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzQwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5hY3RpdmU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdhY3RpdmUnXCIpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ2hhbm5lbEZsb3dPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgZmllbGRzID0ge1xuICAgIGFjdGl2ZTogdm9pZCAwXG4gIH07XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbMF0pO1xuICBmaWVsZHMuYWN0aXZlID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVDaGFubmVsRmxvd09rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMyk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzQxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5hY3RpdmU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdhY3RpdmUnXCIpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ2hhbm5lbENsb3NlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICByZXBseUNvZGU6IHZvaWQgMCxcbiAgICByZXBseVRleHQ6IHZvaWQgMCxcbiAgICBjbGFzc0lkOiB2b2lkIDAsXG4gICAgbWV0aG9kSWQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMucmVwbHlDb2RlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJlcGx5VGV4dCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLmNsYXNzSWQgPSB2YWw7XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy5tZXRob2RJZCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ2hhbm5lbENsb3NlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVwbHlUZXh0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JlcGx5VGV4dCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZXBseVRleHRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJlcGx5VGV4dF9sZW47XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTkgKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxMzEwNzYwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy5yZXBseUNvZGU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdyZXBseUNvZGUnXCIpO1xuICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVwbHlDb2RlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMucmVwbHlUZXh0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcmVwbHlUZXh0X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcmVwbHlUZXh0X2xlbjtcbiAgdmFsID0gZmllbGRzLmNsYXNzSWQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjbGFzc0lkJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NsYXNzSWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5tZXRob2RJZDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ21ldGhvZElkJ1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21ldGhvZElkJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNoYW5uZWxDbG9zZU9rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNoYW5uZWxDbG9zZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDEzMTA3NjEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVBY2Nlc3NSZXF1ZXN0KGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICByZWFsbTogdm9pZCAwLFxuICAgIGV4Y2x1c2l2ZTogdm9pZCAwLFxuICAgIHBhc3NpdmU6IHZvaWQgMCxcbiAgICBhY3RpdmU6IHZvaWQgMCxcbiAgICB3cml0ZTogdm9pZCAwLFxuICAgIHJlYWQ6IHZvaWQgMFxuICB9O1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJlYWxtID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuZXhjbHVzaXZlID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMucGFzc2l2ZSA9IHZhbDtcbiAgdmFsID0gISEoNCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmFjdGl2ZSA9IHZhbDtcbiAgdmFsID0gISEoOCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLndyaXRlID0gdmFsO1xuICB2YWwgPSAhISgxNiAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLnJlYWQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUFjY2Vzc1JlcXVlc3QoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucmVhbG07XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCIvZGF0YVwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyZWFsbScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByZWFsbV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcmVhbG1fbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE0ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMTk2NjA5MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucmVhbG07XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIi9kYXRhXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJlYWxtX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcmVhbG1fbGVuO1xuICB2YWwgPSBmaWVsZHMuZXhjbHVzaXZlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIHZhbCA9IGZpZWxkcy5wYXNzaXZlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIHZhbCA9IGZpZWxkcy5hY3RpdmU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMCk7XG4gIHZhbCAmJiAoYml0cyArPSA0KTtcbiAgdmFsID0gZmllbGRzLndyaXRlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gOCk7XG4gIHZhbCA9IGZpZWxkcy5yZWFkO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITApO1xuICB2YWwgJiYgKGJpdHMgKz0gMTYpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUFjY2Vzc1JlcXVlc3RPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUFjY2Vzc1JlcXVlc3RPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNCk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgxOTY2MDkxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMTsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUV4Y2hhbmdlRGVjbGFyZShidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgdGlja2V0OiB2b2lkIDAsXG4gICAgZXhjaGFuZ2U6IHZvaWQgMCxcbiAgICB0eXBlOiB2b2lkIDAsXG4gICAgcGFzc2l2ZTogdm9pZCAwLFxuICAgIGR1cmFibGU6IHZvaWQgMCxcbiAgICBhdXRvRGVsZXRlOiB2b2lkIDAsXG4gICAgaW50ZXJuYWw6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMCxcbiAgICBhcmd1bWVudHM6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmV4Y2hhbmdlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnR5cGUgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5wYXNzaXZlID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuZHVyYWJsZSA9IHZhbDtcbiAgdmFsID0gISEoNCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmF1dG9EZWxldGUgPSB2YWw7XG4gIHZhbCA9ICEhKDggJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5pbnRlcm5hbCA9IHZhbDtcbiAgdmFsID0gISEoMTYgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIG9mZnNldCsrO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUV4Y2hhbmdlRGVjbGFyZShjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy50eXBlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiZGlyZWN0XCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3R5cGUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgdHlwZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gdHlwZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5hcmd1bWVudHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0ge307IGVsc2UgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcmd1bWVudHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGFyZ3VtZW50c19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGFyZ3VtZW50c19lbmNvZGVkLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNyArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDI2MjE0NTAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy50eXBlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJkaXJlY3RcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gdHlwZV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHR5cGVfbGVuO1xuICB2YWwgPSBmaWVsZHMucGFzc2l2ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMuZHVyYWJsZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDIpO1xuICB2YWwgPSBmaWVsZHMuYXV0b0RlbGV0ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDQpO1xuICB2YWwgPSBmaWVsZHMuaW50ZXJuYWw7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSA4KTtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDE2KTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIG9mZnNldCArPSBhcmd1bWVudHNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVFeGNoYW5nZURlY2xhcmVPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZURlY2xhcmVPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDUxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VEZWxldGUoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgaWZVbnVzZWQ6IHZvaWQgMCxcbiAgICBub3dhaXQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQxNkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICBmaWVsZHMudGlja2V0ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmV4Y2hhbmdlID0gdmFsO1xuICB2YWwgPSAhISgxICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuaWZVbnVzZWQgPSB2YWw7XG4gIHZhbCA9ICEhKDIgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUV4Y2hhbmdlRGVsZXRlKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDI2MjE0NjAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5pZlVudXNlZDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VEZWxldGVPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZURlbGV0ZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDI2MjE0NjEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVFeGNoYW5nZUJpbmQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIGRlc3RpbmF0aW9uOiB2b2lkIDAsXG4gICAgc291cmNlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZGVzdGluYXRpb24gPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuc291cmNlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJvdXRpbmdLZXkgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIG9mZnNldCsrO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUV4Y2hhbmdlQmluZChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIGxlbiwgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYml0cyA9IDAsIHZhcnlpbmdTaXplID0gMCwgc2NyYXRjaE9mZnNldCA9IDA7XG4gIHZhbCA9IGZpZWxkcy5kZXN0aW5hdGlvbjtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2Rlc3RpbmF0aW9uJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2Rlc3RpbmF0aW9uJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGRlc3RpbmF0aW9uX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBkZXN0aW5hdGlvbl9sZW47XG4gIHZhbCA9IGZpZWxkcy5zb3VyY2U7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdzb3VyY2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnc291cmNlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHNvdXJjZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gc291cmNlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncm91dGluZ0tleScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByb3V0aW5nS2V5X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE4ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMjYyMTQ3MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLmRlc3RpbmF0aW9uO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSBkZXN0aW5hdGlvbl9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IGRlc3RpbmF0aW9uX2xlbjtcbiAgdmFsID0gZmllbGRzLnNvdXJjZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gc291cmNlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gc291cmNlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSBcIlwiKTtcbiAgYnVmZmVyW29mZnNldF0gPSByb3V0aW5nS2V5X2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5ub3dhaXQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIG9mZnNldCArPSBhcmd1bWVudHNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVFeGNoYW5nZUJpbmRPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVFeGNoYW5nZUJpbmRPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDcxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlRXhjaGFuZ2VVbmJpbmQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIGRlc3RpbmF0aW9uOiB2b2lkIDAsXG4gICAgc291cmNlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZGVzdGluYXRpb24gPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuc291cmNlID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gIG9mZnNldCsrO1xuICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLnJvdXRpbmdLZXkgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIG9mZnNldCsrO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZUV4Y2hhbmdlVW5iaW5kKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMDtcbiAgdmFsID0gZmllbGRzLmRlc3RpbmF0aW9uO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZGVzdGluYXRpb24nXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZGVzdGluYXRpb24nIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZGVzdGluYXRpb25fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGRlc3RpbmF0aW9uX2xlbjtcbiAgdmFsID0gZmllbGRzLnNvdXJjZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ3NvdXJjZSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdzb3VyY2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgc291cmNlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBzb3VyY2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSBcIlwiOyBlbHNlIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdyb3V0aW5nS2V5JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHJvdXRpbmdLZXlfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHJvdXRpbmdLZXlfbGVuO1xuICB2YWwgPSBmaWVsZHMuYXJndW1lbnRzO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IHt9OyBlbHNlIGlmIChcIm9iamVjdFwiICE9IHR5cGVvZiB2YWwpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnYXJndW1lbnRzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gIGxlbiA9IGVuY29kZVRhYmxlKFNDUkFUQ0gsIHZhbCwgc2NyYXRjaE9mZnNldCk7XG4gIHZhciBhcmd1bWVudHNfZW5jb2RlZCA9IFNDUkFUQ0guc2xpY2Uoc2NyYXRjaE9mZnNldCwgc2NyYXRjaE9mZnNldCArIGxlbik7XG4gIHNjcmF0Y2hPZmZzZXQgKz0gbGVuO1xuICB2YXJ5aW5nU2l6ZSArPSBhcmd1bWVudHNfZW5jb2RlZC5sZW5ndGg7XG4gIHZhciBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTggKyB2YXJ5aW5nU2l6ZSk7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDgwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIHZhbCA9IGZpZWxkcy50aWNrZXQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gMDsgZWxzZSBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAndGlja2V0JyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIG51bWJlciAoYnV0IG5vdCBOYU4pXCIpO1xuICBidWZmZXIud3JpdGVVSW50MTZCRSh2YWwsIG9mZnNldCk7XG4gIG9mZnNldCArPSAyO1xuICB2YWwgPSBmaWVsZHMuZGVzdGluYXRpb247XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGRlc3RpbmF0aW9uX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZGVzdGluYXRpb25fbGVuO1xuICB2YWwgPSBmaWVsZHMuc291cmNlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gdm9pZCAwKTtcbiAgYnVmZmVyW29mZnNldF0gPSBzb3VyY2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBzb3VyY2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBiaXRzID0gMDtcbiAgb2Zmc2V0ICs9IGFyZ3VtZW50c19lbmNvZGVkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUV4Y2hhbmdlVW5iaW5kT2soYnVmZmVyKSB7XG4gIHJldHVybiB7fTtcbn1cblxuZnVuY3Rpb24gZW5jb2RlRXhjaGFuZ2VVbmJpbmRPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSgyNjIxNDkxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVEZWNsYXJlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBxdWV1ZTogdm9pZCAwLFxuICAgIHBhc3NpdmU6IHZvaWQgMCxcbiAgICBkdXJhYmxlOiB2b2lkIDAsXG4gICAgZXhjbHVzaXZlOiB2b2lkIDAsXG4gICAgYXV0b0RlbGV0ZTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5wYXNzaXZlID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuZHVyYWJsZSA9IHZhbDtcbiAgdmFsID0gISEoNCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmV4Y2x1c2l2ZSA9IHZhbDtcbiAgdmFsID0gISEoOCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmF1dG9EZWxldGUgPSB2YWw7XG4gIHZhbCA9ICEhKDE2ICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMubm93YWl0ID0gdmFsO1xuICBvZmZzZXQrKztcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZGVjb2RlRmllbGRzKGJ1ZmZlci5zdWJhcnJheShvZmZzZXQsIG9mZnNldCArIGxlbikpO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuYXJndW1lbnRzID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZURlY2xhcmUoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBsZW4sIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzI3NjgxMCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcXVldWVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5wYXNzaXZlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIHZhbCA9IGZpZWxkcy5kdXJhYmxlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMik7XG4gIHZhbCA9IGZpZWxkcy5leGNsdXNpdmU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSA0KTtcbiAgdmFsID0gZmllbGRzLmF1dG9EZWxldGU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSA4KTtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDE2KTtcbiAgYnVmZmVyW29mZnNldF0gPSBiaXRzO1xuICBvZmZzZXQrKztcbiAgYml0cyA9IDA7XG4gIG9mZnNldCArPSBhcmd1bWVudHNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVRdWV1ZURlY2xhcmVPayhidWZmZXIpIHtcbiAgdmFyIHZhbCwgbGVuLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgcXVldWU6IHZvaWQgMCxcbiAgICBtZXNzYWdlQ291bnQ6IHZvaWQgMCxcbiAgICBjb25zdW1lckNvdW50OiB2b2lkIDBcbiAgfTtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5xdWV1ZSA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLm1lc3NhZ2VDb3VudCA9IHZhbDtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLmNvbnN1bWVyQ291bnQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlRGVjbGFyZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdxdWV1ZSdcIik7XG4gIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdxdWV1ZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciBxdWV1ZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcXVldWVfbGVuO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDIxICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzI3NjgxMSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMubWVzc2FnZUNvdW50O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnbWVzc2FnZUNvdW50J1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ21lc3NhZ2VDb3VudCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgdmFsID0gZmllbGRzLmNvbnN1bWVyQ291bnQ7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdGhyb3cgbmV3IEVycm9yKFwiTWlzc2luZyB2YWx1ZSBmb3IgbWFuZGF0b3J5IGZpZWxkICdjb25zdW1lckNvdW50J1wiKTtcbiAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvbnN1bWVyQ291bnQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVCaW5kKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBxdWV1ZTogdm9pZCAwLFxuICAgIGV4Y2hhbmdlOiB2b2lkIDAsXG4gICAgcm91dGluZ0tleTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwLFxuICAgIGFyZ3VtZW50czogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMuZXhjaGFuZ2UgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucm91dGluZ0tleSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgb2Zmc2V0Kys7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDMyQkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIHZhbCA9IGRlY29kZUZpZWxkcyhidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgb2Zmc2V0ICs9IGxlbjtcbiAgZmllbGRzLmFyZ3VtZW50cyA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlUXVldWVCaW5kKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwLCBzY3JhdGNoT2Zmc2V0ID0gMDtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3F1ZXVlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIHF1ZXVlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ2V4Y2hhbmdlJ1wiKTtcbiAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2V4Y2hhbmdlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgdmFyIGV4Y2hhbmdlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IFwiXCI7IGVsc2UgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3JvdXRpbmdLZXknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcm91dGluZ0tleV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgdmFyeWluZ1NpemUgKz0gcm91dGluZ0tleV9sZW47XG4gIHZhbCA9IGZpZWxkcy5hcmd1bWVudHM7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0ge307IGVsc2UgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcmd1bWVudHMnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGFuIG9iamVjdFwiKTtcbiAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgdmFyIGFyZ3VtZW50c19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgc2NyYXRjaE9mZnNldCArPSBsZW47XG4gIHZhcnlpbmdTaXplICs9IGFyZ3VtZW50c19lbmNvZGVkLmxlbmd0aDtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxOCArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4MjAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMuZXhjaGFuZ2U7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSB2b2lkIDApO1xuICBidWZmZXJbb2Zmc2V0XSA9IGV4Y2hhbmdlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gZXhjaGFuZ2VfbGVuO1xuICB2YWwgPSBmaWVsZHMucm91dGluZ0tleTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDEpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBiaXRzID0gMDtcbiAgb2Zmc2V0ICs9IGFyZ3VtZW50c19lbmNvZGVkLmNvcHkoYnVmZmVyLCBvZmZzZXQpO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlQmluZE9rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlQmluZE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4MjEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVRdWV1ZVB1cmdlKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICB0aWNrZXQ6IHZvaWQgMCxcbiAgICBxdWV1ZTogdm9pZCAwLFxuICAgIG5vd2FpdDogdm9pZCAwXG4gIH07XG4gIHZhbCA9IGJ1ZmZlci5yZWFkVUludDE2QkUob2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIGZpZWxkcy50aWNrZXQgPSB2YWw7XG4gIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgb2Zmc2V0Kys7XG4gIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICBvZmZzZXQgKz0gbGVuO1xuICBmaWVsZHMucXVldWUgPSB2YWw7XG4gIHZhbCA9ICEhKDEgJiBidWZmZXJbb2Zmc2V0XSk7XG4gIGZpZWxkcy5ub3dhaXQgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlUHVyZ2UoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4MzAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVQdXJnZU9rKGJ1ZmZlcikge1xuICB2YXIgdmFsLCBvZmZzZXQgPSAwLCBmaWVsZHMgPSB7XG4gICAgbWVzc2FnZUNvdW50OiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gNDtcbiAgZmllbGRzLm1lc3NhZ2VDb3VudCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlUXVldWVQdXJnZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2KTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4MzEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLm1lc3NhZ2VDb3VudDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ21lc3NhZ2VDb3VudCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZXNzYWdlQ291bnQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVEZWxldGUoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIHF1ZXVlOiB2b2lkIDAsXG4gICAgaWZVbnVzZWQ6IHZvaWQgMCxcbiAgICBpZkVtcHR5OiB2b2lkIDAsXG4gICAgbm93YWl0OiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5xdWV1ZSA9IHZhbDtcbiAgdmFsID0gISEoMSAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLmlmVW51c2VkID0gdmFsO1xuICB2YWwgPSAhISgyICYgYnVmZmVyW29mZnNldF0pO1xuICBmaWVsZHMuaWZFbXB0eSA9IHZhbDtcbiAgdmFsID0gISEoNCAmIGJ1ZmZlcltvZmZzZXRdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlUXVldWVEZWxldGUoY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCBiaXRzID0gMCwgdmFyeWluZ1NpemUgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxNiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4NDAsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLnRpY2tldDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSAwOyBlbHNlIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0aWNrZXQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDI7XG4gIHZhbCA9IGZpZWxkcy5xdWV1ZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IFwiXCIpO1xuICBidWZmZXJbb2Zmc2V0XSA9IHF1ZXVlX2xlbjtcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICBvZmZzZXQgKz0gcXVldWVfbGVuO1xuICB2YWwgPSBmaWVsZHMuaWZVbnVzZWQ7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAxKTtcbiAgdmFsID0gZmllbGRzLmlmRW1wdHk7XG4gIHZvaWQgMCA9PT0gdmFsICYmICh2YWwgPSAhMSk7XG4gIHZhbCAmJiAoYml0cyArPSAyKTtcbiAgdmFsID0gZmllbGRzLm5vd2FpdDtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9ICExKTtcbiAgdmFsICYmIChiaXRzICs9IDQpO1xuICBidWZmZXJbb2Zmc2V0XSA9IGJpdHM7XG4gIG9mZnNldCsrO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVF1ZXVlRGVsZXRlT2soYnVmZmVyKSB7XG4gIHZhciB2YWwsIG9mZnNldCA9IDAsIGZpZWxkcyA9IHtcbiAgICBtZXNzYWdlQ291bnQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICBmaWVsZHMubWVzc2FnZUNvdW50ID0gdmFsO1xuICByZXR1cm4gZmllbGRzO1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZURlbGV0ZU9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFsID0gbnVsbCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE2KTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4NDEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgdmFsID0gZmllbGRzLm1lc3NhZ2VDb3VudDtcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB0aHJvdyBuZXcgRXJyb3IoXCJNaXNzaW5nIHZhbHVlIGZvciBtYW5kYXRvcnkgZmllbGQgJ21lc3NhZ2VDb3VudCdcIik7XG4gIGlmIChcIm51bWJlclwiICE9IHR5cGVvZiB2YWwgfHwgaXNOYU4odmFsKSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZXNzYWdlQ291bnQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKHZhbCwgb2Zmc2V0KTtcbiAgb2Zmc2V0ICs9IDQ7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVVbmJpbmQoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGxlbiwgb2Zmc2V0ID0gMCwgZmllbGRzID0ge1xuICAgIHRpY2tldDogdm9pZCAwLFxuICAgIHF1ZXVlOiB2b2lkIDAsXG4gICAgZXhjaGFuZ2U6IHZvaWQgMCxcbiAgICByb3V0aW5nS2V5OiB2b2lkIDAsXG4gICAgYXJndW1lbnRzOiB2b2lkIDBcbiAgfTtcbiAgdmFsID0gYnVmZmVyLnJlYWRVSW50MTZCRShvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgZmllbGRzLnRpY2tldCA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5xdWV1ZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5leGNoYW5nZSA9IHZhbDtcbiAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICBvZmZzZXQrKztcbiAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5yb3V0aW5nS2V5ID0gdmFsO1xuICBsZW4gPSBidWZmZXIucmVhZFVJbnQzMkJFKG9mZnNldCk7XG4gIG9mZnNldCArPSA0O1xuICB2YWwgPSBkZWNvZGVGaWVsZHMoYnVmZmVyLnN1YmFycmF5KG9mZnNldCwgb2Zmc2V0ICsgbGVuKSk7XG4gIG9mZnNldCArPSBsZW47XG4gIGZpZWxkcy5hcmd1bWVudHMgPSB2YWw7XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbmZ1bmN0aW9uIGVuY29kZVF1ZXVlVW5iaW5kKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgbGVuLCBvZmZzZXQgPSAwLCB2YWwgPSBudWxsLCB2YXJ5aW5nU2l6ZSA9IDAsIHNjcmF0Y2hPZmZzZXQgPSAwO1xuICB2YWwgPSBmaWVsZHMucXVldWU7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncXVldWUnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgcXVldWVfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IHF1ZXVlX2xlbjtcbiAgdmFsID0gZmllbGRzLmV4Y2hhbmdlO1xuICBpZiAodm9pZCAwID09PSB2YWwpIHRocm93IG5ldyBFcnJvcihcIk1pc3NpbmcgdmFsdWUgZm9yIG1hbmRhdG9yeSBmaWVsZCAnZXhjaGFuZ2UnXCIpO1xuICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhjaGFuZ2UnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICB2YXIgZXhjaGFuZ2VfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gIHZhcnlpbmdTaXplICs9IGV4Y2hhbmdlX2xlbjtcbiAgdmFsID0gZmllbGRzLnJvdXRpbmdLZXk7XG4gIGlmICh2b2lkIDAgPT09IHZhbCkgdmFsID0gXCJcIjsgZWxzZSBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncm91dGluZ0tleScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gIHZhciByb3V0aW5nS2V5X2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICB2YXJ5aW5nU2l6ZSArPSByb3V0aW5nS2V5X2xlbjtcbiAgdmFsID0gZmllbGRzLmFyZ3VtZW50cztcbiAgaWYgKHZvaWQgMCA9PT0gdmFsKSB2YWwgPSB7fTsgZWxzZSBpZiAoXCJvYmplY3RcIiAhPSB0eXBlb2YgdmFsKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2FyZ3VtZW50cycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYW4gb2JqZWN0XCIpO1xuICBsZW4gPSBlbmNvZGVUYWJsZShTQ1JBVENILCB2YWwsIHNjcmF0Y2hPZmZzZXQpO1xuICB2YXIgYXJndW1lbnRzX2VuY29kZWQgPSBTQ1JBVENILnNsaWNlKHNjcmF0Y2hPZmZzZXQsIHNjcmF0Y2hPZmZzZXQgKyBsZW4pO1xuICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgdmFyeWluZ1NpemUgKz0gYXJndW1lbnRzX2VuY29kZWQubGVuZ3RoO1xuICB2YXIgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDE3ICsgdmFyeWluZ1NpemUpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoMzI3Njg1MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMudGlja2V0O1xuICBpZiAodm9pZCAwID09PSB2YWwpIHZhbCA9IDA7IGVsc2UgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpY2tldCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUodmFsLCBvZmZzZXQpO1xuICBvZmZzZXQgKz0gMjtcbiAgdmFsID0gZmllbGRzLnF1ZXVlO1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcXVldWVfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBxdWV1ZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5leGNoYW5nZTtcbiAgdm9pZCAwID09PSB2YWwgJiYgKHZhbCA9IHZvaWQgMCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gZXhjaGFuZ2VfbGVuO1xuICBvZmZzZXQrKztcbiAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gIG9mZnNldCArPSBleGNoYW5nZV9sZW47XG4gIHZhbCA9IGZpZWxkcy5yb3V0aW5nS2V5O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gXCJcIik7XG4gIGJ1ZmZlcltvZmZzZXRdID0gcm91dGluZ0tleV9sZW47XG4gIG9mZnNldCsrO1xuICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgb2Zmc2V0ICs9IHJvdXRpbmdLZXlfbGVuO1xuICBvZmZzZXQgKz0gYXJndW1lbnRzX2VuY29kZWQuY29weShidWZmZXIsIG9mZnNldCk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlUXVldWVVbmJpbmRPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVRdWV1ZVVuYmluZE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDMyNzY4NTEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUeFNlbGVjdChidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVUeFNlbGVjdChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1ODk4MjUwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVHhTZWxlY3RPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVUeFNlbGVjdE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDU4OTgyNTEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUeENvbW1pdChidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVUeENvbW1pdChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1ODk4MjYwLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlVHhDb21taXRPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVUeENvbW1pdE9rKGNoYW5uZWwsIGZpZWxkcykge1xuICB2YXIgb2Zmc2V0ID0gMCwgYnVmZmVyID0gQnVmZmVyLmFsbG9jKDEyKTtcbiAgYnVmZmVyWzBdID0gMTtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDU4OTgyNjEsIDcpO1xuICBvZmZzZXQgPSAxMTtcbiAgYnVmZmVyW29mZnNldF0gPSAyMDY7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKG9mZnNldCAtIDcsIDMpO1xuICByZXR1cm4gYnVmZmVyO1xufVxuXG5mdW5jdGlvbiBkZWNvZGVUeFJvbGxiYWNrKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZVR4Um9sbGJhY2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNTg5ODI3MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZVR4Um9sbGJhY2tPayhidWZmZXIpIHtcbiAgcmV0dXJuIHt9O1xufVxuXG5mdW5jdGlvbiBlbmNvZGVUeFJvbGxiYWNrT2soY2hhbm5lbCwgZmllbGRzKSB7XG4gIHZhciBvZmZzZXQgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTIpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNTg5ODI3MSwgNyk7XG4gIG9mZnNldCA9IDExO1xuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIHJldHVybiBidWZmZXI7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUNvbmZpcm1TZWxlY3QoYnVmZmVyKSB7XG4gIHZhciB2YWwsIGZpZWxkcyA9IHtcbiAgICBub3dhaXQ6IHZvaWQgMFxuICB9O1xuICB2YWwgPSAhISgxICYgYnVmZmVyWzBdKTtcbiAgZmllbGRzLm5vd2FpdCA9IHZhbDtcbiAgcmV0dXJuIGZpZWxkcztcbn1cblxuZnVuY3Rpb24gZW5jb2RlQ29uZmlybVNlbGVjdChjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIHZhbCA9IG51bGwsIGJpdHMgPSAwLCBidWZmZXIgPSBCdWZmZXIuYWxsb2MoMTMpO1xuICBidWZmZXJbMF0gPSAxO1xuICBidWZmZXIud3JpdGVVSW50MTZCRShjaGFubmVsLCAxKTtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUoNTU3MDU3MCwgNyk7XG4gIG9mZnNldCA9IDExO1xuICB2YWwgPSBmaWVsZHMubm93YWl0O1xuICB2b2lkIDAgPT09IHZhbCAmJiAodmFsID0gITEpO1xuICB2YWwgJiYgKGJpdHMgKz0gMSk7XG4gIGJ1ZmZlcltvZmZzZXRdID0gYml0cztcbiAgb2Zmc2V0Kys7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZGVjb2RlQ29uZmlybVNlbGVjdE9rKGJ1ZmZlcikge1xuICByZXR1cm4ge307XG59XG5cbmZ1bmN0aW9uIGVuY29kZUNvbmZpcm1TZWxlY3RPayhjaGFubmVsLCBmaWVsZHMpIHtcbiAgdmFyIG9mZnNldCA9IDAsIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygxMik7XG4gIGJ1ZmZlclswXSA9IDE7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGNoYW5uZWwsIDEpO1xuICBidWZmZXIud3JpdGVVSW50MzJCRSg1NTcwNTcxLCA3KTtcbiAgb2Zmc2V0ID0gMTE7XG4gIGJ1ZmZlcltvZmZzZXRdID0gMjA2O1xuICBidWZmZXIud3JpdGVVSW50MzJCRShvZmZzZXQgLSA3LCAzKTtcbiAgcmV0dXJuIGJ1ZmZlcjtcbn1cblxuZnVuY3Rpb24gZW5jb2RlQmFzaWNQcm9wZXJ0aWVzKGNoYW5uZWwsIHNpemUsIGZpZWxkcykge1xuICB2YXIgdmFsLCBsZW4sIG9mZnNldCA9IDAsIGZsYWdzID0gMCwgc2NyYXRjaE9mZnNldCA9IDAsIHZhcnlpbmdTaXplID0gMDtcbiAgdmFsID0gZmllbGRzLmNvbnRlbnRUeXBlO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdjb250ZW50VHlwZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGNvbnRlbnRUeXBlX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gY29udGVudFR5cGVfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5jb250ZW50RW5jb2Rpbmc7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NvbnRlbnRFbmNvZGluZycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGNvbnRlbnRFbmNvZGluZ19sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IGNvbnRlbnRFbmNvZGluZ19sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmhlYWRlcnM7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKFwib2JqZWN0XCIgIT0gdHlwZW9mIHZhbCkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdoZWFkZXJzJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhbiBvYmplY3RcIik7XG4gICAgbGVuID0gZW5jb2RlVGFibGUoU0NSQVRDSCwgdmFsLCBzY3JhdGNoT2Zmc2V0KTtcbiAgICB2YXIgaGVhZGVyc19lbmNvZGVkID0gU0NSQVRDSC5zbGljZShzY3JhdGNoT2Zmc2V0LCBzY3JhdGNoT2Zmc2V0ICsgbGVuKTtcbiAgICBzY3JhdGNoT2Zmc2V0ICs9IGxlbjtcbiAgICB2YXJ5aW5nU2l6ZSArPSBoZWFkZXJzX2VuY29kZWQubGVuZ3RoO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5kZWxpdmVyeU1vZGU7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2RlbGl2ZXJ5TW9kZScgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5wcmlvcml0eTtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoXCJudW1iZXJcIiAhPSB0eXBlb2YgdmFsIHx8IGlzTmFOKHZhbCkpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncHJpb3JpdHknIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgbnVtYmVyIChidXQgbm90IE5hTilcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgfVxuICB2YWwgPSBmaWVsZHMuY29ycmVsYXRpb25JZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnY29ycmVsYXRpb25JZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGNvcnJlbGF0aW9uSWRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSBjb3JyZWxhdGlvbklkX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMucmVwbHlUbztcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAncmVwbHlUbycgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIHJlcGx5VG9fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSByZXBseVRvX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuZXhwaXJhdGlvbjtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBpZiAoIShcInN0cmluZ1wiID09IHR5cGVvZiB2YWwgJiYgQnVmZmVyLmJ5dGVMZW5ndGgodmFsKSA8IDI1NikpIHRocm93IG5ldyBUeXBlRXJyb3IoXCJGaWVsZCAnZXhwaXJhdGlvbicgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGV4cGlyYXRpb25fbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSBleHBpcmF0aW9uX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMubWVzc2FnZUlkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdtZXNzYWdlSWQnIGlzIHRoZSB3cm9uZyB0eXBlOyBtdXN0IGJlIGEgc3RyaW5nICh1cCB0byAyNTUgY2hhcnMpXCIpO1xuICAgIHZhciBtZXNzYWdlSWRfbGVuID0gQnVmZmVyLmJ5dGVMZW5ndGgodmFsLCBcInV0ZjhcIik7XG4gICAgdmFyeWluZ1NpemUgKz0gMTtcbiAgICB2YXJ5aW5nU2l6ZSArPSBtZXNzYWdlSWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy50aW1lc3RhbXA7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKFwibnVtYmVyXCIgIT0gdHlwZW9mIHZhbCB8fCBpc05hTih2YWwpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3RpbWVzdGFtcCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBudW1iZXIgKGJ1dCBub3QgTmFOKVwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSA4O1xuICB9XG4gIHZhbCA9IGZpZWxkcy50eXBlO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICd0eXBlJyBpcyB0aGUgd3JvbmcgdHlwZTsgbXVzdCBiZSBhIHN0cmluZyAodXAgdG8gMjU1IGNoYXJzKVwiKTtcbiAgICB2YXIgdHlwZV9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IHR5cGVfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy51c2VySWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ3VzZXJJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIHVzZXJJZF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IHVzZXJJZF9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmFwcElkO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGlmICghKFwic3RyaW5nXCIgPT0gdHlwZW9mIHZhbCAmJiBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwpIDwgMjU2KSkgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkZpZWxkICdhcHBJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGFwcElkX2xlbiA9IEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCwgXCJ1dGY4XCIpO1xuICAgIHZhcnlpbmdTaXplICs9IDE7XG4gICAgdmFyeWluZ1NpemUgKz0gYXBwSWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5jbHVzdGVySWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgaWYgKCEoXCJzdHJpbmdcIiA9PSB0eXBlb2YgdmFsICYmIEJ1ZmZlci5ieXRlTGVuZ3RoKHZhbCkgPCAyNTYpKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiRmllbGQgJ2NsdXN0ZXJJZCcgaXMgdGhlIHdyb25nIHR5cGU7IG11c3QgYmUgYSBzdHJpbmcgKHVwIHRvIDI1NSBjaGFycylcIik7XG4gICAgdmFyIGNsdXN0ZXJJZF9sZW4gPSBCdWZmZXIuYnl0ZUxlbmd0aCh2YWwsIFwidXRmOFwiKTtcbiAgICB2YXJ5aW5nU2l6ZSArPSAxO1xuICAgIHZhcnlpbmdTaXplICs9IGNsdXN0ZXJJZF9sZW47XG4gIH1cbiAgdmFyIGJ1ZmZlciA9IEJ1ZmZlci5hbGxvYygyMiArIHZhcnlpbmdTaXplKTtcbiAgYnVmZmVyWzBdID0gMjtcbiAgYnVmZmVyLndyaXRlVUludDE2QkUoY2hhbm5lbCwgMSk7XG4gIGJ1ZmZlci53cml0ZVVJbnQzMkJFKDM5MzIxNjAsIDcpO1xuICBpbnRzLndyaXRlVUludDY0QkUoYnVmZmVyLCBzaXplLCAxMSk7XG4gIGZsYWdzID0gMDtcbiAgb2Zmc2V0ID0gMjE7XG4gIHZhbCA9IGZpZWxkcy5jb250ZW50VHlwZTtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAzMjc2ODtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IGNvbnRlbnRUeXBlX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gY29udGVudFR5cGVfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5jb250ZW50RW5jb2Rpbmc7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gMTYzODQ7XG4gICAgYnVmZmVyW29mZnNldF0gPSBjb250ZW50RW5jb2RpbmdfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSBjb250ZW50RW5jb2RpbmdfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5oZWFkZXJzO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDgxOTI7XG4gICAgb2Zmc2V0ICs9IGhlYWRlcnNfZW5jb2RlZC5jb3B5KGJ1ZmZlciwgb2Zmc2V0KTtcbiAgfVxuICB2YWwgPSBmaWVsZHMuZGVsaXZlcnlNb2RlO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDQwOTY7XG4gICAgYnVmZmVyLndyaXRlVUludDgodmFsLCBvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5wcmlvcml0eTtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAyMDQ4O1xuICAgIGJ1ZmZlci53cml0ZVVJbnQ4KHZhbCwgb2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgfVxuICB2YWwgPSBmaWVsZHMuY29ycmVsYXRpb25JZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAxMDI0O1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gY29ycmVsYXRpb25JZF9sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IGNvcnJlbGF0aW9uSWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5yZXBseVRvO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDUxMjtcbiAgICBidWZmZXJbb2Zmc2V0XSA9IHJlcGx5VG9fbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSByZXBseVRvX2xlbjtcbiAgfVxuICB2YWwgPSBmaWVsZHMuZXhwaXJhdGlvbjtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAyNTY7XG4gICAgYnVmZmVyW29mZnNldF0gPSBleHBpcmF0aW9uX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gZXhwaXJhdGlvbl9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLm1lc3NhZ2VJZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSAxMjg7XG4gICAgYnVmZmVyW29mZnNldF0gPSBtZXNzYWdlSWRfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSBtZXNzYWdlSWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy50aW1lc3RhbXA7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gNjQ7XG4gICAgaW50cy53cml0ZVVJbnQ2NEJFKGJ1ZmZlciwgdmFsLCBvZmZzZXQpO1xuICAgIG9mZnNldCArPSA4O1xuICB9XG4gIHZhbCA9IGZpZWxkcy50eXBlO1xuICBpZiAodm9pZCAwICE9IHZhbCkge1xuICAgIGZsYWdzICs9IDMyO1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gdHlwZV9sZW47XG4gICAgb2Zmc2V0Kys7XG4gICAgYnVmZmVyLndyaXRlKHZhbCwgb2Zmc2V0LCBcInV0ZjhcIik7XG4gICAgb2Zmc2V0ICs9IHR5cGVfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy51c2VySWQ7XG4gIGlmICh2b2lkIDAgIT0gdmFsKSB7XG4gICAgZmxhZ3MgKz0gMTY7XG4gICAgYnVmZmVyW29mZnNldF0gPSB1c2VySWRfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSB1c2VySWRfbGVuO1xuICB9XG4gIHZhbCA9IGZpZWxkcy5hcHBJZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSA4O1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gYXBwSWRfbGVuO1xuICAgIG9mZnNldCsrO1xuICAgIGJ1ZmZlci53cml0ZSh2YWwsIG9mZnNldCwgXCJ1dGY4XCIpO1xuICAgIG9mZnNldCArPSBhcHBJZF9sZW47XG4gIH1cbiAgdmFsID0gZmllbGRzLmNsdXN0ZXJJZDtcbiAgaWYgKHZvaWQgMCAhPSB2YWwpIHtcbiAgICBmbGFncyArPSA0O1xuICAgIGJ1ZmZlcltvZmZzZXRdID0gY2x1c3RlcklkX2xlbjtcbiAgICBvZmZzZXQrKztcbiAgICBidWZmZXIud3JpdGUodmFsLCBvZmZzZXQsIFwidXRmOFwiKTtcbiAgICBvZmZzZXQgKz0gY2x1c3RlcklkX2xlbjtcbiAgfVxuICBidWZmZXJbb2Zmc2V0XSA9IDIwNjtcbiAgYnVmZmVyLndyaXRlVUludDMyQkUob2Zmc2V0IC0gNywgMyk7XG4gIGJ1ZmZlci53cml0ZVVJbnQxNkJFKGZsYWdzLCAxOSk7XG4gIHJldHVybiBidWZmZXIuc3ViYXJyYXkoMCwgb2Zmc2V0ICsgMSk7XG59XG5cbmZ1bmN0aW9uIGRlY29kZUJhc2ljUHJvcGVydGllcyhidWZmZXIpIHtcbiAgdmFyIGZsYWdzLCB2YWwsIGxlbiwgb2Zmc2V0ID0gMjtcbiAgZmxhZ3MgPSBidWZmZXIucmVhZFVJbnQxNkJFKDApO1xuICBpZiAoMCA9PT0gZmxhZ3MpIHJldHVybiB7fTtcbiAgdmFyIGZpZWxkcyA9IHtcbiAgICBjb250ZW50VHlwZTogdm9pZCAwLFxuICAgIGNvbnRlbnRFbmNvZGluZzogdm9pZCAwLFxuICAgIGhlYWRlcnM6IHZvaWQgMCxcbiAgICBkZWxpdmVyeU1vZGU6IHZvaWQgMCxcbiAgICBwcmlvcml0eTogdm9pZCAwLFxuICAgIGNvcnJlbGF0aW9uSWQ6IHZvaWQgMCxcbiAgICByZXBseVRvOiB2b2lkIDAsXG4gICAgZXhwaXJhdGlvbjogdm9pZCAwLFxuICAgIG1lc3NhZ2VJZDogdm9pZCAwLFxuICAgIHRpbWVzdGFtcDogdm9pZCAwLFxuICAgIHR5cGU6IHZvaWQgMCxcbiAgICB1c2VySWQ6IHZvaWQgMCxcbiAgICBhcHBJZDogdm9pZCAwLFxuICAgIGNsdXN0ZXJJZDogdm9pZCAwXG4gIH07XG4gIGlmICgzMjc2OCAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLmNvbnRlbnRUeXBlID0gdmFsO1xuICB9XG4gIGlmICgxNjM4NCAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLmNvbnRlbnRFbmNvZGluZyA9IHZhbDtcbiAgfVxuICBpZiAoODE5MiAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50MzJCRShvZmZzZXQpO1xuICAgIG9mZnNldCArPSA0O1xuICAgIHZhbCA9IGRlY29kZUZpZWxkcyhidWZmZXIuc3ViYXJyYXkob2Zmc2V0LCBvZmZzZXQgKyBsZW4pKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5oZWFkZXJzID0gdmFsO1xuICB9XG4gIGlmICg0MDk2ICYgZmxhZ3MpIHtcbiAgICB2YWwgPSBidWZmZXJbb2Zmc2V0XTtcbiAgICBvZmZzZXQrKztcbiAgICBmaWVsZHMuZGVsaXZlcnlNb2RlID0gdmFsO1xuICB9XG4gIGlmICgyMDQ4ICYgZmxhZ3MpIHtcbiAgICB2YWwgPSBidWZmZXJbb2Zmc2V0XTtcbiAgICBvZmZzZXQrKztcbiAgICBmaWVsZHMucHJpb3JpdHkgPSB2YWw7XG4gIH1cbiAgaWYgKDEwMjQgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5jb3JyZWxhdGlvbklkID0gdmFsO1xuICB9XG4gIGlmICg1MTIgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5yZXBseVRvID0gdmFsO1xuICB9XG4gIGlmICgyNTYgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5leHBpcmF0aW9uID0gdmFsO1xuICB9XG4gIGlmICgxMjggJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy5tZXNzYWdlSWQgPSB2YWw7XG4gIH1cbiAgaWYgKDY0ICYgZmxhZ3MpIHtcbiAgICB2YWwgPSBpbnRzLnJlYWRVSW50NjRCRShidWZmZXIsIG9mZnNldCk7XG4gICAgb2Zmc2V0ICs9IDg7XG4gICAgZmllbGRzLnRpbWVzdGFtcCA9IHZhbDtcbiAgfVxuICBpZiAoMzIgJiBmbGFncykge1xuICAgIGxlbiA9IGJ1ZmZlci5yZWFkVUludDgob2Zmc2V0KTtcbiAgICBvZmZzZXQrKztcbiAgICB2YWwgPSBidWZmZXIudG9TdHJpbmcoXCJ1dGY4XCIsIG9mZnNldCwgb2Zmc2V0ICsgbGVuKTtcbiAgICBvZmZzZXQgKz0gbGVuO1xuICAgIGZpZWxkcy50eXBlID0gdmFsO1xuICB9XG4gIGlmICgxNiAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLnVzZXJJZCA9IHZhbDtcbiAgfVxuICBpZiAoOCAmIGZsYWdzKSB7XG4gICAgbGVuID0gYnVmZmVyLnJlYWRVSW50OChvZmZzZXQpO1xuICAgIG9mZnNldCsrO1xuICAgIHZhbCA9IGJ1ZmZlci50b1N0cmluZyhcInV0ZjhcIiwgb2Zmc2V0LCBvZmZzZXQgKyBsZW4pO1xuICAgIG9mZnNldCArPSBsZW47XG4gICAgZmllbGRzLmFwcElkID0gdmFsO1xuICB9XG4gIGlmICg0ICYgZmxhZ3MpIHtcbiAgICBsZW4gPSBidWZmZXIucmVhZFVJbnQ4KG9mZnNldCk7XG4gICAgb2Zmc2V0Kys7XG4gICAgdmFsID0gYnVmZmVyLnRvU3RyaW5nKFwidXRmOFwiLCBvZmZzZXQsIG9mZnNldCArIGxlbik7XG4gICAgb2Zmc2V0ICs9IGxlbjtcbiAgICBmaWVsZHMuY2x1c3RlcklkID0gdmFsO1xuICB9XG4gIHJldHVybiBmaWVsZHM7XG59XG5cbnZhciBjb2RlYyA9IHJlcXVpcmUoXCIuL2NvZGVjXCIpLCBpbnRzID0gcmVxdWlyZShcImJ1ZmZlci1tb3JlLWludHNcIiksIGVuY29kZVRhYmxlID0gY29kZWMuZW5jb2RlVGFibGUsIGRlY29kZUZpZWxkcyA9IGNvZGVjLmRlY29kZUZpZWxkcywgU0NSQVRDSCA9IEJ1ZmZlci5hbGxvYyg2NTUzNiksIEVNUFRZX09CSkVDVCA9IE9iamVjdC5mcmVlemUoe30pO1xuXG5tb2R1bGUuZXhwb3J0cy5jb25zdGFudHMgPSB7XG4gIEZSQU1FX01FVEhPRDogMSxcbiAgRlJBTUVfSEVBREVSOiAyLFxuICBGUkFNRV9CT0RZOiAzLFxuICBGUkFNRV9IRUFSVEJFQVQ6IDgsXG4gIEZSQU1FX01JTl9TSVpFOiA0MDk2LFxuICBGUkFNRV9FTkQ6IDIwNixcbiAgUkVQTFlfU1VDQ0VTUzogMjAwLFxuICBDT05URU5UX1RPT19MQVJHRTogMzExLFxuICBOT19ST1VURTogMzEyLFxuICBOT19DT05TVU1FUlM6IDMxMyxcbiAgQUNDRVNTX1JFRlVTRUQ6IDQwMyxcbiAgTk9UX0ZPVU5EOiA0MDQsXG4gIFJFU09VUkNFX0xPQ0tFRDogNDA1LFxuICBQUkVDT05ESVRJT05fRkFJTEVEOiA0MDYsXG4gIENPTk5FQ1RJT05fRk9SQ0VEOiAzMjAsXG4gIElOVkFMSURfUEFUSDogNDAyLFxuICBGUkFNRV9FUlJPUjogNTAxLFxuICBTWU5UQVhfRVJST1I6IDUwMixcbiAgQ09NTUFORF9JTlZBTElEOiA1MDMsXG4gIENIQU5ORUxfRVJST1I6IDUwNCxcbiAgVU5FWFBFQ1RFRF9GUkFNRTogNTA1LFxuICBSRVNPVVJDRV9FUlJPUjogNTA2LFxuICBOT1RfQUxMT1dFRDogNTMwLFxuICBOT1RfSU1QTEVNRU5URUQ6IDU0MCxcbiAgSU5URVJOQUxfRVJST1I6IDU0MVxufTtcblxubW9kdWxlLmV4cG9ydHMuY29uc3RhbnRfc3RycyA9IHtcbiAgXCIxXCI6IFwiRlJBTUUtTUVUSE9EXCIsXG4gIFwiMlwiOiBcIkZSQU1FLUhFQURFUlwiLFxuICBcIjNcIjogXCJGUkFNRS1CT0RZXCIsXG4gIFwiOFwiOiBcIkZSQU1FLUhFQVJUQkVBVFwiLFxuICBcIjIwMFwiOiBcIlJFUExZLVNVQ0NFU1NcIixcbiAgXCIyMDZcIjogXCJGUkFNRS1FTkRcIixcbiAgXCIzMTFcIjogXCJDT05URU5ULVRPTy1MQVJHRVwiLFxuICBcIjMxMlwiOiBcIk5PLVJPVVRFXCIsXG4gIFwiMzEzXCI6IFwiTk8tQ09OU1VNRVJTXCIsXG4gIFwiMzIwXCI6IFwiQ09OTkVDVElPTi1GT1JDRURcIixcbiAgXCI0MDJcIjogXCJJTlZBTElELVBBVEhcIixcbiAgXCI0MDNcIjogXCJBQ0NFU1MtUkVGVVNFRFwiLFxuICBcIjQwNFwiOiBcIk5PVC1GT1VORFwiLFxuICBcIjQwNVwiOiBcIlJFU09VUkNFLUxPQ0tFRFwiLFxuICBcIjQwNlwiOiBcIlBSRUNPTkRJVElPTi1GQUlMRURcIixcbiAgXCI1MDFcIjogXCJGUkFNRS1FUlJPUlwiLFxuICBcIjUwMlwiOiBcIlNZTlRBWC1FUlJPUlwiLFxuICBcIjUwM1wiOiBcIkNPTU1BTkQtSU5WQUxJRFwiLFxuICBcIjUwNFwiOiBcIkNIQU5ORUwtRVJST1JcIixcbiAgXCI1MDVcIjogXCJVTkVYUEVDVEVELUZSQU1FXCIsXG4gIFwiNTA2XCI6IFwiUkVTT1VSQ0UtRVJST1JcIixcbiAgXCI1MzBcIjogXCJOT1QtQUxMT1dFRFwiLFxuICBcIjU0MFwiOiBcIk5PVC1JTVBMRU1FTlRFRFwiLFxuICBcIjU0MVwiOiBcIklOVEVSTkFMLUVSUk9SXCIsXG4gIFwiNDA5NlwiOiBcIkZSQU1FLU1JTi1TSVpFXCJcbn07XG5cbm1vZHVsZS5leHBvcnRzLkZSQU1FX09WRVJIRUFEID0gODtcblxubW9kdWxlLmV4cG9ydHMuZGVjb2RlID0gZnVuY3Rpb24oaWQsIGJ1Zikge1xuICBzd2l0Y2ggKGlkKSB7XG4gICBjYXNlIDM5MzIxNzA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljUW9zKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjE3MTpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNRb3NPayhidWYpO1xuXG4gICBjYXNlIDM5MzIxODA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljQ29uc3VtZShidWYpO1xuXG4gICBjYXNlIDM5MzIxODE6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljQ29uc3VtZU9rKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjE5MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNDYW5jZWwoYnVmKTtcblxuICAgY2FzZSAzOTMyMTkxOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0NhbmNlbE9rKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjIwMDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNQdWJsaXNoKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjIxMDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNSZXR1cm4oYnVmKTtcblxuICAgY2FzZSAzOTMyMjIwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0RlbGl2ZXIoYnVmKTtcblxuICAgY2FzZSAzOTMyMjMwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0dldChidWYpO1xuXG4gICBjYXNlIDM5MzIyMzE6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljR2V0T2soYnVmKTtcblxuICAgY2FzZSAzOTMyMjMyOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY0dldEVtcHR5KGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjI0MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNBY2soYnVmKTtcblxuICAgY2FzZSAzOTMyMjUwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY1JlamVjdChidWYpO1xuXG4gICBjYXNlIDM5MzIyNjA6XG4gICAgcmV0dXJuIGRlY29kZUJhc2ljUmVjb3ZlckFzeW5jKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjI3MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNSZWNvdmVyKGJ1Zik7XG5cbiAgIGNhc2UgMzkzMjI3MTpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNSZWNvdmVyT2soYnVmKTtcblxuICAgY2FzZSAzOTMyMjgwOlxuICAgIHJldHVybiBkZWNvZGVCYXNpY05hY2soYnVmKTtcblxuICAgY2FzZSA2NTUzNzA6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25TdGFydChidWYpO1xuXG4gICBjYXNlIDY1NTM3MTpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblN0YXJ0T2soYnVmKTtcblxuICAgY2FzZSA2NTUzODA6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25TZWN1cmUoYnVmKTtcblxuICAgY2FzZSA2NTUzODE6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25TZWN1cmVPayhidWYpO1xuXG4gICBjYXNlIDY1NTM5MDpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblR1bmUoYnVmKTtcblxuICAgY2FzZSA2NTUzOTE6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25UdW5lT2soYnVmKTtcblxuICAgY2FzZSA2NTU0MDA6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25PcGVuKGJ1Zik7XG5cbiAgIGNhc2UgNjU1NDAxOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uT3Blbk9rKGJ1Zik7XG5cbiAgIGNhc2UgNjU1NDEwOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uQ2xvc2UoYnVmKTtcblxuICAgY2FzZSA2NTU0MTE6XG4gICAgcmV0dXJuIGRlY29kZUNvbm5lY3Rpb25DbG9zZU9rKGJ1Zik7XG5cbiAgIGNhc2UgNjU1NDIwOlxuICAgIHJldHVybiBkZWNvZGVDb25uZWN0aW9uQmxvY2tlZChidWYpO1xuXG4gICBjYXNlIDY1NTQyMTpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblVuYmxvY2tlZChidWYpO1xuXG4gICBjYXNlIDY1NTQzMDpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblVwZGF0ZVNlY3JldChidWYpO1xuXG4gICBjYXNlIDY1NTQzMTpcbiAgICByZXR1cm4gZGVjb2RlQ29ubmVjdGlvblVwZGF0ZVNlY3JldE9rKGJ1Zik7XG5cbiAgIGNhc2UgMTMxMDczMDpcbiAgICByZXR1cm4gZGVjb2RlQ2hhbm5lbE9wZW4oYnVmKTtcblxuICAgY2FzZSAxMzEwNzMxOlxuICAgIHJldHVybiBkZWNvZGVDaGFubmVsT3Blbk9rKGJ1Zik7XG5cbiAgIGNhc2UgMTMxMDc0MDpcbiAgICByZXR1cm4gZGVjb2RlQ2hhbm5lbEZsb3coYnVmKTtcblxuICAgY2FzZSAxMzEwNzQxOlxuICAgIHJldHVybiBkZWNvZGVDaGFubmVsRmxvd09rKGJ1Zik7XG5cbiAgIGNhc2UgMTMxMDc2MDpcbiAgICByZXR1cm4gZGVjb2RlQ2hhbm5lbENsb3NlKGJ1Zik7XG5cbiAgIGNhc2UgMTMxMDc2MTpcbiAgICByZXR1cm4gZGVjb2RlQ2hhbm5lbENsb3NlT2soYnVmKTtcblxuICAgY2FzZSAxOTY2MDkwOlxuICAgIHJldHVybiBkZWNvZGVBY2Nlc3NSZXF1ZXN0KGJ1Zik7XG5cbiAgIGNhc2UgMTk2NjA5MTpcbiAgICByZXR1cm4gZGVjb2RlQWNjZXNzUmVxdWVzdE9rKGJ1Zik7XG5cbiAgIGNhc2UgMjYyMTQ1MDpcbiAgICByZXR1cm4gZGVjb2RlRXhjaGFuZ2VEZWNsYXJlKGJ1Zik7XG5cbiAgIGNhc2UgMjYyMTQ1MTpcbiAgICByZXR1cm4gZGVjb2RlRXhjaGFuZ2VEZWNsYXJlT2soYnVmKTtcblxuICAgY2FzZSAyNjIxNDYwOlxuICAgIHJldHVybiBkZWNvZGVFeGNoYW5nZURlbGV0ZShidWYpO1xuXG4gICBjYXNlIDI2MjE0NjE6XG4gICAgcmV0dXJuIGRlY29kZUV4Y2hhbmdlRGVsZXRlT2soYnVmKTtcblxuICAgY2FzZSAyNjIxNDcwOlxuICAgIHJldHVybiBkZWNvZGVFeGNoYW5nZUJpbmQoYnVmKTtcblxuICAgY2FzZSAyNjIxNDcxOlxuICAgIHJldHVybiBkZWNvZGVFeGNoYW5nZUJpbmRPayhidWYpO1xuXG4gICBjYXNlIDI2MjE0ODA6XG4gICAgcmV0dXJuIGRlY29kZUV4Y2hhbmdlVW5iaW5kKGJ1Zik7XG5cbiAgIGNhc2UgMjYyMTQ5MTpcbiAgICByZXR1cm4gZGVjb2RlRXhjaGFuZ2VVbmJpbmRPayhidWYpO1xuXG4gICBjYXNlIDMyNzY4MTA6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlRGVjbGFyZShidWYpO1xuXG4gICBjYXNlIDMyNzY4MTE6XG4gICAgcmV0dXJuIGRlY29kZVF1ZXVlRGVjbGFyZU9rKGJ1Zik7XG5cbiAgIGNhc2UgMzI3NjgyMDpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVCaW5kKGJ1Zik7XG5cbiAgIGNhc2UgMzI3NjgyMTpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVCaW5kT2soYnVmKTtcblxuICAgY2FzZSAzMjc2ODMwOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZVB1cmdlKGJ1Zik7XG5cbiAgIGNhc2UgMzI3NjgzMTpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVQdXJnZU9rKGJ1Zik7XG5cbiAgIGNhc2UgMzI3Njg0MDpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVEZWxldGUoYnVmKTtcblxuICAgY2FzZSAzMjc2ODQxOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZURlbGV0ZU9rKGJ1Zik7XG5cbiAgIGNhc2UgMzI3Njg1MDpcbiAgICByZXR1cm4gZGVjb2RlUXVldWVVbmJpbmQoYnVmKTtcblxuICAgY2FzZSAzMjc2ODUxOlxuICAgIHJldHVybiBkZWNvZGVRdWV1ZVVuYmluZE9rKGJ1Zik7XG5cbiAgIGNhc2UgNTg5ODI1MDpcbiAgICByZXR1cm4gZGVjb2RlVHhTZWxlY3QoYnVmKTtcblxuICAgY2FzZSA1ODk4MjUxOlxuICAgIHJldHVybiBkZWNvZGVUeFNlbGVjdE9rKGJ1Zik7XG5cbiAgIGNhc2UgNTg5ODI2MDpcbiAgICByZXR1cm4gZGVjb2RlVHhDb21taXQoYnVmKTtcblxuICAgY2FzZSA1ODk4MjYxOlxuICAgIHJldHVybiBkZWNvZGVUeENvbW1pdE9rKGJ1Zik7XG5cbiAgIGNhc2UgNTg5ODI3MDpcbiAgICByZXR1cm4gZGVjb2RlVHhSb2xsYmFjayhidWYpO1xuXG4gICBjYXNlIDU4OTgyNzE6XG4gICAgcmV0dXJuIGRlY29kZVR4Um9sbGJhY2tPayhidWYpO1xuXG4gICBjYXNlIDU1NzA1NzA6XG4gICAgcmV0dXJuIGRlY29kZUNvbmZpcm1TZWxlY3QoYnVmKTtcblxuICAgY2FzZSA1NTcwNTcxOlxuICAgIHJldHVybiBkZWNvZGVDb25maXJtU2VsZWN0T2soYnVmKTtcblxuICAgY2FzZSA2MDpcbiAgICByZXR1cm4gZGVjb2RlQmFzaWNQcm9wZXJ0aWVzKGJ1Zik7XG5cbiAgIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjbGFzcy9tZXRob2QgSURcIik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZU1ldGhvZCA9IGZ1bmN0aW9uKGlkLCBjaGFubmVsLCBmaWVsZHMpIHtcbiAgc3dpdGNoIChpZCkge1xuICAgY2FzZSAzOTMyMTcwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY1FvcyhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIxNzE6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUW9zT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMTgwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0NvbnN1bWUoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMTgxOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0NvbnN1bWVPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIxOTA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljQ2FuY2VsKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjE5MTpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNDYW5jZWxPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyMDA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUHVibGlzaChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyMTA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUmV0dXJuKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjIyMDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNEZWxpdmVyKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjIzMDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNHZXQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjMxOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY0dldE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjIzMjpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNHZXRFbXB0eShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyNDA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljQWNrKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjI1MDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNSZWplY3QoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzOTMyMjYwOlxuICAgIHJldHVybiBlbmNvZGVCYXNpY1JlY292ZXJBc3luYyhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyNzA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUmVjb3ZlcihjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDM5MzIyNzE6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUmVjb3Zlck9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzkzMjI4MDpcbiAgICByZXR1cm4gZW5jb2RlQmFzaWNOYWNrKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1MzcwOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uU3RhcnQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTUzNzE6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25TdGFydE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1MzgwOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uU2VjdXJlKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1MzgxOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uU2VjdXJlT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTUzOTA6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25UdW5lKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1MzkxOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uVHVuZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1NDAwOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uT3BlbihjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTQwMTpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvbk9wZW5PayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTQxMDpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvbkNsb3NlKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNjU1NDExOlxuICAgIHJldHVybiBlbmNvZGVDb25uZWN0aW9uQ2xvc2VPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDY1NTQyMDpcbiAgICByZXR1cm4gZW5jb2RlQ29ubmVjdGlvbkJsb2NrZWQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTU0MjE6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25VbmJsb2NrZWQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTU0MzA6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25VcGRhdGVTZWNyZXQoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA2NTU0MzE6XG4gICAgcmV0dXJuIGVuY29kZUNvbm5lY3Rpb25VcGRhdGVTZWNyZXRPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDEzMTA3MzA6XG4gICAgcmV0dXJuIGVuY29kZUNoYW5uZWxPcGVuKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMTMxMDczMTpcbiAgICByZXR1cm4gZW5jb2RlQ2hhbm5lbE9wZW5PayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDEzMTA3NDA6XG4gICAgcmV0dXJuIGVuY29kZUNoYW5uZWxGbG93KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMTMxMDc0MTpcbiAgICByZXR1cm4gZW5jb2RlQ2hhbm5lbEZsb3dPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDEzMTA3NjA6XG4gICAgcmV0dXJuIGVuY29kZUNoYW5uZWxDbG9zZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDEzMTA3NjE6XG4gICAgcmV0dXJuIGVuY29kZUNoYW5uZWxDbG9zZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMTk2NjA5MDpcbiAgICByZXR1cm4gZW5jb2RlQWNjZXNzUmVxdWVzdChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDE5NjYwOTE6XG4gICAgcmV0dXJuIGVuY29kZUFjY2Vzc1JlcXVlc3RPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDI2MjE0NTA6XG4gICAgcmV0dXJuIGVuY29kZUV4Y2hhbmdlRGVjbGFyZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDI2MjE0NTE6XG4gICAgcmV0dXJuIGVuY29kZUV4Y2hhbmdlRGVjbGFyZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMjYyMTQ2MDpcbiAgICByZXR1cm4gZW5jb2RlRXhjaGFuZ2VEZWxldGUoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAyNjIxNDYxOlxuICAgIHJldHVybiBlbmNvZGVFeGNoYW5nZURlbGV0ZU9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMjYyMTQ3MDpcbiAgICByZXR1cm4gZW5jb2RlRXhjaGFuZ2VCaW5kKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMjYyMTQ3MTpcbiAgICByZXR1cm4gZW5jb2RlRXhjaGFuZ2VCaW5kT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAyNjIxNDgwOlxuICAgIHJldHVybiBlbmNvZGVFeGNoYW5nZVVuYmluZChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDI2MjE0OTE6XG4gICAgcmV0dXJuIGVuY29kZUV4Y2hhbmdlVW5iaW5kT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODEwOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZURlY2xhcmUoY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSAzMjc2ODExOlxuICAgIHJldHVybiBlbmNvZGVRdWV1ZURlY2xhcmVPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4MjA6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlQmluZChjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4MjE6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlQmluZE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3NjgzMDpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVQdXJnZShjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4MzE6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlUHVyZ2VPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4NDA6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlRGVsZXRlKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3Njg0MTpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVEZWxldGVPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDMyNzY4NTA6XG4gICAgcmV0dXJuIGVuY29kZVF1ZXVlVW5iaW5kKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgMzI3Njg1MTpcbiAgICByZXR1cm4gZW5jb2RlUXVldWVVbmJpbmRPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDU4OTgyNTA6XG4gICAgcmV0dXJuIGVuY29kZVR4U2VsZWN0KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNTg5ODI1MTpcbiAgICByZXR1cm4gZW5jb2RlVHhTZWxlY3RPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDU4OTgyNjA6XG4gICAgcmV0dXJuIGVuY29kZVR4Q29tbWl0KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNTg5ODI2MTpcbiAgICByZXR1cm4gZW5jb2RlVHhDb21taXRPayhjaGFubmVsLCBmaWVsZHMpO1xuXG4gICBjYXNlIDU4OTgyNzA6XG4gICAgcmV0dXJuIGVuY29kZVR4Um9sbGJhY2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA1ODk4MjcxOlxuICAgIHJldHVybiBlbmNvZGVUeFJvbGxiYWNrT2soY2hhbm5lbCwgZmllbGRzKTtcblxuICAgY2FzZSA1NTcwNTcwOlxuICAgIHJldHVybiBlbmNvZGVDb25maXJtU2VsZWN0KGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGNhc2UgNTU3MDU3MTpcbiAgICByZXR1cm4gZW5jb2RlQ29uZmlybVNlbGVjdE9rKGNoYW5uZWwsIGZpZWxkcyk7XG5cbiAgIGRlZmF1bHQ6XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiVW5rbm93biBjbGFzcy9tZXRob2QgSURcIik7XG4gIH1cbn07XG5cbm1vZHVsZS5leHBvcnRzLmVuY29kZVByb3BlcnRpZXMgPSBmdW5jdGlvbihpZCwgY2hhbm5lbCwgc2l6ZSwgZmllbGRzKSB7XG4gIHN3aXRjaCAoaWQpIHtcbiAgIGNhc2UgNjA6XG4gICAgcmV0dXJuIGVuY29kZUJhc2ljUHJvcGVydGllcyhjaGFubmVsLCBzaXplLCBmaWVsZHMpO1xuXG4gICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihcIlVua25vd24gY2xhc3MvcHJvcGVydGllcyBJRFwiKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuaW5mbyA9IGZ1bmN0aW9uKGlkKSB7XG4gIHN3aXRjaCAoaWQpIHtcbiAgIGNhc2UgMzkzMjE3MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljUW9zO1xuXG4gICBjYXNlIDM5MzIxNzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1Fvc09rO1xuXG4gICBjYXNlIDM5MzIxODA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0NvbnN1bWU7XG5cbiAgIGNhc2UgMzkzMjE4MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljQ29uc3VtZU9rO1xuXG4gICBjYXNlIDM5MzIxOTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0NhbmNlbDtcblxuICAgY2FzZSAzOTMyMTkxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNDYW5jZWxPaztcblxuICAgY2FzZSAzOTMyMjAwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNQdWJsaXNoO1xuXG4gICBjYXNlIDM5MzIyMTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1JldHVybjtcblxuICAgY2FzZSAzOTMyMjIwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNEZWxpdmVyO1xuXG4gICBjYXNlIDM5MzIyMzA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY0dldDtcblxuICAgY2FzZSAzOTMyMjMxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNHZXRPaztcblxuICAgY2FzZSAzOTMyMjMyOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNHZXRFbXB0eTtcblxuICAgY2FzZSAzOTMyMjQwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNBY2s7XG5cbiAgIGNhc2UgMzkzMjI1MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Jhc2ljUmVqZWN0O1xuXG4gICBjYXNlIDM5MzIyNjA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1JlY292ZXJBc3luYztcblxuICAgY2FzZSAzOTMyMjcwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNSZWNvdmVyO1xuXG4gICBjYXNlIDM5MzIyNzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9CYXNpY1JlY292ZXJPaztcblxuICAgY2FzZSAzOTMyMjgwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQmFzaWNOYWNrO1xuXG4gICBjYXNlIDY1NTM3MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25TdGFydDtcblxuICAgY2FzZSA2NTUzNzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uU3RhcnRPaztcblxuICAgY2FzZSA2NTUzODA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uU2VjdXJlO1xuXG4gICBjYXNlIDY1NTM4MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25TZWN1cmVPaztcblxuICAgY2FzZSA2NTUzOTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uVHVuZTtcblxuICAgY2FzZSA2NTUzOTE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uVHVuZU9rO1xuXG4gICBjYXNlIDY1NTQwMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25PcGVuO1xuXG4gICBjYXNlIDY1NTQwMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25PcGVuT2s7XG5cbiAgIGNhc2UgNjU1NDEwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvbkNsb3NlO1xuXG4gICBjYXNlIDY1NTQxMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25DbG9zZU9rO1xuXG4gICBjYXNlIDY1NTQyMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25CbG9ja2VkO1xuXG4gICBjYXNlIDY1NTQyMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0Nvbm5lY3Rpb25VbmJsb2NrZWQ7XG5cbiAgIGNhc2UgNjU1NDMwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29ubmVjdGlvblVwZGF0ZVNlY3JldDtcblxuICAgY2FzZSA2NTU0MzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9Db25uZWN0aW9uVXBkYXRlU2VjcmV0T2s7XG5cbiAgIGNhc2UgMTMxMDczMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0NoYW5uZWxPcGVuO1xuXG4gICBjYXNlIDEzMTA3MzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9DaGFubmVsT3Blbk9rO1xuXG4gICBjYXNlIDEzMTA3NDA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9DaGFubmVsRmxvdztcblxuICAgY2FzZSAxMzEwNzQxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ2hhbm5lbEZsb3dPaztcblxuICAgY2FzZSAxMzEwNzYwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ2hhbm5lbENsb3NlO1xuXG4gICBjYXNlIDEzMTA3NjE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9DaGFubmVsQ2xvc2VPaztcblxuICAgY2FzZSAxOTY2MDkwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQWNjZXNzUmVxdWVzdDtcblxuICAgY2FzZSAxOTY2MDkxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQWNjZXNzUmVxdWVzdE9rO1xuXG4gICBjYXNlIDI2MjE0NTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9FeGNoYW5nZURlY2xhcmU7XG5cbiAgIGNhc2UgMjYyMTQ1MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0V4Y2hhbmdlRGVjbGFyZU9rO1xuXG4gICBjYXNlIDI2MjE0NjA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9FeGNoYW5nZURlbGV0ZTtcblxuICAgY2FzZSAyNjIxNDYxOlxuICAgIHJldHVybiBtZXRob2RJbmZvRXhjaGFuZ2VEZWxldGVPaztcblxuICAgY2FzZSAyNjIxNDcwOlxuICAgIHJldHVybiBtZXRob2RJbmZvRXhjaGFuZ2VCaW5kO1xuXG4gICBjYXNlIDI2MjE0NzE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9FeGNoYW5nZUJpbmRPaztcblxuICAgY2FzZSAyNjIxNDgwOlxuICAgIHJldHVybiBtZXRob2RJbmZvRXhjaGFuZ2VVbmJpbmQ7XG5cbiAgIGNhc2UgMjYyMTQ5MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb0V4Y2hhbmdlVW5iaW5kT2s7XG5cbiAgIGNhc2UgMzI3NjgxMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlRGVjbGFyZTtcblxuICAgY2FzZSAzMjc2ODExOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVEZWNsYXJlT2s7XG5cbiAgIGNhc2UgMzI3NjgyMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlQmluZDtcblxuICAgY2FzZSAzMjc2ODIxOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVCaW5kT2s7XG5cbiAgIGNhc2UgMzI3NjgzMDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlUHVyZ2U7XG5cbiAgIGNhc2UgMzI3NjgzMTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlUHVyZ2VPaztcblxuICAgY2FzZSAzMjc2ODQwOlxuICAgIHJldHVybiBtZXRob2RJbmZvUXVldWVEZWxldGU7XG5cbiAgIGNhc2UgMzI3Njg0MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlRGVsZXRlT2s7XG5cbiAgIGNhc2UgMzI3Njg1MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1F1ZXVlVW5iaW5kO1xuXG4gICBjYXNlIDMyNzY4NTE6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9RdWV1ZVVuYmluZE9rO1xuXG4gICBjYXNlIDU4OTgyNTA6XG4gICAgcmV0dXJuIG1ldGhvZEluZm9UeFNlbGVjdDtcblxuICAgY2FzZSA1ODk4MjUxOlxuICAgIHJldHVybiBtZXRob2RJbmZvVHhTZWxlY3RPaztcblxuICAgY2FzZSA1ODk4MjYwOlxuICAgIHJldHVybiBtZXRob2RJbmZvVHhDb21taXQ7XG5cbiAgIGNhc2UgNTg5ODI2MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1R4Q29tbWl0T2s7XG5cbiAgIGNhc2UgNTg5ODI3MDpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1R4Um9sbGJhY2s7XG5cbiAgIGNhc2UgNTg5ODI3MTpcbiAgICByZXR1cm4gbWV0aG9kSW5mb1R4Um9sbGJhY2tPaztcblxuICAgY2FzZSA1NTcwNTcwOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29uZmlybVNlbGVjdDtcblxuICAgY2FzZSA1NTcwNTcxOlxuICAgIHJldHVybiBtZXRob2RJbmZvQ29uZmlybVNlbGVjdE9rO1xuXG4gICBjYXNlIDYwOlxuICAgIHJldHVybiBwcm9wZXJ0aWVzSW5mb0Jhc2ljUHJvcGVydGllcztcblxuICAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoXCJVbmtub3duIGNsYXNzL21ldGhvZCBJRFwiKTtcbiAgfVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNRb3MgPSAzOTMyMTcwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljUW9zID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUW9zID0ge1xuICBpZDogMzkzMjE3MCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAxMCxcbiAgbmFtZTogXCJCYXNpY1Fvc1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdcIixcbiAgICBuYW1lOiBcInByZWZldGNoU2l6ZVwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInByZWZldGNoQ291bnRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiZ2xvYmFsXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1Fvc09rID0gMzkzMjE3MTtcblxudmFyIG1ldGhvZEluZm9CYXNpY1Fvc09rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUW9zT2sgPSB7XG4gIGlkOiAzOTMyMTcxLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDExLFxuICBuYW1lOiBcIkJhc2ljUW9zT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljQ29uc3VtZSA9IDM5MzIxODA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNDb25zdW1lID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljQ29uc3VtZSA9IHtcbiAgaWQ6IDM5MzIxODAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogMjAsXG4gIG5hbWU6IFwiQmFzaWNDb25zdW1lXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJUYWdcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm9Mb2NhbFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm9BY2tcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImV4Y2x1c2l2ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImFyZ3VtZW50c1wiLFxuICAgIGRlZmF1bHQ6IHt9XG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNDb25zdW1lT2sgPSAzOTMyMTgxO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljQ29uc3VtZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljQ29uc3VtZU9rID0ge1xuICBpZDogMzkzMjE4MSxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAyMSxcbiAgbmFtZTogXCJCYXNpY0NvbnN1bWVPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjb25zdW1lclRhZ1wiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNDYW5jZWwgPSAzOTMyMTkwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljQ2FuY2VsID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljQ2FuY2VsID0ge1xuICBpZDogMzkzMjE5MCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAzMCxcbiAgbmFtZTogXCJCYXNpY0NhbmNlbFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJjb25zdW1lclRhZ1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY0NhbmNlbE9rID0gMzkzMjE5MTtcblxudmFyIG1ldGhvZEluZm9CYXNpY0NhbmNlbE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljQ2FuY2VsT2sgPSB7XG4gIGlkOiAzOTMyMTkxLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDMxLFxuICBuYW1lOiBcIkJhc2ljQ2FuY2VsT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJUYWdcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljUHVibGlzaCA9IDM5MzIyMDA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNQdWJsaXNoID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUHVibGlzaCA9IHtcbiAgaWQ6IDM5MzIyMDAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogNDAsXG4gIG5hbWU6IFwiQmFzaWNQdWJsaXNoXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJtYW5kYXRvcnlcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImltbWVkaWF0ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNSZXR1cm4gPSAzOTMyMjEwO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljUmV0dXJuID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Jhc2ljUmV0dXJuID0ge1xuICBpZDogMzkzMjIxMCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiA1MCxcbiAgbmFtZTogXCJCYXNpY1JldHVyblwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJyZXBseUNvZGVcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicmVwbHlUZXh0XCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZXhjaGFuZ2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNEZWxpdmVyID0gMzkzMjIyMDtcblxudmFyIG1ldGhvZEluZm9CYXNpY0RlbGl2ZXIgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNEZWxpdmVyID0ge1xuICBpZDogMzkzMjIyMCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiA2MCxcbiAgbmFtZTogXCJCYXNpY0RlbGl2ZXJcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29uc3VtZXJUYWdcIlxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nbG9uZ1wiLFxuICAgIG5hbWU6IFwiZGVsaXZlcnlUYWdcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcInJlZGVsaXZlcmVkXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljR2V0ID0gMzkzMjIzMDtcblxudmFyIG1ldGhvZEluZm9CYXNpY0dldCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0dldCA9IHtcbiAgaWQ6IDM5MzIyMzAsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogNzAsXG4gIG5hbWU6IFwiQmFzaWNHZXRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicXVldWVcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm9BY2tcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkJhc2ljR2V0T2sgPSAzOTMyMjMxO1xuXG52YXIgbWV0aG9kSW5mb0Jhc2ljR2V0T2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNHZXRPayA9IHtcbiAgaWQ6IDM5MzIyMzEsXG4gIGNsYXNzSWQ6IDYwLFxuICBtZXRob2RJZDogNzEsXG4gIG5hbWU6IFwiQmFzaWNHZXRPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdsb25nXCIsXG4gICAgbmFtZTogXCJkZWxpdmVyeVRhZ1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVkZWxpdmVyZWRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZXhjaGFuZ2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImxvbmdcIixcbiAgICBuYW1lOiBcIm1lc3NhZ2VDb3VudFwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNHZXRFbXB0eSA9IDM5MzIyMzI7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNHZXRFbXB0eSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9CYXNpY0dldEVtcHR5ID0ge1xuICBpZDogMzkzMjIzMixcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiA3MixcbiAgbmFtZTogXCJCYXNpY0dldEVtcHR5XCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNsdXN0ZXJJZFwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY0FjayA9IDM5MzIyNDA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNBY2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNBY2sgPSB7XG4gIGlkOiAzOTMyMjQwLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDgwLFxuICBuYW1lOiBcIkJhc2ljQWNrXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ2xvbmdcIixcbiAgICBuYW1lOiBcImRlbGl2ZXJ5VGFnXCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm11bHRpcGxlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1JlamVjdCA9IDM5MzIyNTA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNSZWplY3QgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNSZWplY3QgPSB7XG4gIGlkOiAzOTMyMjUwLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDkwLFxuICBuYW1lOiBcIkJhc2ljUmVqZWN0XCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ2xvbmdcIixcbiAgICBuYW1lOiBcImRlbGl2ZXJ5VGFnXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJyZXF1ZXVlXCIsXG4gICAgZGVmYXVsdDogITBcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1JlY292ZXJBc3luYyA9IDM5MzIyNjA7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNSZWNvdmVyQXN5bmMgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNSZWNvdmVyQXN5bmMgPSB7XG4gIGlkOiAzOTMyMjYwLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDEwMCxcbiAgbmFtZTogXCJCYXNpY1JlY292ZXJBc3luY1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwicmVxdWV1ZVwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNSZWNvdmVyID0gMzkzMjI3MDtcblxudmFyIG1ldGhvZEluZm9CYXNpY1JlY292ZXIgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNSZWNvdmVyID0ge1xuICBpZDogMzkzMjI3MCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAxMTAsXG4gIG5hbWU6IFwiQmFzaWNSZWNvdmVyXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJyZXF1ZXVlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1JlY292ZXJPayA9IDM5MzIyNzE7XG5cbnZhciBtZXRob2RJbmZvQmFzaWNSZWNvdmVyT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNSZWNvdmVyT2sgPSB7XG4gIGlkOiAzOTMyMjcxLFxuICBjbGFzc0lkOiA2MCxcbiAgbWV0aG9kSWQ6IDExMSxcbiAgbmFtZTogXCJCYXNpY1JlY292ZXJPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQmFzaWNOYWNrID0gMzkzMjI4MDtcblxudmFyIG1ldGhvZEluZm9CYXNpY05hY2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQmFzaWNOYWNrID0ge1xuICBpZDogMzkzMjI4MCxcbiAgY2xhc3NJZDogNjAsXG4gIG1ldGhvZElkOiAxMjAsXG4gIG5hbWU6IFwiQmFzaWNOYWNrXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ2xvbmdcIixcbiAgICBuYW1lOiBcImRlbGl2ZXJ5VGFnXCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm11bHRpcGxlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJyZXF1ZXVlXCIsXG4gICAgZGVmYXVsdDogITBcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uU3RhcnQgPSA2NTUzNzA7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvblN0YXJ0ID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25TdGFydCA9IHtcbiAgaWQ6IDY1NTM3MCxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiAxMCxcbiAgbmFtZTogXCJDb25uZWN0aW9uU3RhcnRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJvY3RldFwiLFxuICAgIG5hbWU6IFwidmVyc2lvbk1ham9yXCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJvY3RldFwiLFxuICAgIG5hbWU6IFwidmVyc2lvbk1pbm9yXCIsXG4gICAgZGVmYXVsdDogOVxuICB9LCB7XG4gICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgIG5hbWU6IFwic2VydmVyUHJvcGVydGllc1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcImxvbmdzdHJcIixcbiAgICBuYW1lOiBcIm1lY2hhbmlzbXNcIixcbiAgICBkZWZhdWx0OiBcIlBMQUlOXCJcbiAgfSwge1xuICAgIHR5cGU6IFwibG9uZ3N0clwiLFxuICAgIG5hbWU6IFwibG9jYWxlc1wiLFxuICAgIGRlZmF1bHQ6IFwiZW5fVVNcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25TdGFydE9rID0gNjU1MzcxO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25TdGFydE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25TdGFydE9rID0ge1xuICBpZDogNjU1MzcxLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDExLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25TdGFydE9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImNsaWVudFByb3BlcnRpZXNcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwibWVjaGFuaXNtXCIsXG4gICAgZGVmYXVsdDogXCJQTEFJTlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImxvbmdzdHJcIixcbiAgICBuYW1lOiBcInJlc3BvbnNlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImxvY2FsZVwiLFxuICAgIGRlZmF1bHQ6IFwiZW5fVVNcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25TZWN1cmUgPSA2NTUzODA7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvblNlY3VyZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uU2VjdXJlID0ge1xuICBpZDogNjU1MzgwLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDIwLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25TZWN1cmVcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJsb25nc3RyXCIsXG4gICAgbmFtZTogXCJjaGFsbGVuZ2VcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25TZWN1cmVPayA9IDY1NTM4MTtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uU2VjdXJlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvblNlY3VyZU9rID0ge1xuICBpZDogNjU1MzgxLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDIxLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25TZWN1cmVPa1wiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdzdHJcIixcbiAgICBuYW1lOiBcInJlc3BvbnNlXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uVHVuZSA9IDY1NTM5MDtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uVHVuZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uVHVuZSA9IHtcbiAgaWQ6IDY1NTM5MCxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiAzMCxcbiAgbmFtZTogXCJDb25uZWN0aW9uVHVuZVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJjaGFubmVsTWF4XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJmcmFtZU1heFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcImhlYXJ0YmVhdFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uVHVuZU9rID0gNjU1MzkxO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25UdW5lT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvblR1bmVPayA9IHtcbiAgaWQ6IDY1NTM5MSxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiAzMSxcbiAgbmFtZTogXCJDb25uZWN0aW9uVHVuZU9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcImNoYW5uZWxNYXhcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcImxvbmdcIixcbiAgICBuYW1lOiBcImZyYW1lTWF4XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwiaGVhcnRiZWF0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25PcGVuID0gNjU1NDAwO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25PcGVuID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25PcGVuID0ge1xuICBpZDogNjU1NDAwLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDQwLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25PcGVuXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInZpcnR1YWxIb3N0XCIsXG4gICAgZGVmYXVsdDogXCIvXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNhcGFiaWxpdGllc1wiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJpbnNpc3RcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25PcGVuT2sgPSA2NTU0MDE7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvbk9wZW5PayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uT3Blbk9rID0ge1xuICBpZDogNjU1NDAxLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDQxLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25PcGVuT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwia25vd25Ib3N0c1wiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uQ2xvc2UgPSA2NTU0MTA7XG5cbnZhciBtZXRob2RJbmZvQ29ubmVjdGlvbkNsb3NlID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25DbG9zZSA9IHtcbiAgaWQ6IDY1NTQxMCxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiA1MCxcbiAgbmFtZTogXCJDb25uZWN0aW9uQ2xvc2VcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwicmVwbHlDb2RlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJlcGx5VGV4dFwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcImNsYXNzSWRcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwibWV0aG9kSWRcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25DbG9zZU9rID0gNjU1NDExO1xuXG52YXIgbWV0aG9kSW5mb0Nvbm5lY3Rpb25DbG9zZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25DbG9zZU9rID0ge1xuICBpZDogNjU1NDExLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDUxLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25DbG9zZU9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5Db25uZWN0aW9uQmxvY2tlZCA9IDY1NTQyMDtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uQmxvY2tlZCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25uZWN0aW9uQmxvY2tlZCA9IHtcbiAgaWQ6IDY1NTQyMCxcbiAgY2xhc3NJZDogMTAsXG4gIG1ldGhvZElkOiA2MCxcbiAgbmFtZTogXCJDb25uZWN0aW9uQmxvY2tlZFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyZWFzb25cIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvblVuYmxvY2tlZCA9IDY1NTQyMTtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uVW5ibG9ja2VkID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25VbmJsb2NrZWQgPSB7XG4gIGlkOiA2NTU0MjEsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogNjEsXG4gIG5hbWU6IFwiQ29ubmVjdGlvblVuYmxvY2tlZFwiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29ubmVjdGlvblVwZGF0ZVNlY3JldCA9IDY1NTQzMDtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uVXBkYXRlU2VjcmV0ID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0Nvbm5lY3Rpb25VcGRhdGVTZWNyZXQgPSB7XG4gIGlkOiA2NTU0MzAsXG4gIGNsYXNzSWQ6IDEwLFxuICBtZXRob2RJZDogNzAsXG4gIG5hbWU6IFwiQ29ubmVjdGlvblVwZGF0ZVNlY3JldFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcImxvbmdzdHJcIixcbiAgICBuYW1lOiBcIm5ld1NlY3JldFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyZWFzb25cIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbm5lY3Rpb25VcGRhdGVTZWNyZXRPayA9IDY1NTQzMTtcblxudmFyIG1ldGhvZEluZm9Db25uZWN0aW9uVXBkYXRlU2VjcmV0T2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ29ubmVjdGlvblVwZGF0ZVNlY3JldE9rID0ge1xuICBpZDogNjU1NDMxLFxuICBjbGFzc0lkOiAxMCxcbiAgbWV0aG9kSWQ6IDcxLFxuICBuYW1lOiBcIkNvbm5lY3Rpb25VcGRhdGVTZWNyZXRPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbE9wZW4gPSAxMzEwNzMwO1xuXG52YXIgbWV0aG9kSW5mb0NoYW5uZWxPcGVuID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0NoYW5uZWxPcGVuID0ge1xuICBpZDogMTMxMDczMCxcbiAgY2xhc3NJZDogMjAsXG4gIG1ldGhvZElkOiAxMCxcbiAgbmFtZTogXCJDaGFubmVsT3BlblwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJvdXRPZkJhbmRcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbE9wZW5PayA9IDEzMTA3MzE7XG5cbnZhciBtZXRob2RJbmZvQ2hhbm5lbE9wZW5PayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9DaGFubmVsT3Blbk9rID0ge1xuICBpZDogMTMxMDczMSxcbiAgY2xhc3NJZDogMjAsXG4gIG1ldGhvZElkOiAxMSxcbiAgbmFtZTogXCJDaGFubmVsT3Blbk9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ3N0clwiLFxuICAgIG5hbWU6IFwiY2hhbm5lbElkXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNoYW5uZWxGbG93ID0gMTMxMDc0MDtcblxudmFyIG1ldGhvZEluZm9DaGFubmVsRmxvdyA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9DaGFubmVsRmxvdyA9IHtcbiAgaWQ6IDEzMTA3NDAsXG4gIGNsYXNzSWQ6IDIwLFxuICBtZXRob2RJZDogMjAsXG4gIG5hbWU6IFwiQ2hhbm5lbEZsb3dcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImFjdGl2ZVwiXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ2hhbm5lbEZsb3dPayA9IDEzMTA3NDE7XG5cbnZhciBtZXRob2RJbmZvQ2hhbm5lbEZsb3dPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9DaGFubmVsRmxvd09rID0ge1xuICBpZDogMTMxMDc0MSxcbiAgY2xhc3NJZDogMjAsXG4gIG1ldGhvZElkOiAyMSxcbiAgbmFtZTogXCJDaGFubmVsRmxvd09rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJhY3RpdmVcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNoYW5uZWxDbG9zZSA9IDEzMTA3NjA7XG5cbnZhciBtZXRob2RJbmZvQ2hhbm5lbENsb3NlID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0NoYW5uZWxDbG9zZSA9IHtcbiAgaWQ6IDEzMTA3NjAsXG4gIGNsYXNzSWQ6IDIwLFxuICBtZXRob2RJZDogNDAsXG4gIG5hbWU6IFwiQ2hhbm5lbENsb3NlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInJlcGx5Q29kZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyZXBseVRleHRcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJjbGFzc0lkXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcIm1ldGhvZElkXCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5DaGFubmVsQ2xvc2VPayA9IDEzMTA3NjE7XG5cbnZhciBtZXRob2RJbmZvQ2hhbm5lbENsb3NlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvQ2hhbm5lbENsb3NlT2sgPSB7XG4gIGlkOiAxMzEwNzYxLFxuICBjbGFzc0lkOiAyMCxcbiAgbWV0aG9kSWQ6IDQxLFxuICBuYW1lOiBcIkNoYW5uZWxDbG9zZU9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5BY2Nlc3NSZXF1ZXN0ID0gMTk2NjA5MDtcblxudmFyIG1ldGhvZEluZm9BY2Nlc3NSZXF1ZXN0ID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0FjY2Vzc1JlcXVlc3QgPSB7XG4gIGlkOiAxOTY2MDkwLFxuICBjbGFzc0lkOiAzMCxcbiAgbWV0aG9kSWQ6IDEwLFxuICBuYW1lOiBcIkFjY2Vzc1JlcXVlc3RcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicmVhbG1cIixcbiAgICBkZWZhdWx0OiBcIi9kYXRhXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJleGNsdXNpdmVcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcInBhc3NpdmVcIixcbiAgICBkZWZhdWx0OiAhMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImFjdGl2ZVwiLFxuICAgIGRlZmF1bHQ6ICEwXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwid3JpdGVcIixcbiAgICBkZWZhdWx0OiAhMFxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcInJlYWRcIixcbiAgICBkZWZhdWx0OiAhMFxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkFjY2Vzc1JlcXVlc3RPayA9IDE5NjYwOTE7XG5cbnZhciBtZXRob2RJbmZvQWNjZXNzUmVxdWVzdE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0FjY2Vzc1JlcXVlc3RPayA9IHtcbiAgaWQ6IDE5NjYwOTEsXG4gIGNsYXNzSWQ6IDMwLFxuICBtZXRob2RJZDogMTEsXG4gIG5hbWU6IFwiQWNjZXNzUmVxdWVzdE9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZURlY2xhcmUgPSAyNjIxNDUwO1xuXG52YXIgbWV0aG9kSW5mb0V4Y2hhbmdlRGVjbGFyZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9FeGNoYW5nZURlY2xhcmUgPSB7XG4gIGlkOiAyNjIxNDUwLFxuICBjbGFzc0lkOiA0MCxcbiAgbWV0aG9kSWQ6IDEwLFxuICBuYW1lOiBcIkV4Y2hhbmdlRGVjbGFyZVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJleGNoYW5nZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJ0eXBlXCIsXG4gICAgZGVmYXVsdDogXCJkaXJlY3RcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcInBhc3NpdmVcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImR1cmFibGVcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImF1dG9EZWxldGVcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImludGVybmFsXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJ0YWJsZVwiLFxuICAgIG5hbWU6IFwiYXJndW1lbnRzXCIsXG4gICAgZGVmYXVsdDoge31cbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZURlY2xhcmVPayA9IDI2MjE0NTE7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VEZWNsYXJlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VEZWNsYXJlT2sgPSB7XG4gIGlkOiAyNjIxNDUxLFxuICBjbGFzc0lkOiA0MCxcbiAgbWV0aG9kSWQ6IDExLFxuICBuYW1lOiBcIkV4Y2hhbmdlRGVjbGFyZU9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZURlbGV0ZSA9IDI2MjE0NjA7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VEZWxldGUgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvRXhjaGFuZ2VEZWxldGUgPSB7XG4gIGlkOiAyNjIxNDYwLFxuICBjbGFzc0lkOiA0MCxcbiAgbWV0aG9kSWQ6IDIwLFxuICBuYW1lOiBcIkV4Y2hhbmdlRGVsZXRlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJpZlVudXNlZFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5FeGNoYW5nZURlbGV0ZU9rID0gMjYyMTQ2MTtcblxudmFyIG1ldGhvZEluZm9FeGNoYW5nZURlbGV0ZU9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0V4Y2hhbmdlRGVsZXRlT2sgPSB7XG4gIGlkOiAyNjIxNDYxLFxuICBjbGFzc0lkOiA0MCxcbiAgbWV0aG9kSWQ6IDIxLFxuICBuYW1lOiBcIkV4Y2hhbmdlRGVsZXRlT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkV4Y2hhbmdlQmluZCA9IDI2MjE0NzA7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VCaW5kID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0V4Y2hhbmdlQmluZCA9IHtcbiAgaWQ6IDI2MjE0NzAsXG4gIGNsYXNzSWQ6IDQwLFxuICBtZXRob2RJZDogMzAsXG4gIG5hbWU6IFwiRXhjaGFuZ2VCaW5kXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImRlc3RpbmF0aW9uXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInNvdXJjZVwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJyb3V0aW5nS2V5XCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJhcmd1bWVudHNcIixcbiAgICBkZWZhdWx0OiB7fVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkV4Y2hhbmdlQmluZE9rID0gMjYyMTQ3MTtcblxudmFyIG1ldGhvZEluZm9FeGNoYW5nZUJpbmRPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9FeGNoYW5nZUJpbmRPayA9IHtcbiAgaWQ6IDI2MjE0NzEsXG4gIGNsYXNzSWQ6IDQwLFxuICBtZXRob2RJZDogMzEsXG4gIG5hbWU6IFwiRXhjaGFuZ2VCaW5kT2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLkV4Y2hhbmdlVW5iaW5kID0gMjYyMTQ4MDtcblxudmFyIG1ldGhvZEluZm9FeGNoYW5nZVVuYmluZCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9FeGNoYW5nZVVuYmluZCA9IHtcbiAgaWQ6IDI2MjE0ODAsXG4gIGNsYXNzSWQ6IDQwLFxuICBtZXRob2RJZDogNDAsXG4gIG5hbWU6IFwiRXhjaGFuZ2VVbmJpbmRcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZGVzdGluYXRpb25cIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwic291cmNlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImFyZ3VtZW50c1wiLFxuICAgIGRlZmF1bHQ6IHt9XG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuRXhjaGFuZ2VVbmJpbmRPayA9IDI2MjE0OTE7XG5cbnZhciBtZXRob2RJbmZvRXhjaGFuZ2VVbmJpbmRPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9FeGNoYW5nZVVuYmluZE9rID0ge1xuICBpZDogMjYyMTQ5MSxcbiAgY2xhc3NJZDogNDAsXG4gIG1ldGhvZElkOiA1MSxcbiAgbmFtZTogXCJFeGNoYW5nZVVuYmluZE9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZURlY2xhcmUgPSAzMjc2ODEwO1xuXG52YXIgbWV0aG9kSW5mb1F1ZXVlRGVjbGFyZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZURlY2xhcmUgPSB7XG4gIGlkOiAzMjc2ODEwLFxuICBjbGFzc0lkOiA1MCxcbiAgbWV0aG9kSWQ6IDEwLFxuICBuYW1lOiBcIlF1ZXVlRGVjbGFyZVwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJxdWV1ZVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJwYXNzaXZlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJkdXJhYmxlXCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJleGNsdXNpdmVcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImF1dG9EZWxldGVcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0sIHtcbiAgICB0eXBlOiBcInRhYmxlXCIsXG4gICAgbmFtZTogXCJhcmd1bWVudHNcIixcbiAgICBkZWZhdWx0OiB7fVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlRGVjbGFyZU9rID0gMzI3NjgxMTtcblxudmFyIG1ldGhvZEluZm9RdWV1ZURlY2xhcmVPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZURlY2xhcmVPayA9IHtcbiAgaWQ6IDMyNzY4MTEsXG4gIGNsYXNzSWQ6IDUwLFxuICBtZXRob2RJZDogMTEsXG4gIG5hbWU6IFwiUXVldWVEZWNsYXJlT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicXVldWVcIlxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJtZXNzYWdlQ291bnRcIlxuICB9LCB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJjb25zdW1lckNvdW50XCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZUJpbmQgPSAzMjc2ODIwO1xuXG52YXIgbWV0aG9kSW5mb1F1ZXVlQmluZCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZUJpbmQgPSB7XG4gIGlkOiAzMjc2ODIwLFxuICBjbGFzc0lkOiA1MCxcbiAgbWV0aG9kSWQ6IDIwLFxuICBuYW1lOiBcIlF1ZXVlQmluZFwiLFxuICBhcmdzOiBbIHtcbiAgICB0eXBlOiBcInNob3J0XCIsXG4gICAgbmFtZTogXCJ0aWNrZXRcIixcbiAgICBkZWZhdWx0OiAwXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJxdWV1ZVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImV4Y2hhbmdlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInJvdXRpbmdLZXlcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwibm93YWl0XCIsXG4gICAgZGVmYXVsdDogITFcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImFyZ3VtZW50c1wiLFxuICAgIGRlZmF1bHQ6IHt9XG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVCaW5kT2sgPSAzMjc2ODIxO1xuXG52YXIgbWV0aG9kSW5mb1F1ZXVlQmluZE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1F1ZXVlQmluZE9rID0ge1xuICBpZDogMzI3NjgyMSxcbiAgY2xhc3NJZDogNTAsXG4gIG1ldGhvZElkOiAyMSxcbiAgbmFtZTogXCJRdWV1ZUJpbmRPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVQdXJnZSA9IDMyNzY4MzA7XG5cbnZhciBtZXRob2RJbmZvUXVldWVQdXJnZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZVB1cmdlID0ge1xuICBpZDogMzI3NjgzMCxcbiAgY2xhc3NJZDogNTAsXG4gIG1ldGhvZElkOiAzMCxcbiAgbmFtZTogXCJRdWV1ZVB1cmdlXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVQdXJnZU9rID0gMzI3NjgzMTtcblxudmFyIG1ldGhvZEluZm9RdWV1ZVB1cmdlT2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVQdXJnZU9rID0ge1xuICBpZDogMzI3NjgzMSxcbiAgY2xhc3NJZDogNTAsXG4gIG1ldGhvZElkOiAzMSxcbiAgbmFtZTogXCJRdWV1ZVB1cmdlT2tcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJsb25nXCIsXG4gICAgbmFtZTogXCJtZXNzYWdlQ291bnRcIlxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLlF1ZXVlRGVsZXRlID0gMzI3Njg0MDtcblxudmFyIG1ldGhvZEluZm9RdWV1ZURlbGV0ZSA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZURlbGV0ZSA9IHtcbiAgaWQ6IDMyNzY4NDAsXG4gIGNsYXNzSWQ6IDUwLFxuICBtZXRob2RJZDogNDAsXG4gIG5hbWU6IFwiUXVldWVEZWxldGVcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydFwiLFxuICAgIG5hbWU6IFwidGlja2V0XCIsXG4gICAgZGVmYXVsdDogMFxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicXVldWVcIixcbiAgICBkZWZhdWx0OiBcIlwiXG4gIH0sIHtcbiAgICB0eXBlOiBcImJpdFwiLFxuICAgIG5hbWU6IFwiaWZVbnVzZWRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcImlmRW1wdHlcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9LCB7XG4gICAgdHlwZTogXCJiaXRcIixcbiAgICBuYW1lOiBcIm5vd2FpdFwiLFxuICAgIGRlZmF1bHQ6ICExXG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVEZWxldGVPayA9IDMyNzY4NDE7XG5cbnZhciBtZXRob2RJbmZvUXVldWVEZWxldGVPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZURlbGV0ZU9rID0ge1xuICBpZDogMzI3Njg0MSxcbiAgY2xhc3NJZDogNTAsXG4gIG1ldGhvZElkOiA0MSxcbiAgbmFtZTogXCJRdWV1ZURlbGV0ZU9rXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwibG9uZ1wiLFxuICAgIG5hbWU6IFwibWVzc2FnZUNvdW50XCJcbiAgfSBdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5RdWV1ZVVuYmluZCA9IDMyNzY4NTA7XG5cbnZhciBtZXRob2RJbmZvUXVldWVVbmJpbmQgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvUXVldWVVbmJpbmQgPSB7XG4gIGlkOiAzMjc2ODUwLFxuICBjbGFzc0lkOiA1MCxcbiAgbWV0aG9kSWQ6IDUwLFxuICBuYW1lOiBcIlF1ZXVlVW5iaW5kXCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwic2hvcnRcIixcbiAgICBuYW1lOiBcInRpY2tldFwiLFxuICAgIGRlZmF1bHQ6IDBcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInF1ZXVlXCIsXG4gICAgZGVmYXVsdDogXCJcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiZXhjaGFuZ2VcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicm91dGluZ0tleVwiLFxuICAgIGRlZmF1bHQ6IFwiXCJcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImFyZ3VtZW50c1wiLFxuICAgIGRlZmF1bHQ6IHt9XG4gIH0gXVxufTtcblxubW9kdWxlLmV4cG9ydHMuUXVldWVVbmJpbmRPayA9IDMyNzY4NTE7XG5cbnZhciBtZXRob2RJbmZvUXVldWVVbmJpbmRPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9RdWV1ZVVuYmluZE9rID0ge1xuICBpZDogMzI3Njg1MSxcbiAgY2xhc3NJZDogNTAsXG4gIG1ldGhvZElkOiA1MSxcbiAgbmFtZTogXCJRdWV1ZVVuYmluZE9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UeFNlbGVjdCA9IDU4OTgyNTA7XG5cbnZhciBtZXRob2RJbmZvVHhTZWxlY3QgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvVHhTZWxlY3QgPSB7XG4gIGlkOiA1ODk4MjUwLFxuICBjbGFzc0lkOiA5MCxcbiAgbWV0aG9kSWQ6IDEwLFxuICBuYW1lOiBcIlR4U2VsZWN0XCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UeFNlbGVjdE9rID0gNTg5ODI1MTtcblxudmFyIG1ldGhvZEluZm9UeFNlbGVjdE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb1R4U2VsZWN0T2sgPSB7XG4gIGlkOiA1ODk4MjUxLFxuICBjbGFzc0lkOiA5MCxcbiAgbWV0aG9kSWQ6IDExLFxuICBuYW1lOiBcIlR4U2VsZWN0T2tcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLlR4Q29tbWl0ID0gNTg5ODI2MDtcblxudmFyIG1ldGhvZEluZm9UeENvbW1pdCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9UeENvbW1pdCA9IHtcbiAgaWQ6IDU4OTgyNjAsXG4gIGNsYXNzSWQ6IDkwLFxuICBtZXRob2RJZDogMjAsXG4gIG5hbWU6IFwiVHhDb21taXRcIixcbiAgYXJnczogW11cbn07XG5cbm1vZHVsZS5leHBvcnRzLlR4Q29tbWl0T2sgPSA1ODk4MjYxO1xuXG52YXIgbWV0aG9kSW5mb1R4Q29tbWl0T2sgPSBtb2R1bGUuZXhwb3J0cy5tZXRob2RJbmZvVHhDb21taXRPayA9IHtcbiAgaWQ6IDU4OTgyNjEsXG4gIGNsYXNzSWQ6IDkwLFxuICBtZXRob2RJZDogMjEsXG4gIG5hbWU6IFwiVHhDb21taXRPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuVHhSb2xsYmFjayA9IDU4OTgyNzA7XG5cbnZhciBtZXRob2RJbmZvVHhSb2xsYmFjayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9UeFJvbGxiYWNrID0ge1xuICBpZDogNTg5ODI3MCxcbiAgY2xhc3NJZDogOTAsXG4gIG1ldGhvZElkOiAzMCxcbiAgbmFtZTogXCJUeFJvbGxiYWNrXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5UeFJvbGxiYWNrT2sgPSA1ODk4MjcxO1xuXG52YXIgbWV0aG9kSW5mb1R4Um9sbGJhY2tPayA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9UeFJvbGxiYWNrT2sgPSB7XG4gIGlkOiA1ODk4MjcxLFxuICBjbGFzc0lkOiA5MCxcbiAgbWV0aG9kSWQ6IDMxLFxuICBuYW1lOiBcIlR4Um9sbGJhY2tPa1wiLFxuICBhcmdzOiBbXVxufTtcblxubW9kdWxlLmV4cG9ydHMuQ29uZmlybVNlbGVjdCA9IDU1NzA1NzA7XG5cbnZhciBtZXRob2RJbmZvQ29uZmlybVNlbGVjdCA9IG1vZHVsZS5leHBvcnRzLm1ldGhvZEluZm9Db25maXJtU2VsZWN0ID0ge1xuICBpZDogNTU3MDU3MCxcbiAgY2xhc3NJZDogODUsXG4gIG1ldGhvZElkOiAxMCxcbiAgbmFtZTogXCJDb25maXJtU2VsZWN0XCIsXG4gIGFyZ3M6IFsge1xuICAgIHR5cGU6IFwiYml0XCIsXG4gICAgbmFtZTogXCJub3dhaXRcIixcbiAgICBkZWZhdWx0OiAhMVxuICB9IF1cbn07XG5cbm1vZHVsZS5leHBvcnRzLkNvbmZpcm1TZWxlY3RPayA9IDU1NzA1NzE7XG5cbnZhciBtZXRob2RJbmZvQ29uZmlybVNlbGVjdE9rID0gbW9kdWxlLmV4cG9ydHMubWV0aG9kSW5mb0NvbmZpcm1TZWxlY3RPayA9IHtcbiAgaWQ6IDU1NzA1NzEsXG4gIGNsYXNzSWQ6IDg1LFxuICBtZXRob2RJZDogMTEsXG4gIG5hbWU6IFwiQ29uZmlybVNlbGVjdE9rXCIsXG4gIGFyZ3M6IFtdXG59O1xuXG5tb2R1bGUuZXhwb3J0cy5CYXNpY1Byb3BlcnRpZXMgPSA2MDtcblxudmFyIHByb3BlcnRpZXNJbmZvQmFzaWNQcm9wZXJ0aWVzID0gbW9kdWxlLmV4cG9ydHMucHJvcGVydGllc0luZm9CYXNpY1Byb3BlcnRpZXMgPSB7XG4gIGlkOiA2MCxcbiAgbmFtZTogXCJCYXNpY1Byb3BlcnRpZXNcIixcbiAgYXJnczogWyB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29udGVudFR5cGVcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwiY29udGVudEVuY29kaW5nXCJcbiAgfSwge1xuICAgIHR5cGU6IFwidGFibGVcIixcbiAgICBuYW1lOiBcImhlYWRlcnNcIlxuICB9LCB7XG4gICAgdHlwZTogXCJvY3RldFwiLFxuICAgIG5hbWU6IFwiZGVsaXZlcnlNb2RlXCJcbiAgfSwge1xuICAgIHR5cGU6IFwib2N0ZXRcIixcbiAgICBuYW1lOiBcInByaW9yaXR5XCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNvcnJlbGF0aW9uSWRcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwicmVwbHlUb1wiXG4gIH0sIHtcbiAgICB0eXBlOiBcInNob3J0c3RyXCIsXG4gICAgbmFtZTogXCJleHBpcmF0aW9uXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcIm1lc3NhZ2VJZFwiXG4gIH0sIHtcbiAgICB0eXBlOiBcInRpbWVzdGFtcFwiLFxuICAgIG5hbWU6IFwidGltZXN0YW1wXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcInR5cGVcIlxuICB9LCB7XG4gICAgdHlwZTogXCJzaG9ydHN0clwiLFxuICAgIG5hbWU6IFwidXNlcklkXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImFwcElkXCJcbiAgfSwge1xuICAgIHR5cGU6IFwic2hvcnRzdHJcIixcbiAgICBuYW1lOiBcImNsdXN0ZXJJZFwiXG4gIH0gXVxufTsiXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/defs.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/error.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/error.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("var inherits = (__webpack_require__(/*! util */ \"util\").inherits);\n\nfunction trimStack(stack, num) {\n  return stack && stack.split('\\n').slice(num).join('\\n');\n}\n\nfunction IllegalOperationError(msg, stack) {\n  var tmp = new Error();\n  this.message = msg;\n  this.stack = this.toString() + '\\n' + trimStack(tmp.stack, 2);\n  this.stackAtStateChange = stack;\n}\ninherits(IllegalOperationError, Error);\n\nIllegalOperationError.prototype.name = 'IllegalOperationError';\n\nfunction stackCapture(reason) {\n  var e = new Error();\n  return 'Stack capture: ' + reason + '\\n' +\n    trimStack(e.stack, 2);\n}\n\nmodule.exports.IllegalOperationError = IllegalOperationError;\nmodule.exports.stackCapture = stackCapture;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZXJyb3IuanMiLCJtYXBwaW5ncyI6IkFBQUEsZUFBZSxrREFBd0I7O0FBRXZDO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9DQUFvQztBQUNwQywyQkFBMkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIyLy4vbm9kZV9tb2R1bGVzL2FtcXBsaWIvbGliL2Vycm9yLmpzP2M4ZGMiXSwic291cmNlc0NvbnRlbnQiOlsidmFyIGluaGVyaXRzID0gcmVxdWlyZSgndXRpbCcpLmluaGVyaXRzO1xuXG5mdW5jdGlvbiB0cmltU3RhY2soc3RhY2ssIG51bSkge1xuICByZXR1cm4gc3RhY2sgJiYgc3RhY2suc3BsaXQoJ1xcbicpLnNsaWNlKG51bSkuam9pbignXFxuJyk7XG59XG5cbmZ1bmN0aW9uIElsbGVnYWxPcGVyYXRpb25FcnJvcihtc2csIHN0YWNrKSB7XG4gIHZhciB0bXAgPSBuZXcgRXJyb3IoKTtcbiAgdGhpcy5tZXNzYWdlID0gbXNnO1xuICB0aGlzLnN0YWNrID0gdGhpcy50b1N0cmluZygpICsgJ1xcbicgKyB0cmltU3RhY2sodG1wLnN0YWNrLCAyKTtcbiAgdGhpcy5zdGFja0F0U3RhdGVDaGFuZ2UgPSBzdGFjaztcbn1cbmluaGVyaXRzKElsbGVnYWxPcGVyYXRpb25FcnJvciwgRXJyb3IpO1xuXG5JbGxlZ2FsT3BlcmF0aW9uRXJyb3IucHJvdG90eXBlLm5hbWUgPSAnSWxsZWdhbE9wZXJhdGlvbkVycm9yJztcblxuZnVuY3Rpb24gc3RhY2tDYXB0dXJlKHJlYXNvbikge1xuICB2YXIgZSA9IG5ldyBFcnJvcigpO1xuICByZXR1cm4gJ1N0YWNrIGNhcHR1cmU6ICcgKyByZWFzb24gKyAnXFxuJyArXG4gICAgdHJpbVN0YWNrKGUuc3RhY2ssIDIpO1xufVxuXG5tb2R1bGUuZXhwb3J0cy5JbGxlZ2FsT3BlcmF0aW9uRXJyb3IgPSBJbGxlZ2FsT3BlcmF0aW9uRXJyb3I7XG5tb2R1bGUuZXhwb3J0cy5zdGFja0NhcHR1cmUgPSBzdGFja0NhcHR1cmU7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/error.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/format.js":
/*!********************************************!*\
  !*** ./node_modules/amqplib/lib/format.js ***!
  \********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("//\n//\n//\n\n// Stringifying various things\n\n\n\nvar defs = __webpack_require__(/*! ./defs */ \"(rsc)/./node_modules/amqplib/lib/defs.js\");\nvar format = (__webpack_require__(/*! util */ \"util\").format);\nvar HEARTBEAT = (__webpack_require__(/*! ./frame */ \"(rsc)/./node_modules/amqplib/lib/frame.js\").HEARTBEAT);\n\nmodule.exports.closeMessage = function(close) {\n  var code = close.fields.replyCode;\n  return format('%d (%s) with message \"%s\"',\n                code, defs.constant_strs[code],\n                close.fields.replyText);\n}\n\nmodule.exports.methodName = function(id) {\n  return defs.info(id).name;\n};\n\nmodule.exports.inspect = function(frame, showFields) {\n  if (frame === HEARTBEAT) {\n    return '<Heartbeat>';\n  }\n  else if (!frame.id) {\n    return format('<Content channel:%d size:%d>',\n                  frame.channel, frame.size);\n  }\n  else {\n    var info = defs.info(frame.id);\n    return format('<%s channel:%d%s>', info.name, frame.channel,\n                  (showFields)\n                  ? ' ' + JSON.stringify(frame.fields, undefined, 2)\n                  : '');\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZm9ybWF0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFYTs7QUFFYixXQUFXLG1CQUFPLENBQUMsd0RBQVE7QUFDM0IsYUFBYSxnREFBc0I7QUFDbkMsZ0JBQWdCLDJGQUE0Qjs7QUFFNUMsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUEsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjIvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZm9ybWF0LmpzPzdmYjAiXSwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vXG4vL1xuXG4vLyBTdHJpbmdpZnlpbmcgdmFyaW91cyB0aGluZ3NcblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmcyA9IHJlcXVpcmUoJy4vZGVmcycpO1xudmFyIGZvcm1hdCA9IHJlcXVpcmUoJ3V0aWwnKS5mb3JtYXQ7XG52YXIgSEVBUlRCRUFUID0gcmVxdWlyZSgnLi9mcmFtZScpLkhFQVJUQkVBVDtcblxubW9kdWxlLmV4cG9ydHMuY2xvc2VNZXNzYWdlID0gZnVuY3Rpb24oY2xvc2UpIHtcbiAgdmFyIGNvZGUgPSBjbG9zZS5maWVsZHMucmVwbHlDb2RlO1xuICByZXR1cm4gZm9ybWF0KCclZCAoJXMpIHdpdGggbWVzc2FnZSBcIiVzXCInLFxuICAgICAgICAgICAgICAgIGNvZGUsIGRlZnMuY29uc3RhbnRfc3Ryc1tjb2RlXSxcbiAgICAgICAgICAgICAgICBjbG9zZS5maWVsZHMucmVwbHlUZXh0KTtcbn1cblxubW9kdWxlLmV4cG9ydHMubWV0aG9kTmFtZSA9IGZ1bmN0aW9uKGlkKSB7XG4gIHJldHVybiBkZWZzLmluZm8oaWQpLm5hbWU7XG59O1xuXG5tb2R1bGUuZXhwb3J0cy5pbnNwZWN0ID0gZnVuY3Rpb24oZnJhbWUsIHNob3dGaWVsZHMpIHtcbiAgaWYgKGZyYW1lID09PSBIRUFSVEJFQVQpIHtcbiAgICByZXR1cm4gJzxIZWFydGJlYXQ+JztcbiAgfVxuICBlbHNlIGlmICghZnJhbWUuaWQpIHtcbiAgICByZXR1cm4gZm9ybWF0KCc8Q29udGVudCBjaGFubmVsOiVkIHNpemU6JWQ+JyxcbiAgICAgICAgICAgICAgICAgIGZyYW1lLmNoYW5uZWwsIGZyYW1lLnNpemUpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBpbmZvID0gZGVmcy5pbmZvKGZyYW1lLmlkKTtcbiAgICByZXR1cm4gZm9ybWF0KCc8JXMgY2hhbm5lbDolZCVzPicsIGluZm8ubmFtZSwgZnJhbWUuY2hhbm5lbCxcbiAgICAgICAgICAgICAgICAgIChzaG93RmllbGRzKVxuICAgICAgICAgICAgICAgICAgPyAnICcgKyBKU09OLnN0cmluZ2lmeShmcmFtZS5maWVsZHMsIHVuZGVmaW5lZCwgMilcbiAgICAgICAgICAgICAgICAgIDogJycpO1xuICB9XG59XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/format.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/frame.js":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/lib/frame.js ***!
  \*******************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// The river sweeps through\n// Silt and twigs, gravel and leaves\n// Driving the wheel on\n\n\n\nvar defs = __webpack_require__(/*! ./defs */ \"(rsc)/./node_modules/amqplib/lib/defs.js\");\nvar constants = defs.constants;\nvar decode = defs.decode;\n\nvar Bits = __webpack_require__(/*! @acuminous/bitsyntax */ \"(rsc)/./node_modules/@acuminous/bitsyntax/index.js\");\n\nmodule.exports.PROTOCOL_HEADER = \"AMQP\" + String.fromCharCode(0, 0, 9, 1);\n\n/*\n  Frame format:\n\n  0      1         3             7                size+7 size+8\n  +------+---------+-------------+ +------------+ +-----------+\n  | type | channel | size        | | payload    | | frame-end |\n  +------+---------+-------------+ +------------+ +-----------+\n  octet   short     long            size octets    octet\n\n  In general I want to know those first three things straight away, so I\n  can discard frames early.\n\n*/\n\n// framing constants\nvar FRAME_METHOD = constants.FRAME_METHOD,\nFRAME_HEARTBEAT = constants.FRAME_HEARTBEAT,\nFRAME_HEADER = constants.FRAME_HEADER,\nFRAME_BODY = constants.FRAME_BODY,\nFRAME_END = constants.FRAME_END;\n\nvar bodyCons =\n  Bits.builder(FRAME_BODY,\n               'channel:16, size:32, payload:size/binary',\n               FRAME_END);\n\n// %%% TESTME possibly better to cons the first bit and write the\n// second directly, in the absence of IO lists\nmodule.exports.makeBodyFrame = function(channel, payload) {\n  return bodyCons({channel: channel, size: payload.length, payload: payload});\n};\n\nvar frameHeaderPattern = Bits.matcher('type:8', 'channel:16',\n                                      'size:32', 'rest/binary');\n\nfunction parseFrame(bin, max) {\n  var fh = frameHeaderPattern(bin);\n  if (fh) {\n    var size = fh.size, rest = fh.rest;\n    if (size > max) {\n      throw new Error('Frame size exceeds frame max');\n    }\n    else if (rest.length > size) {\n      if (rest[size] !== FRAME_END)\n        throw new Error('Invalid frame');\n\n      return {\n        type: fh.type,\n        channel: fh.channel,\n        size: size,\n        payload: rest.slice(0, size),\n        rest: rest.slice(size + 1)\n      };\n    }\n  }\n  return false;\n}\n\nmodule.exports.parseFrame = parseFrame;\n\nvar headerPattern = Bits.matcher('class:16',\n                                 '_weight:16',\n                                 'size:64',\n                                 'flagsAndfields/binary');\n\nvar methodPattern = Bits.matcher('id:32, args/binary');\n\nvar HEARTBEAT = {channel: 0};\n\nmodule.exports.decodeFrame = function(frame) {\n  var payload = frame.payload;\n  switch (frame.type) {\n  case FRAME_METHOD:\n    var idAndArgs = methodPattern(payload);\n    var id = idAndArgs.id;\n    var fields = decode(id, idAndArgs.args);\n    return {id: id, channel: frame.channel, fields: fields};\n  case FRAME_HEADER:\n    var parts = headerPattern(payload);\n    var id = parts['class'];\n    var fields = decode(id, parts.flagsAndfields);\n    return {id: id, channel: frame.channel,\n            size: parts.size, fields: fields};\n  case FRAME_BODY:\n    return {channel: frame.channel, content: frame.payload};\n  case FRAME_HEARTBEAT:\n    return HEARTBEAT;\n  default:\n    throw new Error('Unknown frame type ' + frame.type);\n  }\n}\n\n// encoded heartbeat\nmodule.exports.HEARTBEAT_BUF = Buffer.from([constants.FRAME_HEARTBEAT,\n                                           0, 0, 0, 0, // size = 0\n                                           0, 0, // channel = 0\n                                           constants.FRAME_END]);\n\nmodule.exports.HEARTBEAT = HEARTBEAT;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZnJhbWUuanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTtBQUNBOztBQUVhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyx3REFBUTtBQUMzQjtBQUNBOztBQUVBLFdBQVcsbUJBQU8sQ0FBQyxnRkFBc0I7O0FBRXpDLDhCQUE4Qjs7QUFFOUI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSw0QkFBNEI7QUFDNUIsbUJBQW1CLHlEQUF5RDtBQUM1RTs7QUFFQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEseUJBQXlCOztBQUV6QjtBQUNBO0FBQ0E7QUFDQTs7QUFFQTs7QUFFQSxpQkFBaUI7O0FBRWpCLDBCQUEwQjtBQUMxQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSw0QkFBNEI7QUFDNUI7QUFDQTtBQUNBOztBQUVBLHdCQUF3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjIvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvZnJhbWUuanM/OTk4ZCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBUaGUgcml2ZXIgc3dlZXBzIHRocm91Z2hcbi8vIFNpbHQgYW5kIHR3aWdzLCBncmF2ZWwgYW5kIGxlYXZlc1xuLy8gRHJpdmluZyB0aGUgd2hlZWwgb25cblxuJ3VzZSBzdHJpY3QnO1xuXG52YXIgZGVmcyA9IHJlcXVpcmUoJy4vZGVmcycpO1xudmFyIGNvbnN0YW50cyA9IGRlZnMuY29uc3RhbnRzO1xudmFyIGRlY29kZSA9IGRlZnMuZGVjb2RlO1xuXG52YXIgQml0cyA9IHJlcXVpcmUoJ0BhY3VtaW5vdXMvYml0c3ludGF4Jyk7XG5cbm1vZHVsZS5leHBvcnRzLlBST1RPQ09MX0hFQURFUiA9IFwiQU1RUFwiICsgU3RyaW5nLmZyb21DaGFyQ29kZSgwLCAwLCA5LCAxKTtcblxuLypcbiAgRnJhbWUgZm9ybWF0OlxuXG4gIDAgICAgICAxICAgICAgICAgMyAgICAgICAgICAgICA3ICAgICAgICAgICAgICAgIHNpemUrNyBzaXplKzhcbiAgKy0tLS0tLSstLS0tLS0tLS0rLS0tLS0tLS0tLS0tLSsgKy0tLS0tLS0tLS0tLSsgKy0tLS0tLS0tLS0tK1xuICB8IHR5cGUgfCBjaGFubmVsIHwgc2l6ZSAgICAgICAgfCB8IHBheWxvYWQgICAgfCB8IGZyYW1lLWVuZCB8XG4gICstLS0tLS0rLS0tLS0tLS0tKy0tLS0tLS0tLS0tLS0rICstLS0tLS0tLS0tLS0rICstLS0tLS0tLS0tLStcbiAgb2N0ZXQgICBzaG9ydCAgICAgbG9uZyAgICAgICAgICAgIHNpemUgb2N0ZXRzICAgIG9jdGV0XG5cbiAgSW4gZ2VuZXJhbCBJIHdhbnQgdG8ga25vdyB0aG9zZSBmaXJzdCB0aHJlZSB0aGluZ3Mgc3RyYWlnaHQgYXdheSwgc28gSVxuICBjYW4gZGlzY2FyZCBmcmFtZXMgZWFybHkuXG5cbiovXG5cbi8vIGZyYW1pbmcgY29uc3RhbnRzXG52YXIgRlJBTUVfTUVUSE9EID0gY29uc3RhbnRzLkZSQU1FX01FVEhPRCxcbkZSQU1FX0hFQVJUQkVBVCA9IGNvbnN0YW50cy5GUkFNRV9IRUFSVEJFQVQsXG5GUkFNRV9IRUFERVIgPSBjb25zdGFudHMuRlJBTUVfSEVBREVSLFxuRlJBTUVfQk9EWSA9IGNvbnN0YW50cy5GUkFNRV9CT0RZLFxuRlJBTUVfRU5EID0gY29uc3RhbnRzLkZSQU1FX0VORDtcblxudmFyIGJvZHlDb25zID1cbiAgQml0cy5idWlsZGVyKEZSQU1FX0JPRFksXG4gICAgICAgICAgICAgICAnY2hhbm5lbDoxNiwgc2l6ZTozMiwgcGF5bG9hZDpzaXplL2JpbmFyeScsXG4gICAgICAgICAgICAgICBGUkFNRV9FTkQpO1xuXG4vLyAlJSUgVEVTVE1FIHBvc3NpYmx5IGJldHRlciB0byBjb25zIHRoZSBmaXJzdCBiaXQgYW5kIHdyaXRlIHRoZVxuLy8gc2Vjb25kIGRpcmVjdGx5LCBpbiB0aGUgYWJzZW5jZSBvZiBJTyBsaXN0c1xubW9kdWxlLmV4cG9ydHMubWFrZUJvZHlGcmFtZSA9IGZ1bmN0aW9uKGNoYW5uZWwsIHBheWxvYWQpIHtcbiAgcmV0dXJuIGJvZHlDb25zKHtjaGFubmVsOiBjaGFubmVsLCBzaXplOiBwYXlsb2FkLmxlbmd0aCwgcGF5bG9hZDogcGF5bG9hZH0pO1xufTtcblxudmFyIGZyYW1lSGVhZGVyUGF0dGVybiA9IEJpdHMubWF0Y2hlcigndHlwZTo4JywgJ2NoYW5uZWw6MTYnLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTozMicsICdyZXN0L2JpbmFyeScpO1xuXG5mdW5jdGlvbiBwYXJzZUZyYW1lKGJpbiwgbWF4KSB7XG4gIHZhciBmaCA9IGZyYW1lSGVhZGVyUGF0dGVybihiaW4pO1xuICBpZiAoZmgpIHtcbiAgICB2YXIgc2l6ZSA9IGZoLnNpemUsIHJlc3QgPSBmaC5yZXN0O1xuICAgIGlmIChzaXplID4gbWF4KSB7XG4gICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ZyYW1lIHNpemUgZXhjZWVkcyBmcmFtZSBtYXgnKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocmVzdC5sZW5ndGggPiBzaXplKSB7XG4gICAgICBpZiAocmVzdFtzaXplXSAhPT0gRlJBTUVfRU5EKVxuICAgICAgICB0aHJvdyBuZXcgRXJyb3IoJ0ludmFsaWQgZnJhbWUnKTtcblxuICAgICAgcmV0dXJuIHtcbiAgICAgICAgdHlwZTogZmgudHlwZSxcbiAgICAgICAgY2hhbm5lbDogZmguY2hhbm5lbCxcbiAgICAgICAgc2l6ZTogc2l6ZSxcbiAgICAgICAgcGF5bG9hZDogcmVzdC5zbGljZSgwLCBzaXplKSxcbiAgICAgICAgcmVzdDogcmVzdC5zbGljZShzaXplICsgMSlcbiAgICAgIH07XG4gICAgfVxuICB9XG4gIHJldHVybiBmYWxzZTtcbn1cblxubW9kdWxlLmV4cG9ydHMucGFyc2VGcmFtZSA9IHBhcnNlRnJhbWU7XG5cbnZhciBoZWFkZXJQYXR0ZXJuID0gQml0cy5tYXRjaGVyKCdjbGFzczoxNicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnX3dlaWdodDoxNicsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnc2l6ZTo2NCcsXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAnZmxhZ3NBbmRmaWVsZHMvYmluYXJ5Jyk7XG5cbnZhciBtZXRob2RQYXR0ZXJuID0gQml0cy5tYXRjaGVyKCdpZDozMiwgYXJncy9iaW5hcnknKTtcblxudmFyIEhFQVJUQkVBVCA9IHtjaGFubmVsOiAwfTtcblxubW9kdWxlLmV4cG9ydHMuZGVjb2RlRnJhbWUgPSBmdW5jdGlvbihmcmFtZSkge1xuICB2YXIgcGF5bG9hZCA9IGZyYW1lLnBheWxvYWQ7XG4gIHN3aXRjaCAoZnJhbWUudHlwZSkge1xuICBjYXNlIEZSQU1FX01FVEhPRDpcbiAgICB2YXIgaWRBbmRBcmdzID0gbWV0aG9kUGF0dGVybihwYXlsb2FkKTtcbiAgICB2YXIgaWQgPSBpZEFuZEFyZ3MuaWQ7XG4gICAgdmFyIGZpZWxkcyA9IGRlY29kZShpZCwgaWRBbmRBcmdzLmFyZ3MpO1xuICAgIHJldHVybiB7aWQ6IGlkLCBjaGFubmVsOiBmcmFtZS5jaGFubmVsLCBmaWVsZHM6IGZpZWxkc307XG4gIGNhc2UgRlJBTUVfSEVBREVSOlxuICAgIHZhciBwYXJ0cyA9IGhlYWRlclBhdHRlcm4ocGF5bG9hZCk7XG4gICAgdmFyIGlkID0gcGFydHNbJ2NsYXNzJ107XG4gICAgdmFyIGZpZWxkcyA9IGRlY29kZShpZCwgcGFydHMuZmxhZ3NBbmRmaWVsZHMpO1xuICAgIHJldHVybiB7aWQ6IGlkLCBjaGFubmVsOiBmcmFtZS5jaGFubmVsLFxuICAgICAgICAgICAgc2l6ZTogcGFydHMuc2l6ZSwgZmllbGRzOiBmaWVsZHN9O1xuICBjYXNlIEZSQU1FX0JPRFk6XG4gICAgcmV0dXJuIHtjaGFubmVsOiBmcmFtZS5jaGFubmVsLCBjb250ZW50OiBmcmFtZS5wYXlsb2FkfTtcbiAgY2FzZSBGUkFNRV9IRUFSVEJFQVQ6XG4gICAgcmV0dXJuIEhFQVJUQkVBVDtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBuZXcgRXJyb3IoJ1Vua25vd24gZnJhbWUgdHlwZSAnICsgZnJhbWUudHlwZSk7XG4gIH1cbn1cblxuLy8gZW5jb2RlZCBoZWFydGJlYXRcbm1vZHVsZS5leHBvcnRzLkhFQVJUQkVBVF9CVUYgPSBCdWZmZXIuZnJvbShbY29uc3RhbnRzLkZSQU1FX0hFQVJUQkVBVCxcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAwLCAwLCAwLCAwLCAvLyBzaXplID0gMFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIDAsIDAsIC8vIGNoYW5uZWwgPSAwXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RhbnRzLkZSQU1FX0VORF0pO1xuXG5tb2R1bGUuZXhwb3J0cy5IRUFSVEJFQVQgPSBIRUFSVEJFQVQ7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/frame.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/heartbeat.js":
/*!***********************************************!*\
  !*** ./node_modules/amqplib/lib/heartbeat.js ***!
  \***********************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("//\n//\n//\n\n// Heartbeats. In AMQP both clients and servers may expect a heartbeat\n// frame if there is no activity on the connection for a negotiated\n// period of time. If there's no activity for two such intervals, the\n// server or client is allowed to close the connection on the\n// presumption that the other party is dead.\n//\n// The client has two jobs here: the first is to send a heartbeat\n// frame if it's not sent any frames for a while, so that the server\n// doesn't think it's dead; the second is to check periodically that\n// it's seen activity from the server, and to advise if there doesn't\n// appear to have been any for over two intervals.\n//\n// Node.JS timers are a bit unreliable, in that they endeavour only to\n// fire at some indeterminate point *after* the given time (rather\n// gives the lie to 'realtime', dunnit). Because the scheduler is just\n// an event loop, it's quite easy to delay timers indefinitely by\n// reacting to some I/O with a lot of computation.\n//\n// To mitigate this I need a bit of creative interpretation:\n//\n//  - I'll schedule a server activity check for every `interval`, and\n//    check just how much time has passed. It will overshoot by at\n//    least a small margin; modulo missing timer deadlines, it'll\n//    notice between two and three intervals after activity actually\n//    stops (otherwise, at some point after two intervals).\n//\n//  - Every `interval / 2` I'll check that we've sent something since\n//    the last check, and if not, send a heartbeat frame. If we're\n//    really too busy to even run the check for two whole heartbeat\n//    intervals, there must be a lot of I (but not O, at least not on\n//    the connection), or computation, in which case perhaps it's best\n//    the server cuts us off anyway. Why `interval / 2`? Because the\n//    edge case is that the client sent a frame just after a\n//    heartbeat, which would mean I only send one after almost two\n//    intervals. (NB a heartbeat counts as a send, so it'll be checked\n//    at least twice before sending another)\n//\n// This design is based largely on RabbitMQ's heartbeating:\n// https://github.com/rabbitmq/rabbitmq-common/blob/master/src/rabbit_heartbeat.erl\n\n// %% Yes, I could apply the same 'actually passage of time' thing to\n// %% send as well as to recv.\n\n\n\nvar EventEmitter = __webpack_require__(/*! events */ \"events\");\n\n// Exported so that we can mess with it in tests\nmodule.exports.UNITS_TO_MS = 1000;\n\nclass Heart extends EventEmitter {\n  constructor (interval, checkSend, checkRecv) {\n    super();\n\n    this.interval = interval;\n\n    var intervalMs = interval * module.exports.UNITS_TO_MS;\n    // Function#bind is my new best friend\n    var beat = this.emit.bind(this, 'beat');\n    var timeout = this.emit.bind(this, 'timeout');\n\n    this.sendTimer = setInterval(\n      this.runHeartbeat.bind(this, checkSend, beat), intervalMs / 2);\n\n    // A timeout occurs if I see nothing for *two consecutive* intervals\n    var recvMissed = 0;\n    function missedTwo () {\n      if (!checkRecv())\n        return (++recvMissed < 2);\n      else { recvMissed = 0; return true; }\n    }\n    this.recvTimer = setInterval(\n      this.runHeartbeat.bind(this, missedTwo, timeout), intervalMs);\n  }\n\n  clear () {\n    clearInterval(this.sendTimer);\n    clearInterval(this.recvTimer);\n  }\n\n  runHeartbeat (check, fail) {\n    // Have we seen activity?\n    if (!check())\n      fail();\n  }\n}\n\nmodule.exports.Heart = Heart;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvaGVhcnRiZWF0LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRWE7O0FBRWIsbUJBQW1CLG1CQUFPLENBQUMsc0JBQVE7O0FBRW5DO0FBQ0EsMEJBQTBCOztBQUUxQjtBQUNBO0FBQ0E7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYSxnQkFBZ0I7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQiIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjIvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvaGVhcnRiZWF0LmpzPzk5MjYiXSwic291cmNlc0NvbnRlbnQiOlsiLy9cbi8vXG4vL1xuXG4vLyBIZWFydGJlYXRzLiBJbiBBTVFQIGJvdGggY2xpZW50cyBhbmQgc2VydmVycyBtYXkgZXhwZWN0IGEgaGVhcnRiZWF0XG4vLyBmcmFtZSBpZiB0aGVyZSBpcyBubyBhY3Rpdml0eSBvbiB0aGUgY29ubmVjdGlvbiBmb3IgYSBuZWdvdGlhdGVkXG4vLyBwZXJpb2Qgb2YgdGltZS4gSWYgdGhlcmUncyBubyBhY3Rpdml0eSBmb3IgdHdvIHN1Y2ggaW50ZXJ2YWxzLCB0aGVcbi8vIHNlcnZlciBvciBjbGllbnQgaXMgYWxsb3dlZCB0byBjbG9zZSB0aGUgY29ubmVjdGlvbiBvbiB0aGVcbi8vIHByZXN1bXB0aW9uIHRoYXQgdGhlIG90aGVyIHBhcnR5IGlzIGRlYWQuXG4vL1xuLy8gVGhlIGNsaWVudCBoYXMgdHdvIGpvYnMgaGVyZTogdGhlIGZpcnN0IGlzIHRvIHNlbmQgYSBoZWFydGJlYXRcbi8vIGZyYW1lIGlmIGl0J3Mgbm90IHNlbnQgYW55IGZyYW1lcyBmb3IgYSB3aGlsZSwgc28gdGhhdCB0aGUgc2VydmVyXG4vLyBkb2Vzbid0IHRoaW5rIGl0J3MgZGVhZDsgdGhlIHNlY29uZCBpcyB0byBjaGVjayBwZXJpb2RpY2FsbHkgdGhhdFxuLy8gaXQncyBzZWVuIGFjdGl2aXR5IGZyb20gdGhlIHNlcnZlciwgYW5kIHRvIGFkdmlzZSBpZiB0aGVyZSBkb2Vzbid0XG4vLyBhcHBlYXIgdG8gaGF2ZSBiZWVuIGFueSBmb3Igb3ZlciB0d28gaW50ZXJ2YWxzLlxuLy9cbi8vIE5vZGUuSlMgdGltZXJzIGFyZSBhIGJpdCB1bnJlbGlhYmxlLCBpbiB0aGF0IHRoZXkgZW5kZWF2b3VyIG9ubHkgdG9cbi8vIGZpcmUgYXQgc29tZSBpbmRldGVybWluYXRlIHBvaW50ICphZnRlciogdGhlIGdpdmVuIHRpbWUgKHJhdGhlclxuLy8gZ2l2ZXMgdGhlIGxpZSB0byAncmVhbHRpbWUnLCBkdW5uaXQpLiBCZWNhdXNlIHRoZSBzY2hlZHVsZXIgaXMganVzdFxuLy8gYW4gZXZlbnQgbG9vcCwgaXQncyBxdWl0ZSBlYXN5IHRvIGRlbGF5IHRpbWVycyBpbmRlZmluaXRlbHkgYnlcbi8vIHJlYWN0aW5nIHRvIHNvbWUgSS9PIHdpdGggYSBsb3Qgb2YgY29tcHV0YXRpb24uXG4vL1xuLy8gVG8gbWl0aWdhdGUgdGhpcyBJIG5lZWQgYSBiaXQgb2YgY3JlYXRpdmUgaW50ZXJwcmV0YXRpb246XG4vL1xuLy8gIC0gSSdsbCBzY2hlZHVsZSBhIHNlcnZlciBhY3Rpdml0eSBjaGVjayBmb3IgZXZlcnkgYGludGVydmFsYCwgYW5kXG4vLyAgICBjaGVjayBqdXN0IGhvdyBtdWNoIHRpbWUgaGFzIHBhc3NlZC4gSXQgd2lsbCBvdmVyc2hvb3QgYnkgYXRcbi8vICAgIGxlYXN0IGEgc21hbGwgbWFyZ2luOyBtb2R1bG8gbWlzc2luZyB0aW1lciBkZWFkbGluZXMsIGl0J2xsXG4vLyAgICBub3RpY2UgYmV0d2VlbiB0d28gYW5kIHRocmVlIGludGVydmFscyBhZnRlciBhY3Rpdml0eSBhY3R1YWxseVxuLy8gICAgc3RvcHMgKG90aGVyd2lzZSwgYXQgc29tZSBwb2ludCBhZnRlciB0d28gaW50ZXJ2YWxzKS5cbi8vXG4vLyAgLSBFdmVyeSBgaW50ZXJ2YWwgLyAyYCBJJ2xsIGNoZWNrIHRoYXQgd2UndmUgc2VudCBzb21ldGhpbmcgc2luY2Vcbi8vICAgIHRoZSBsYXN0IGNoZWNrLCBhbmQgaWYgbm90LCBzZW5kIGEgaGVhcnRiZWF0IGZyYW1lLiBJZiB3ZSdyZVxuLy8gICAgcmVhbGx5IHRvbyBidXN5IHRvIGV2ZW4gcnVuIHRoZSBjaGVjayBmb3IgdHdvIHdob2xlIGhlYXJ0YmVhdFxuLy8gICAgaW50ZXJ2YWxzLCB0aGVyZSBtdXN0IGJlIGEgbG90IG9mIEkgKGJ1dCBub3QgTywgYXQgbGVhc3Qgbm90IG9uXG4vLyAgICB0aGUgY29ubmVjdGlvbiksIG9yIGNvbXB1dGF0aW9uLCBpbiB3aGljaCBjYXNlIHBlcmhhcHMgaXQncyBiZXN0XG4vLyAgICB0aGUgc2VydmVyIGN1dHMgdXMgb2ZmIGFueXdheS4gV2h5IGBpbnRlcnZhbCAvIDJgPyBCZWNhdXNlIHRoZVxuLy8gICAgZWRnZSBjYXNlIGlzIHRoYXQgdGhlIGNsaWVudCBzZW50IGEgZnJhbWUganVzdCBhZnRlciBhXG4vLyAgICBoZWFydGJlYXQsIHdoaWNoIHdvdWxkIG1lYW4gSSBvbmx5IHNlbmQgb25lIGFmdGVyIGFsbW9zdCB0d29cbi8vICAgIGludGVydmFscy4gKE5CIGEgaGVhcnRiZWF0IGNvdW50cyBhcyBhIHNlbmQsIHNvIGl0J2xsIGJlIGNoZWNrZWRcbi8vICAgIGF0IGxlYXN0IHR3aWNlIGJlZm9yZSBzZW5kaW5nIGFub3RoZXIpXG4vL1xuLy8gVGhpcyBkZXNpZ24gaXMgYmFzZWQgbGFyZ2VseSBvbiBSYWJiaXRNUSdzIGhlYXJ0YmVhdGluZzpcbi8vIGh0dHBzOi8vZ2l0aHViLmNvbS9yYWJiaXRtcS9yYWJiaXRtcS1jb21tb24vYmxvYi9tYXN0ZXIvc3JjL3JhYmJpdF9oZWFydGJlYXQuZXJsXG5cbi8vICUlIFllcywgSSBjb3VsZCBhcHBseSB0aGUgc2FtZSAnYWN0dWFsbHkgcGFzc2FnZSBvZiB0aW1lJyB0aGluZyB0b1xuLy8gJSUgc2VuZCBhcyB3ZWxsIGFzIHRvIHJlY3YuXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIEV2ZW50RW1pdHRlciA9IHJlcXVpcmUoJ2V2ZW50cycpO1xuXG4vLyBFeHBvcnRlZCBzbyB0aGF0IHdlIGNhbiBtZXNzIHdpdGggaXQgaW4gdGVzdHNcbm1vZHVsZS5leHBvcnRzLlVOSVRTX1RPX01TID0gMTAwMDtcblxuY2xhc3MgSGVhcnQgZXh0ZW5kcyBFdmVudEVtaXR0ZXIge1xuICBjb25zdHJ1Y3RvciAoaW50ZXJ2YWwsIGNoZWNrU2VuZCwgY2hlY2tSZWN2KSB7XG4gICAgc3VwZXIoKTtcblxuICAgIHRoaXMuaW50ZXJ2YWwgPSBpbnRlcnZhbDtcblxuICAgIHZhciBpbnRlcnZhbE1zID0gaW50ZXJ2YWwgKiBtb2R1bGUuZXhwb3J0cy5VTklUU19UT19NUztcbiAgICAvLyBGdW5jdGlvbiNiaW5kIGlzIG15IG5ldyBiZXN0IGZyaWVuZFxuICAgIHZhciBiZWF0ID0gdGhpcy5lbWl0LmJpbmQodGhpcywgJ2JlYXQnKTtcbiAgICB2YXIgdGltZW91dCA9IHRoaXMuZW1pdC5iaW5kKHRoaXMsICd0aW1lb3V0Jyk7XG5cbiAgICB0aGlzLnNlbmRUaW1lciA9IHNldEludGVydmFsKFxuICAgICAgdGhpcy5ydW5IZWFydGJlYXQuYmluZCh0aGlzLCBjaGVja1NlbmQsIGJlYXQpLCBpbnRlcnZhbE1zIC8gMik7XG5cbiAgICAvLyBBIHRpbWVvdXQgb2NjdXJzIGlmIEkgc2VlIG5vdGhpbmcgZm9yICp0d28gY29uc2VjdXRpdmUqIGludGVydmFsc1xuICAgIHZhciByZWN2TWlzc2VkID0gMDtcbiAgICBmdW5jdGlvbiBtaXNzZWRUd28gKCkge1xuICAgICAgaWYgKCFjaGVja1JlY3YoKSlcbiAgICAgICAgcmV0dXJuICgrK3JlY3ZNaXNzZWQgPCAyKTtcbiAgICAgIGVsc2UgeyByZWN2TWlzc2VkID0gMDsgcmV0dXJuIHRydWU7IH1cbiAgICB9XG4gICAgdGhpcy5yZWN2VGltZXIgPSBzZXRJbnRlcnZhbChcbiAgICAgIHRoaXMucnVuSGVhcnRiZWF0LmJpbmQodGhpcywgbWlzc2VkVHdvLCB0aW1lb3V0KSwgaW50ZXJ2YWxNcyk7XG4gIH1cblxuICBjbGVhciAoKSB7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLnNlbmRUaW1lcik7XG4gICAgY2xlYXJJbnRlcnZhbCh0aGlzLnJlY3ZUaW1lcik7XG4gIH1cblxuICBydW5IZWFydGJlYXQgKGNoZWNrLCBmYWlsKSB7XG4gICAgLy8gSGF2ZSB3ZSBzZWVuIGFjdGl2aXR5P1xuICAgIGlmICghY2hlY2soKSlcbiAgICAgIGZhaWwoKTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5IZWFydCA9IEhlYXJ0O1xuIl0sIm5hbWVzIjpbXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/heartbeat.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/lib/mux.js":
/*!*****************************************!*\
  !*** ./node_modules/amqplib/lib/mux.js ***!
  \*****************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("//\n//\n//\n\n\n\n// A Mux is an object into which other readable streams may be piped;\n// it then writes 'packets' from the upstreams to the given\n// downstream.\n\nvar assert = __webpack_require__(/*! assert */ \"assert\");\n\nvar schedule = (typeof setImmediate === 'function') ?\n  setImmediate : process.nextTick;\n\nclass Mux {\n  constructor (downstream) {\n    this.newStreams = [];\n    this.oldStreams = [];\n    this.blocked = false;\n    this.scheduledRead = false;\n\n    this.out = downstream;\n    var self = this;\n    downstream.on('drain', function () {\n      self.blocked = false;\n      self._readIncoming();\n    });\n  }\n\n  // There are 2 states we can be in:\n  // - waiting for outbound capacity, which will be signalled by a\n  // - 'drain' event on the downstream; or,\n  // - no packets to send, waiting for an inbound buffer to have\n  //   packets, which will be signalled by a 'readable' event\n  // If we write all packets available whenever there is outbound\n  // capacity, we will either run out of outbound capacity (`#write`\n  // returns false), or run out of packets (all calls to an\n  // `inbound.read()` have returned null).\n  _readIncoming () {\n\n    // We may be sent here speculatively, if an incoming stream has\n    // become readable\n    if (this.blocked) return;\n\n    var accepting = true;\n    var out = this.out;\n\n    // Try to read a chunk from each stream in turn, until all streams\n    // are empty, or we exhaust our ability to accept chunks.\n    function roundrobin (streams) {\n      var s;\n      while (accepting && (s = streams.shift())) {\n        var chunk = s.read();\n        if (chunk !== null) {\n          accepting = out.write(chunk);\n          streams.push(s);\n        }\n      }\n    }\n\n    roundrobin(this.newStreams);\n\n    // Either we exhausted the new queues, or we ran out of capacity. If\n    // we ran out of capacity, all the remaining new streams (i.e.,\n    // those with packets left) become old streams. This effectively\n    // prioritises streams that keep their buffers close to empty over\n    // those that are constantly near full.\n    if (accepting) { // all new queues are exhausted, write as many as\n      // we can from the old streams\n      assert.equal(0, this.newStreams.length);\n      roundrobin(this.oldStreams);\n    }\n    else { // ran out of room\n      assert(this.newStreams.length > 0, \"Expect some new streams to remain\");\n      Array.prototype.push.apply(this.oldStreams, this.newStreams);\n      this.newStreams = [];\n    }\n    // We may have exhausted all the old queues, or run out of room;\n    // either way, all we need to do is record whether we have capacity\n    // or not, so any speculative reads will know\n    this.blocked = !accepting;\n  }\n\n  _scheduleRead () {\n    var self = this;\n\n    if (!self.scheduledRead) {\n      schedule(function () {\n        self.scheduledRead = false;\n        self._readIncoming();\n      });\n      self.scheduledRead = true;\n    }\n  }\n\n  pipeFrom (readable) {\n    var self = this;\n\n    function enqueue () {\n      self.newStreams.push(readable);\n      self._scheduleRead();\n    }\n\n    function cleanup () {\n      readable.removeListener('readable', enqueue);\n      readable.removeListener('error', cleanup);\n      readable.removeListener('end', cleanup);\n      readable.removeListener('unpipeFrom', cleanupIfMe);\n    }\n    function cleanupIfMe (dest) {\n      if (dest === self) cleanup();\n    }\n\n    readable.on('unpipeFrom', cleanupIfMe);\n    readable.on('end', cleanup);\n    readable.on('error', cleanup);\n    readable.on('readable', enqueue);\n  }\n\n  unpipeFrom (readable) {\n    readable.emit('unpipeFrom', this);\n  }\n}\n\nmodule.exports.Mux = Mux;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYW1xcGxpYi9saWIvbXV4LmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7O0FBRUEsYUFBYSxtQkFBTyxDQUFDLHNCQUFROztBQUU3QjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxPQUFPO0FBQ1A7QUFDQTtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsa0JBQWtCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMi8uL25vZGVfbW9kdWxlcy9hbXFwbGliL2xpYi9tdXguanM/YWM5MSJdLCJzb3VyY2VzQ29udGVudCI6WyIvL1xuLy9cbi8vXG5cbid1c2Ugc3RyaWN0JztcblxuLy8gQSBNdXggaXMgYW4gb2JqZWN0IGludG8gd2hpY2ggb3RoZXIgcmVhZGFibGUgc3RyZWFtcyBtYXkgYmUgcGlwZWQ7XG4vLyBpdCB0aGVuIHdyaXRlcyAncGFja2V0cycgZnJvbSB0aGUgdXBzdHJlYW1zIHRvIHRoZSBnaXZlblxuLy8gZG93bnN0cmVhbS5cblxudmFyIGFzc2VydCA9IHJlcXVpcmUoJ2Fzc2VydCcpO1xuXG52YXIgc2NoZWR1bGUgPSAodHlwZW9mIHNldEltbWVkaWF0ZSA9PT0gJ2Z1bmN0aW9uJykgP1xuICBzZXRJbW1lZGlhdGUgOiBwcm9jZXNzLm5leHRUaWNrO1xuXG5jbGFzcyBNdXgge1xuICBjb25zdHJ1Y3RvciAoZG93bnN0cmVhbSkge1xuICAgIHRoaXMubmV3U3RyZWFtcyA9IFtdO1xuICAgIHRoaXMub2xkU3RyZWFtcyA9IFtdO1xuICAgIHRoaXMuYmxvY2tlZCA9IGZhbHNlO1xuICAgIHRoaXMuc2NoZWR1bGVkUmVhZCA9IGZhbHNlO1xuXG4gICAgdGhpcy5vdXQgPSBkb3duc3RyZWFtO1xuICAgIHZhciBzZWxmID0gdGhpcztcbiAgICBkb3duc3RyZWFtLm9uKCdkcmFpbicsIGZ1bmN0aW9uICgpIHtcbiAgICAgIHNlbGYuYmxvY2tlZCA9IGZhbHNlO1xuICAgICAgc2VsZi5fcmVhZEluY29taW5nKCk7XG4gICAgfSk7XG4gIH1cblxuICAvLyBUaGVyZSBhcmUgMiBzdGF0ZXMgd2UgY2FuIGJlIGluOlxuICAvLyAtIHdhaXRpbmcgZm9yIG91dGJvdW5kIGNhcGFjaXR5LCB3aGljaCB3aWxsIGJlIHNpZ25hbGxlZCBieSBhXG4gIC8vIC0gJ2RyYWluJyBldmVudCBvbiB0aGUgZG93bnN0cmVhbTsgb3IsXG4gIC8vIC0gbm8gcGFja2V0cyB0byBzZW5kLCB3YWl0aW5nIGZvciBhbiBpbmJvdW5kIGJ1ZmZlciB0byBoYXZlXG4gIC8vICAgcGFja2V0cywgd2hpY2ggd2lsbCBiZSBzaWduYWxsZWQgYnkgYSAncmVhZGFibGUnIGV2ZW50XG4gIC8vIElmIHdlIHdyaXRlIGFsbCBwYWNrZXRzIGF2YWlsYWJsZSB3aGVuZXZlciB0aGVyZSBpcyBvdXRib3VuZFxuICAvLyBjYXBhY2l0eSwgd2Ugd2lsbCBlaXRoZXIgcnVuIG91dCBvZiBvdXRib3VuZCBjYXBhY2l0eSAoYCN3cml0ZWBcbiAgLy8gcmV0dXJucyBmYWxzZSksIG9yIHJ1biBvdXQgb2YgcGFja2V0cyAoYWxsIGNhbGxzIHRvIGFuXG4gIC8vIGBpbmJvdW5kLnJlYWQoKWAgaGF2ZSByZXR1cm5lZCBudWxsKS5cbiAgX3JlYWRJbmNvbWluZyAoKSB7XG5cbiAgICAvLyBXZSBtYXkgYmUgc2VudCBoZXJlIHNwZWN1bGF0aXZlbHksIGlmIGFuIGluY29taW5nIHN0cmVhbSBoYXNcbiAgICAvLyBiZWNvbWUgcmVhZGFibGVcbiAgICBpZiAodGhpcy5ibG9ja2VkKSByZXR1cm47XG5cbiAgICB2YXIgYWNjZXB0aW5nID0gdHJ1ZTtcbiAgICB2YXIgb3V0ID0gdGhpcy5vdXQ7XG5cbiAgICAvLyBUcnkgdG8gcmVhZCBhIGNodW5rIGZyb20gZWFjaCBzdHJlYW0gaW4gdHVybiwgdW50aWwgYWxsIHN0cmVhbXNcbiAgICAvLyBhcmUgZW1wdHksIG9yIHdlIGV4aGF1c3Qgb3VyIGFiaWxpdHkgdG8gYWNjZXB0IGNodW5rcy5cbiAgICBmdW5jdGlvbiByb3VuZHJvYmluIChzdHJlYW1zKSB7XG4gICAgICB2YXIgcztcbiAgICAgIHdoaWxlIChhY2NlcHRpbmcgJiYgKHMgPSBzdHJlYW1zLnNoaWZ0KCkpKSB7XG4gICAgICAgIHZhciBjaHVuayA9IHMucmVhZCgpO1xuICAgICAgICBpZiAoY2h1bmsgIT09IG51bGwpIHtcbiAgICAgICAgICBhY2NlcHRpbmcgPSBvdXQud3JpdGUoY2h1bmspO1xuICAgICAgICAgIHN0cmVhbXMucHVzaChzKTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH1cblxuICAgIHJvdW5kcm9iaW4odGhpcy5uZXdTdHJlYW1zKTtcblxuICAgIC8vIEVpdGhlciB3ZSBleGhhdXN0ZWQgdGhlIG5ldyBxdWV1ZXMsIG9yIHdlIHJhbiBvdXQgb2YgY2FwYWNpdHkuIElmXG4gICAgLy8gd2UgcmFuIG91dCBvZiBjYXBhY2l0eSwgYWxsIHRoZSByZW1haW5pbmcgbmV3IHN0cmVhbXMgKGkuZS4sXG4gICAgLy8gdGhvc2Ugd2l0aCBwYWNrZXRzIGxlZnQpIGJlY29tZSBvbGQgc3RyZWFtcy4gVGhpcyBlZmZlY3RpdmVseVxuICAgIC8vIHByaW9yaXRpc2VzIHN0cmVhbXMgdGhhdCBrZWVwIHRoZWlyIGJ1ZmZlcnMgY2xvc2UgdG8gZW1wdHkgb3ZlclxuICAgIC8vIHRob3NlIHRoYXQgYXJlIGNvbnN0YW50bHkgbmVhciBmdWxsLlxuICAgIGlmIChhY2NlcHRpbmcpIHsgLy8gYWxsIG5ldyBxdWV1ZXMgYXJlIGV4aGF1c3RlZCwgd3JpdGUgYXMgbWFueSBhc1xuICAgICAgLy8gd2UgY2FuIGZyb20gdGhlIG9sZCBzdHJlYW1zXG4gICAgICBhc3NlcnQuZXF1YWwoMCwgdGhpcy5uZXdTdHJlYW1zLmxlbmd0aCk7XG4gICAgICByb3VuZHJvYmluKHRoaXMub2xkU3RyZWFtcyk7XG4gICAgfVxuICAgIGVsc2UgeyAvLyByYW4gb3V0IG9mIHJvb21cbiAgICAgIGFzc2VydCh0aGlzLm5ld1N0cmVhbXMubGVuZ3RoID4gMCwgXCJFeHBlY3Qgc29tZSBuZXcgc3RyZWFtcyB0byByZW1haW5cIik7XG4gICAgICBBcnJheS5wcm90b3R5cGUucHVzaC5hcHBseSh0aGlzLm9sZFN0cmVhbXMsIHRoaXMubmV3U3RyZWFtcyk7XG4gICAgICB0aGlzLm5ld1N0cmVhbXMgPSBbXTtcbiAgICB9XG4gICAgLy8gV2UgbWF5IGhhdmUgZXhoYXVzdGVkIGFsbCB0aGUgb2xkIHF1ZXVlcywgb3IgcnVuIG91dCBvZiByb29tO1xuICAgIC8vIGVpdGhlciB3YXksIGFsbCB3ZSBuZWVkIHRvIGRvIGlzIHJlY29yZCB3aGV0aGVyIHdlIGhhdmUgY2FwYWNpdHlcbiAgICAvLyBvciBub3QsIHNvIGFueSBzcGVjdWxhdGl2ZSByZWFkcyB3aWxsIGtub3dcbiAgICB0aGlzLmJsb2NrZWQgPSAhYWNjZXB0aW5nO1xuICB9XG5cbiAgX3NjaGVkdWxlUmVhZCAoKSB7XG4gICAgdmFyIHNlbGYgPSB0aGlzO1xuXG4gICAgaWYgKCFzZWxmLnNjaGVkdWxlZFJlYWQpIHtcbiAgICAgIHNjaGVkdWxlKGZ1bmN0aW9uICgpIHtcbiAgICAgICAgc2VsZi5zY2hlZHVsZWRSZWFkID0gZmFsc2U7XG4gICAgICAgIHNlbGYuX3JlYWRJbmNvbWluZygpO1xuICAgICAgfSk7XG4gICAgICBzZWxmLnNjaGVkdWxlZFJlYWQgPSB0cnVlO1xuICAgIH1cbiAgfVxuXG4gIHBpcGVGcm9tIChyZWFkYWJsZSkge1xuICAgIHZhciBzZWxmID0gdGhpcztcblxuICAgIGZ1bmN0aW9uIGVucXVldWUgKCkge1xuICAgICAgc2VsZi5uZXdTdHJlYW1zLnB1c2gocmVhZGFibGUpO1xuICAgICAgc2VsZi5fc2NoZWR1bGVSZWFkKCk7XG4gICAgfVxuXG4gICAgZnVuY3Rpb24gY2xlYW51cCAoKSB7XG4gICAgICByZWFkYWJsZS5yZW1vdmVMaXN0ZW5lcigncmVhZGFibGUnLCBlbnF1ZXVlKTtcbiAgICAgIHJlYWRhYmxlLnJlbW92ZUxpc3RlbmVyKCdlcnJvcicsIGNsZWFudXApO1xuICAgICAgcmVhZGFibGUucmVtb3ZlTGlzdGVuZXIoJ2VuZCcsIGNsZWFudXApO1xuICAgICAgcmVhZGFibGUucmVtb3ZlTGlzdGVuZXIoJ3VucGlwZUZyb20nLCBjbGVhbnVwSWZNZSk7XG4gICAgfVxuICAgIGZ1bmN0aW9uIGNsZWFudXBJZk1lIChkZXN0KSB7XG4gICAgICBpZiAoZGVzdCA9PT0gc2VsZikgY2xlYW51cCgpO1xuICAgIH1cblxuICAgIHJlYWRhYmxlLm9uKCd1bnBpcGVGcm9tJywgY2xlYW51cElmTWUpO1xuICAgIHJlYWRhYmxlLm9uKCdlbmQnLCBjbGVhbnVwKTtcbiAgICByZWFkYWJsZS5vbignZXJyb3InLCBjbGVhbnVwKTtcbiAgICByZWFkYWJsZS5vbigncmVhZGFibGUnLCBlbnF1ZXVlKTtcbiAgfVxuXG4gIHVucGlwZUZyb20gKHJlYWRhYmxlKSB7XG4gICAgcmVhZGFibGUuZW1pdCgndW5waXBlRnJvbScsIHRoaXMpO1xuICB9XG59XG5cbm1vZHVsZS5leHBvcnRzLk11eCA9IE11eDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/amqplib/lib/mux.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/amqplib/package.json":
/*!*******************************************!*\
  !*** ./node_modules/amqplib/package.json ***!
  \*******************************************/
/***/ ((module) => {

"use strict";
module.exports = /*#__PURE__*/JSON.parse('{"name":"amqplib","homepage":"http://amqp-node.github.io/amqplib/","main":"./channel_api.js","version":"0.10.4","description":"An AMQP 0-9-1 (e.g., RabbitMQ) library and client.","repository":{"type":"git","url":"https://github.com/amqp-node/amqplib.git"},"engines":{"node":">=10"},"dependencies":{"@acuminous/bitsyntax":"^0.1.2","buffer-more-ints":"~1.0.0","readable-stream":"1.x >=1.1.9","url-parse":"~1.5.10"},"devDependencies":{"claire":"0.4.1","mocha":"^9.2.2","nyc":"^15.1.0","uglify-js":"2.8.x"},"scripts":{"test":"make test","prepare":"make"},"keywords":["AMQP","AMQP 0-9-1","RabbitMQ"],"author":"Michael Bridgen <mikeb@squaremobius.net>","license":"MIT"}');

/***/ })

};
;