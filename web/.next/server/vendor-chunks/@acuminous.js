/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@acuminous";
exports.ids = ["vendor-chunks/@acuminous"];
exports.modules = {

/***/ "(rsc)/./node_modules/@acuminous/bitsyntax/index.js":
/*!****************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/index.js ***!
  \****************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("\n\nmodule.exports.parse = __webpack_require__(/*! ./lib/parse */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/parse.js\").parse;\nmodule.exports.match = __webpack_require__(/*! ./lib/interp */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/interp.js\").match;\nmodule.exports.build = __webpack_require__(/*! ./lib/constructor */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/constructor.js\").build;\nmodule.exports.write = __webpack_require__(/*! ./lib/constructor */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/constructor.js\").write;\n\nmodule.exports.matcher = module.exports.compile = __webpack_require__(/*! ./lib/compile */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/compile.js\").compile;\nmodule.exports.builder = __webpack_require__(/*! ./lib/compile */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/compile.js\").compile_builder;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQWE7O0FBRWIsNkhBQW1EO0FBQ25ELCtIQUFvRDtBQUNwRCx5SUFBeUQ7QUFDekQseUlBQXlEOztBQUV6RCxzQkFBc0IsR0FBRyxxSUFDUztBQUNsQyw2SUFBaUUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIyLy4vbm9kZV9tb2R1bGVzL0BhY3VtaW5vdXMvYml0c3ludGF4L2luZGV4LmpzPzQwNjUiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5tb2R1bGUuZXhwb3J0cy5wYXJzZSA9IHJlcXVpcmUoJy4vbGliL3BhcnNlJykucGFyc2U7XG5tb2R1bGUuZXhwb3J0cy5tYXRjaCA9IHJlcXVpcmUoJy4vbGliL2ludGVycCcpLm1hdGNoO1xubW9kdWxlLmV4cG9ydHMuYnVpbGQgPSByZXF1aXJlKCcuL2xpYi9jb25zdHJ1Y3RvcicpLmJ1aWxkO1xubW9kdWxlLmV4cG9ydHMud3JpdGUgPSByZXF1aXJlKCcuL2xpYi9jb25zdHJ1Y3RvcicpLndyaXRlO1xuXG5tb2R1bGUuZXhwb3J0cy5tYXRjaGVyID0gbW9kdWxlLmV4cG9ydHMuY29tcGlsZSA9XG4gIHJlcXVpcmUoJy4vbGliL2NvbXBpbGUnKS5jb21waWxlO1xubW9kdWxlLmV4cG9ydHMuYnVpbGRlciA9IHJlcXVpcmUoJy4vbGliL2NvbXBpbGUnKS5jb21waWxlX2J1aWxkZXI7XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@acuminous/bitsyntax/index.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@acuminous/bitsyntax/lib/compile.js":
/*!**********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/compile.js ***!
  \**********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Compile patterns to recognisers and constructors\n\n\n\n__webpack_require__(/*! buffer-more-ints */ \"(rsc)/./node_modules/buffer-more-ints/buffer-more-ints.js\");\nvar $ = (__webpack_require__(/*! util */ \"util\").format);\n\nvar parse = (__webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/parse.js\").parse);\nvar interp = __webpack_require__(/*! ./interp */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/interp.js\"),\n  parse_int = interp.parse_int,\n  parse_float = interp.parse_float;\nvar construct = __webpack_require__(/*! ./constructor */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/constructor.js\"),\n  write_int = construct.write_int,\n  write_float = construct.write_float;\n\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/safe-buffer/index.js\").Buffer);\n\nvar lines = [];\nfunction $start() {\n  lines = [];\n}\nfunction $line(/* format , args */) {\n  lines.push($.apply(null, arguments));\n}\nfunction $result() {\n  return lines.join('\\n');\n}\n\nfunction bits_expr(segment) {\n  if (typeof segment.size === 'string') {\n    return $('%s * %d', var_name(segment.size), segment.unit);\n  }\n  else {\n    return (segment.size * segment.unit).toString();\n  }\n}\n\nfunction get_number(segment) {\n  $line('bits = %s;\\n', bits_expr(segment));\n  var parser = (segment.type === 'integer') ?\n    'parse_int' : 'parse_float';\n  var be = segment.bigendian, sg = segment.signed;\n  $line(\"byteoffset = offset / 8; offset += bits\");\n  $line(\"if (offset > binsize) { return false; }\");\n  $line(\"else { result = %s(bin, byteoffset, bits / 8, %s, %s); }\",\n        parser, be, sg);\n}\n\nfunction get_binary(segment) {\n  $line(\"byteoffset = offset / 8;\");\n  if (segment.size === true) {\n    $line(\"offset = binsize;\");\n    $line(\"result = bin.slice(byteoffset);\");\n  }\n  else {\n    $line(\"bits = %s;\", bits_expr(segment));\n    $line(\"offset += bits;\");\n    $line(\"if (offset > binsize) { return false; }\");\n    $line(\"else { result = bin.slice(byteoffset,\",\n          \"byteoffset + bits / 8); }\");\n  }\n}\n\nfunction get_string(segment) {\n  $line(\"byteoffset = offset / 8;\");\n  var strlen = segment.value.length;\n  var strlenbits = strlen * 8;\n  $line(\"offset += %d;\", strlenbits);\n  $line(\"if (offset > binsize) { return false; }\");\n  $line(\"else { result = bin.toString(byteoffset,\",\n        $(\"byteoffset + %d); }\", strlen));\n}\n\nfunction skip_bits(segment) {\n  if (typeof segment.size === 'string') {\n    // Damn. Have to look up the size.\n    $line(\"var skipbits = %s * %d;\",\n          var_name(segment.size), segment.unit);\n    $line(\"if (offset + skipbits > binsize) { return false; }\");\n    $line(\"else { offset += skipbits; }\");\n  }\n  else if (segment.size === true) {\n    $line(\"if (offset % 8 === 0) { offset = binsize; }\");\n    $line(\"else { return false; }\");\n  }\n  else {\n    var bits = segment.unit * segment.size;\n    $line(\"if (offset + %d > binsize) { return false; }\", bits);\n    $line(\"else { offset += %d; }\", bits);\n  }\n}\n\nfunction match_seg(segment) {\n  if (segment.name === '_') {\n    skip_bits(segment);\n  }\n  else {\n    var assign_result;\n    switch (segment.type) {\n    case 'integer':\n    case 'float':\n      get_number(segment);\n      break;\n    case 'binary':\n      get_binary(segment);\n      break;\n    case 'string':\n      get_string(segment);\n      break;\n    }\n    $line(\"if (result === false) return false;\");\n    if (segment.name) {\n      // variable is given a value in the environment\n      $line(\"else if (%s !== undefined) {\", var_name(segment.name));\n      // .. and it is not the same as that matched\n      $line(\"if (%s != result) return false;\",\n            var_name(segment.name));\n      $line(\"}\");\n      // variable is free\n      $line('else %s = result;', var_name(segment.name));\n    }\n    else {\n      var repr = JSON.stringify(segment.value);\n      $line(\"else if (result != %s) return false;\", repr);\n    }\n  }\n}\n\nfunction var_name(name) {\n  return  'var_' + name;\n}\n\nfunction variables(segments) {\n  var names = {};\n  for (var i = 0; i < segments.length; i++) {\n    var name = segments[i].name;\n    if (name && name !== '_') {\n      names[name] = true;\n    }\n    name = segments[i].size;\n    if (typeof name === 'string') {\n      names[name] = true;\n    }\n  }\n  return Object.keys(names);\n}\n\nfunction compile_pattern(segments) {\n  $start();\n  $line(\"return function(binary, env) {\");\n  $line(\"'use strict';\");\n  $line(\"var bin = binary, env = env || {};\");\n  $line(\"var offset = 0, binsize = bin.length * 8;\");\n  $line(\"var bits, result, byteoffset;\");\n  var varnames = variables(segments);\n  for (var v = 0; v < varnames.length; v++) {\n    var name = varnames[v];\n    $line(\"var %s = env['%s'];\", var_name(name), name);\n  }\n\n  var len = segments.length;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    $line(\"// \" + JSON.stringify(segment));\n    match_seg(segment);\n  }\n\n  $line(\"if (offset == binsize) {\");\n  $line(\"return {\");\n  for (var v = 0; v < varnames.length; v++) {\n    var name = varnames[v];\n    $line(\"%s: %s,\", name, var_name(name));\n  }\n  $line('};');\n  $line('}'); // if offset == binsize\n  $line(\"else return false;\");\n  $line(\"}\"); // end function\n\n  var fn = new Function('parse_int', 'parse_float', $result());\n  return fn(parse_int, parse_float);\n}\n\n\nfunction write_seg(segment) {\n  switch (segment.type) {\n  case 'string':\n    $line(\"offset += buf.write(%s, offset, 'utf8');\",\n          JSON.stringify(segment.value));\n    break;\n  case 'binary':\n    $line(\"val = bindings['%s'];\", segment.name);\n    if (segment.size === true) {\n      $line('size = val.length;');\n    }\n    else if (typeof segment.size === 'string') {\n      $line(\"size = (bindings['%s'] * %d) / 8;\",\n            segment.size, segment.unit);\n    }\n    else {\n      $line(\"size = %d;\", (segment.size * segment.unit) / 8);\n    }\n    $line('val.copy(buf, offset, 0, size);');\n    $line('offset += size;');\n    break;\n  case 'integer':\n  case 'float':\n    write_number(segment);\n    break;\n  }\n}\n\nfunction write_number(segment) {\n  if (segment.name) {\n    $line(\"val = bindings['%s'];\", segment.name);\n  }\n  else {\n    $line(\"val = %d\", segment.value);\n  }\n  var writer = (segment.type === 'integer') ?\n    'write_int' : 'write_float';\n  if (typeof segment.size === 'string') {\n    $line(\"size = (bindings['%s'] * %d) / 8;\",\n          segment.size, segment.unit);\n  }\n  else {\n    $line('size = %d;', (segment.size * segment.unit) / 8);\n  }\n  $line('%s(buf, val, offset, size, %s);',\n        writer, segment.bigendian);\n  $line('offset += size;');\n}\n\nfunction size_of(segments) {\n  var variable = [];\n  var fixed = 0;\n\n  for (var i = 0; i < segments.length; i++) {\n    var segment = segments[i];\n    if (typeof segment.size === 'string' ||\n        segment.size === true) {\n      variable.push(segment);\n    }\n    else if (segment.type === 'string') {\n      fixed += Buffer.byteLength(segment.value);\n    }\n    else {\n      fixed += (segment.size * segment.unit) / 8;\n    }\n  }\n\n  $line('var buffersize = %d;', fixed);\n\n  if (variable.length > 0) {\n    for (var j = 0; j < variable.length; j++) {\n      var segment = variable[j];\n      if (segment.size === true) {\n        $line(\"buffersize += bindings['%s'].length;\", segment.name);\n      }\n      else {\n        $line(\"buffersize += (bindings['%s'] * %d) / 8;\",\n              segment.size, segment.unit);\n      }\n    }\n  }\n}\n\nfunction emit_write(segments) {\n  $line('var val, size;');\n\n  var len = segments.length;\n  for (var i = 0; i < len; i++) {\n    var segment = segments[i];\n    $line('// %s', JSON.stringify(segment));\n    write_seg(segment);\n  }\n}\n\nfunction compile_ctor(segments) {\n  $start();\n  $line('return function(bindings) {');\n  $line(\"'use strict';\");\n  size_of(segments);\n  $line('var buf = Buffer.alloc(buffersize);');\n  $line('var offset = 0;');\n  emit_write(segments);\n  $line('return buf;');\n  $line('}'); // end function\n\n  return new Function('write_int', 'write_float', 'Buffer',\n                      $result())(write_int, write_float, Buffer);\n}\n\nmodule.exports.compile_pattern = compile_pattern;\nmodule.exports.compile = function() {\n  var str = [].join.call(arguments, ',');\n  var p = parse(str);\n  return compile_pattern(p);\n};\nmodule.exports.compile_builder = function() {\n  var str = [].join.call(arguments, ',');\n  var p = parse(str);\n  return compile_ctor(p);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL2NvbXBpbGUuanMiLCJtYXBwaW5ncyI6IkFBQUE7O0FBRWE7O0FBRWIsbUJBQU8sQ0FBQyxtRkFBa0I7QUFDMUIsUUFBUSxnREFBc0I7O0FBRTlCLFlBQVksb0dBQXdCO0FBQ3BDLGFBQWEsbUJBQU8sQ0FBQyx5RUFBVTtBQUMvQjtBQUNBO0FBQ0EsZ0JBQWdCLG1CQUFPLENBQUMsbUZBQWU7QUFDdkM7QUFDQTs7QUFFQSxhQUFhLDRGQUE2Qjs7QUFFMUM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLG1CQUFtQjtBQUNuQjtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEMsaUNBQWlDLGVBQWU7QUFDaEQsZ0JBQWdCLGlEQUFpRDtBQUNqRTtBQUNBOztBQUVBO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0EsNEJBQTRCO0FBQzVCLDBDQUEwQztBQUMxQztBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCLDBCQUEwQjtBQUMxQixtQ0FBbUMsZUFBZTtBQUNsRCxrQkFBa0I7QUFDbEIsb0NBQW9DO0FBQ3BDO0FBQ0E7O0FBRUE7QUFDQSxpQ0FBaUM7QUFDakM7QUFDQTtBQUNBLHNCQUFzQjtBQUN0QixpQ0FBaUMsZUFBZTtBQUNoRCxnQkFBZ0I7QUFDaEIsOEJBQThCO0FBQzlCOztBQUVBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBLDhDQUE4QyxlQUFlO0FBQzdELGtCQUFrQixxQkFBcUI7QUFDdkM7QUFDQTtBQUNBLG1DQUFtQyxtQkFBbUI7QUFDdEQsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTtBQUNBO0FBQ0Esd0NBQXdDLGVBQWU7QUFDdkQsa0JBQWtCLGVBQWU7QUFDakM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4Q0FBOEM7QUFDOUM7QUFDQTtBQUNBLHlDQUF5QztBQUN6QztBQUNBLDRDQUE0QztBQUM1QztBQUNBLGNBQWM7QUFDZDtBQUNBLDhCQUE4QjtBQUM5QjtBQUNBO0FBQ0E7QUFDQSxpREFBaUQ7QUFDakQ7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSx1Q0FBdUM7QUFDdkMsc0JBQXNCO0FBQ3RCLDJDQUEyQztBQUMzQyxrREFBa0Q7QUFDbEQsc0NBQXNDO0FBQ3RDO0FBQ0Esa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBLDhCQUE4QjtBQUM5Qjs7QUFFQTtBQUNBLGtCQUFrQixTQUFTO0FBQzNCO0FBQ0E7QUFDQTtBQUNBOztBQUVBLGlDQUFpQztBQUNqQyxpQkFBaUI7QUFDakIsa0JBQWtCLHFCQUFxQjtBQUN2QztBQUNBO0FBQ0E7QUFDQSxXQUFXO0FBQ1gsVUFBVSxJQUFJO0FBQ2QsMkJBQTJCO0FBQzNCLFVBQVUsSUFBSTs7QUFFZDtBQUNBO0FBQ0E7OztBQUdBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRDtBQUNuRDtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQSwrQkFBK0I7QUFDL0I7QUFDQTtBQUNBLDhDQUE4QztBQUM5QztBQUNBO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSwwQ0FBMEM7QUFDMUMsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0Q0FBNEM7QUFDNUM7QUFDQTtBQUNBO0FBQ0EscUJBQXFCO0FBQ3JCO0FBQ0Esd0NBQXdDO0FBQ3hDO0FBQ0Esd0JBQXdCO0FBQ3hCOztBQUVBO0FBQ0E7QUFDQTs7QUFFQSxrQkFBa0IscUJBQXFCO0FBQ3ZDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQSw2QkFBNkI7O0FBRTdCO0FBQ0Esb0JBQW9CLHFCQUFxQjtBQUN6QztBQUNBO0FBQ0EsbURBQW1EO0FBQ25EO0FBQ0E7QUFDQSx1REFBdUQ7QUFDdkQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHVCQUF1Qjs7QUFFdkI7QUFDQSxrQkFBa0IsU0FBUztBQUMzQjtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEMsc0JBQXNCO0FBQ3RCO0FBQ0EsNENBQTRDO0FBQzVDLHdCQUF3QjtBQUN4QjtBQUNBLG9CQUFvQjtBQUNwQixVQUFVLElBQUk7O0FBRWQ7QUFDQTtBQUNBOztBQUVBLDhCQUE4QjtBQUM5QixzQkFBc0I7QUFDdEI7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEI7QUFDOUI7QUFDQTtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIyLy4vbm9kZV9tb2R1bGVzL0BhY3VtaW5vdXMvYml0c3ludGF4L2xpYi9jb21waWxlLmpzPzljYzEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gQ29tcGlsZSBwYXR0ZXJucyB0byByZWNvZ25pc2VycyBhbmQgY29uc3RydWN0b3JzXG5cbid1c2Ugc3RyaWN0JztcblxucmVxdWlyZSgnYnVmZmVyLW1vcmUtaW50cycpO1xudmFyICQgPSByZXF1aXJlKCd1dGlsJykuZm9ybWF0O1xuXG52YXIgcGFyc2UgPSByZXF1aXJlKCcuL3BhcnNlJykucGFyc2U7XG52YXIgaW50ZXJwID0gcmVxdWlyZSgnLi9pbnRlcnAnKSxcbiAgcGFyc2VfaW50ID0gaW50ZXJwLnBhcnNlX2ludCxcbiAgcGFyc2VfZmxvYXQgPSBpbnRlcnAucGFyc2VfZmxvYXQ7XG52YXIgY29uc3RydWN0ID0gcmVxdWlyZSgnLi9jb25zdHJ1Y3RvcicpLFxuICB3cml0ZV9pbnQgPSBjb25zdHJ1Y3Qud3JpdGVfaW50LFxuICB3cml0ZV9mbG9hdCA9IGNvbnN0cnVjdC53cml0ZV9mbG9hdDtcblxudmFyIEJ1ZmZlciA9IHJlcXVpcmUoJ3NhZmUtYnVmZmVyJykuQnVmZmVyO1xuXG52YXIgbGluZXMgPSBbXTtcbmZ1bmN0aW9uICRzdGFydCgpIHtcbiAgbGluZXMgPSBbXTtcbn1cbmZ1bmN0aW9uICRsaW5lKC8qIGZvcm1hdCAsIGFyZ3MgKi8pIHtcbiAgbGluZXMucHVzaCgkLmFwcGx5KG51bGwsIGFyZ3VtZW50cykpO1xufVxuZnVuY3Rpb24gJHJlc3VsdCgpIHtcbiAgcmV0dXJuIGxpbmVzLmpvaW4oJ1xcbicpO1xufVxuXG5mdW5jdGlvbiBiaXRzX2V4cHIoc2VnbWVudCkge1xuICBpZiAodHlwZW9mIHNlZ21lbnQuc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICByZXR1cm4gJCgnJXMgKiAlZCcsIHZhcl9uYW1lKHNlZ21lbnQuc2l6ZSksIHNlZ21lbnQudW5pdCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgcmV0dXJuIChzZWdtZW50LnNpemUgKiBzZWdtZW50LnVuaXQpLnRvU3RyaW5nKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gZ2V0X251bWJlcihzZWdtZW50KSB7XG4gICRsaW5lKCdiaXRzID0gJXM7XFxuJywgYml0c19leHByKHNlZ21lbnQpKTtcbiAgdmFyIHBhcnNlciA9IChzZWdtZW50LnR5cGUgPT09ICdpbnRlZ2VyJykgP1xuICAgICdwYXJzZV9pbnQnIDogJ3BhcnNlX2Zsb2F0JztcbiAgdmFyIGJlID0gc2VnbWVudC5iaWdlbmRpYW4sIHNnID0gc2VnbWVudC5zaWduZWQ7XG4gICRsaW5lKFwiYnl0ZW9mZnNldCA9IG9mZnNldCAvIDg7IG9mZnNldCArPSBiaXRzXCIpO1xuICAkbGluZShcImlmIChvZmZzZXQgPiBiaW5zaXplKSB7IHJldHVybiBmYWxzZTsgfVwiKTtcbiAgJGxpbmUoXCJlbHNlIHsgcmVzdWx0ID0gJXMoYmluLCBieXRlb2Zmc2V0LCBiaXRzIC8gOCwgJXMsICVzKTsgfVwiLFxuICAgICAgICBwYXJzZXIsIGJlLCBzZyk7XG59XG5cbmZ1bmN0aW9uIGdldF9iaW5hcnkoc2VnbWVudCkge1xuICAkbGluZShcImJ5dGVvZmZzZXQgPSBvZmZzZXQgLyA4O1wiKTtcbiAgaWYgKHNlZ21lbnQuc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICRsaW5lKFwib2Zmc2V0ID0gYmluc2l6ZTtcIik7XG4gICAgJGxpbmUoXCJyZXN1bHQgPSBiaW4uc2xpY2UoYnl0ZW9mZnNldCk7XCIpO1xuICB9XG4gIGVsc2Uge1xuICAgICRsaW5lKFwiYml0cyA9ICVzO1wiLCBiaXRzX2V4cHIoc2VnbWVudCkpO1xuICAgICRsaW5lKFwib2Zmc2V0ICs9IGJpdHM7XCIpO1xuICAgICRsaW5lKFwiaWYgKG9mZnNldCA+IGJpbnNpemUpIHsgcmV0dXJuIGZhbHNlOyB9XCIpO1xuICAgICRsaW5lKFwiZWxzZSB7IHJlc3VsdCA9IGJpbi5zbGljZShieXRlb2Zmc2V0LFwiLFxuICAgICAgICAgIFwiYnl0ZW9mZnNldCArIGJpdHMgLyA4KTsgfVwiKTtcbiAgfVxufVxuXG5mdW5jdGlvbiBnZXRfc3RyaW5nKHNlZ21lbnQpIHtcbiAgJGxpbmUoXCJieXRlb2Zmc2V0ID0gb2Zmc2V0IC8gODtcIik7XG4gIHZhciBzdHJsZW4gPSBzZWdtZW50LnZhbHVlLmxlbmd0aDtcbiAgdmFyIHN0cmxlbmJpdHMgPSBzdHJsZW4gKiA4O1xuICAkbGluZShcIm9mZnNldCArPSAlZDtcIiwgc3RybGVuYml0cyk7XG4gICRsaW5lKFwiaWYgKG9mZnNldCA+IGJpbnNpemUpIHsgcmV0dXJuIGZhbHNlOyB9XCIpO1xuICAkbGluZShcImVsc2UgeyByZXN1bHQgPSBiaW4udG9TdHJpbmcoYnl0ZW9mZnNldCxcIixcbiAgICAgICAgJChcImJ5dGVvZmZzZXQgKyAlZCk7IH1cIiwgc3RybGVuKSk7XG59XG5cbmZ1bmN0aW9uIHNraXBfYml0cyhzZWdtZW50KSB7XG4gIGlmICh0eXBlb2Ygc2VnbWVudC5zaXplID09PSAnc3RyaW5nJykge1xuICAgIC8vIERhbW4uIEhhdmUgdG8gbG9vayB1cCB0aGUgc2l6ZS5cbiAgICAkbGluZShcInZhciBza2lwYml0cyA9ICVzICogJWQ7XCIsXG4gICAgICAgICAgdmFyX25hbWUoc2VnbWVudC5zaXplKSwgc2VnbWVudC51bml0KTtcbiAgICAkbGluZShcImlmIChvZmZzZXQgKyBza2lwYml0cyA+IGJpbnNpemUpIHsgcmV0dXJuIGZhbHNlOyB9XCIpO1xuICAgICRsaW5lKFwiZWxzZSB7IG9mZnNldCArPSBza2lwYml0czsgfVwiKTtcbiAgfVxuICBlbHNlIGlmIChzZWdtZW50LnNpemUgPT09IHRydWUpIHtcbiAgICAkbGluZShcImlmIChvZmZzZXQgJSA4ID09PSAwKSB7IG9mZnNldCA9IGJpbnNpemU7IH1cIik7XG4gICAgJGxpbmUoXCJlbHNlIHsgcmV0dXJuIGZhbHNlOyB9XCIpO1xuICB9XG4gIGVsc2Uge1xuICAgIHZhciBiaXRzID0gc2VnbWVudC51bml0ICogc2VnbWVudC5zaXplO1xuICAgICRsaW5lKFwiaWYgKG9mZnNldCArICVkID4gYmluc2l6ZSkgeyByZXR1cm4gZmFsc2U7IH1cIiwgYml0cyk7XG4gICAgJGxpbmUoXCJlbHNlIHsgb2Zmc2V0ICs9ICVkOyB9XCIsIGJpdHMpO1xuICB9XG59XG5cbmZ1bmN0aW9uIG1hdGNoX3NlZyhzZWdtZW50KSB7XG4gIGlmIChzZWdtZW50Lm5hbWUgPT09ICdfJykge1xuICAgIHNraXBfYml0cyhzZWdtZW50KTtcbiAgfVxuICBlbHNlIHtcbiAgICB2YXIgYXNzaWduX3Jlc3VsdDtcbiAgICBzd2l0Y2ggKHNlZ21lbnQudHlwZSkge1xuICAgIGNhc2UgJ2ludGVnZXInOlxuICAgIGNhc2UgJ2Zsb2F0JzpcbiAgICAgIGdldF9udW1iZXIoc2VnbWVudCk7XG4gICAgICBicmVhaztcbiAgICBjYXNlICdiaW5hcnknOlxuICAgICAgZ2V0X2JpbmFyeShzZWdtZW50KTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBnZXRfc3RyaW5nKHNlZ21lbnQpO1xuICAgICAgYnJlYWs7XG4gICAgfVxuICAgICRsaW5lKFwiaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcIik7XG4gICAgaWYgKHNlZ21lbnQubmFtZSkge1xuICAgICAgLy8gdmFyaWFibGUgaXMgZ2l2ZW4gYSB2YWx1ZSBpbiB0aGUgZW52aXJvbm1lbnRcbiAgICAgICRsaW5lKFwiZWxzZSBpZiAoJXMgIT09IHVuZGVmaW5lZCkge1wiLCB2YXJfbmFtZShzZWdtZW50Lm5hbWUpKTtcbiAgICAgIC8vIC4uIGFuZCBpdCBpcyBub3QgdGhlIHNhbWUgYXMgdGhhdCBtYXRjaGVkXG4gICAgICAkbGluZShcImlmICglcyAhPSByZXN1bHQpIHJldHVybiBmYWxzZTtcIixcbiAgICAgICAgICAgIHZhcl9uYW1lKHNlZ21lbnQubmFtZSkpO1xuICAgICAgJGxpbmUoXCJ9XCIpO1xuICAgICAgLy8gdmFyaWFibGUgaXMgZnJlZVxuICAgICAgJGxpbmUoJ2Vsc2UgJXMgPSByZXN1bHQ7JywgdmFyX25hbWUoc2VnbWVudC5uYW1lKSk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIHJlcHIgPSBKU09OLnN0cmluZ2lmeShzZWdtZW50LnZhbHVlKTtcbiAgICAgICRsaW5lKFwiZWxzZSBpZiAocmVzdWx0ICE9ICVzKSByZXR1cm4gZmFsc2U7XCIsIHJlcHIpO1xuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiB2YXJfbmFtZShuYW1lKSB7XG4gIHJldHVybiAgJ3Zhcl8nICsgbmFtZTtcbn1cblxuZnVuY3Rpb24gdmFyaWFibGVzKHNlZ21lbnRzKSB7XG4gIHZhciBuYW1lcyA9IHt9O1xuICBmb3IgKHZhciBpID0gMDsgaSA8IHNlZ21lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgdmFyIG5hbWUgPSBzZWdtZW50c1tpXS5uYW1lO1xuICAgIGlmIChuYW1lICYmIG5hbWUgIT09ICdfJykge1xuICAgICAgbmFtZXNbbmFtZV0gPSB0cnVlO1xuICAgIH1cbiAgICBuYW1lID0gc2VnbWVudHNbaV0uc2l6ZTtcbiAgICBpZiAodHlwZW9mIG5hbWUgPT09ICdzdHJpbmcnKSB7XG4gICAgICBuYW1lc1tuYW1lXSA9IHRydWU7XG4gICAgfVxuICB9XG4gIHJldHVybiBPYmplY3Qua2V5cyhuYW1lcyk7XG59XG5cbmZ1bmN0aW9uIGNvbXBpbGVfcGF0dGVybihzZWdtZW50cykge1xuICAkc3RhcnQoKTtcbiAgJGxpbmUoXCJyZXR1cm4gZnVuY3Rpb24oYmluYXJ5LCBlbnYpIHtcIik7XG4gICRsaW5lKFwiJ3VzZSBzdHJpY3QnO1wiKTtcbiAgJGxpbmUoXCJ2YXIgYmluID0gYmluYXJ5LCBlbnYgPSBlbnYgfHwge307XCIpO1xuICAkbGluZShcInZhciBvZmZzZXQgPSAwLCBiaW5zaXplID0gYmluLmxlbmd0aCAqIDg7XCIpO1xuICAkbGluZShcInZhciBiaXRzLCByZXN1bHQsIGJ5dGVvZmZzZXQ7XCIpO1xuICB2YXIgdmFybmFtZXMgPSB2YXJpYWJsZXMoc2VnbWVudHMpO1xuICBmb3IgKHZhciB2ID0gMDsgdiA8IHZhcm5hbWVzLmxlbmd0aDsgdisrKSB7XG4gICAgdmFyIG5hbWUgPSB2YXJuYW1lc1t2XTtcbiAgICAkbGluZShcInZhciAlcyA9IGVudlsnJXMnXTtcIiwgdmFyX25hbWUobmFtZSksIG5hbWUpO1xuICB9XG5cbiAgdmFyIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgJGxpbmUoXCIvLyBcIiArIEpTT04uc3RyaW5naWZ5KHNlZ21lbnQpKTtcbiAgICBtYXRjaF9zZWcoc2VnbWVudCk7XG4gIH1cblxuICAkbGluZShcImlmIChvZmZzZXQgPT0gYmluc2l6ZSkge1wiKTtcbiAgJGxpbmUoXCJyZXR1cm4ge1wiKTtcbiAgZm9yICh2YXIgdiA9IDA7IHYgPCB2YXJuYW1lcy5sZW5ndGg7IHYrKykge1xuICAgIHZhciBuYW1lID0gdmFybmFtZXNbdl07XG4gICAgJGxpbmUoXCIlczogJXMsXCIsIG5hbWUsIHZhcl9uYW1lKG5hbWUpKTtcbiAgfVxuICAkbGluZSgnfTsnKTtcbiAgJGxpbmUoJ30nKTsgLy8gaWYgb2Zmc2V0ID09IGJpbnNpemVcbiAgJGxpbmUoXCJlbHNlIHJldHVybiBmYWxzZTtcIik7XG4gICRsaW5lKFwifVwiKTsgLy8gZW5kIGZ1bmN0aW9uXG5cbiAgdmFyIGZuID0gbmV3IEZ1bmN0aW9uKCdwYXJzZV9pbnQnLCAncGFyc2VfZmxvYXQnLCAkcmVzdWx0KCkpO1xuICByZXR1cm4gZm4ocGFyc2VfaW50LCBwYXJzZV9mbG9hdCk7XG59XG5cblxuZnVuY3Rpb24gd3JpdGVfc2VnKHNlZ21lbnQpIHtcbiAgc3dpdGNoIChzZWdtZW50LnR5cGUpIHtcbiAgY2FzZSAnc3RyaW5nJzpcbiAgICAkbGluZShcIm9mZnNldCArPSBidWYud3JpdGUoJXMsIG9mZnNldCwgJ3V0ZjgnKTtcIixcbiAgICAgICAgICBKU09OLnN0cmluZ2lmeShzZWdtZW50LnZhbHVlKSk7XG4gICAgYnJlYWs7XG4gIGNhc2UgJ2JpbmFyeSc6XG4gICAgJGxpbmUoXCJ2YWwgPSBiaW5kaW5nc1snJXMnXTtcIiwgc2VnbWVudC5uYW1lKTtcbiAgICBpZiAoc2VnbWVudC5zaXplID09PSB0cnVlKSB7XG4gICAgICAkbGluZSgnc2l6ZSA9IHZhbC5sZW5ndGg7Jyk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHR5cGVvZiBzZWdtZW50LnNpemUgPT09ICdzdHJpbmcnKSB7XG4gICAgICAkbGluZShcInNpemUgPSAoYmluZGluZ3NbJyVzJ10gKiAlZCkgLyA4O1wiLFxuICAgICAgICAgICAgc2VnbWVudC5zaXplLCBzZWdtZW50LnVuaXQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgICRsaW5lKFwic2l6ZSA9ICVkO1wiLCAoc2VnbWVudC5zaXplICogc2VnbWVudC51bml0KSAvIDgpO1xuICAgIH1cbiAgICAkbGluZSgndmFsLmNvcHkoYnVmLCBvZmZzZXQsIDAsIHNpemUpOycpO1xuICAgICRsaW5lKCdvZmZzZXQgKz0gc2l6ZTsnKTtcbiAgICBicmVhaztcbiAgY2FzZSAnaW50ZWdlcic6XG4gIGNhc2UgJ2Zsb2F0JzpcbiAgICB3cml0ZV9udW1iZXIoc2VnbWVudCk7XG4gICAgYnJlYWs7XG4gIH1cbn1cblxuZnVuY3Rpb24gd3JpdGVfbnVtYmVyKHNlZ21lbnQpIHtcbiAgaWYgKHNlZ21lbnQubmFtZSkge1xuICAgICRsaW5lKFwidmFsID0gYmluZGluZ3NbJyVzJ107XCIsIHNlZ21lbnQubmFtZSk7XG4gIH1cbiAgZWxzZSB7XG4gICAgJGxpbmUoXCJ2YWwgPSAlZFwiLCBzZWdtZW50LnZhbHVlKTtcbiAgfVxuICB2YXIgd3JpdGVyID0gKHNlZ21lbnQudHlwZSA9PT0gJ2ludGVnZXInKSA/XG4gICAgJ3dyaXRlX2ludCcgOiAnd3JpdGVfZmxvYXQnO1xuICBpZiAodHlwZW9mIHNlZ21lbnQuc2l6ZSA9PT0gJ3N0cmluZycpIHtcbiAgICAkbGluZShcInNpemUgPSAoYmluZGluZ3NbJyVzJ10gKiAlZCkgLyA4O1wiLFxuICAgICAgICAgIHNlZ21lbnQuc2l6ZSwgc2VnbWVudC51bml0KTtcbiAgfVxuICBlbHNlIHtcbiAgICAkbGluZSgnc2l6ZSA9ICVkOycsIChzZWdtZW50LnNpemUgKiBzZWdtZW50LnVuaXQpIC8gOCk7XG4gIH1cbiAgJGxpbmUoJyVzKGJ1ZiwgdmFsLCBvZmZzZXQsIHNpemUsICVzKTsnLFxuICAgICAgICB3cml0ZXIsIHNlZ21lbnQuYmlnZW5kaWFuKTtcbiAgJGxpbmUoJ29mZnNldCArPSBzaXplOycpO1xufVxuXG5mdW5jdGlvbiBzaXplX29mKHNlZ21lbnRzKSB7XG4gIHZhciB2YXJpYWJsZSA9IFtdO1xuICB2YXIgZml4ZWQgPSAwO1xuXG4gIGZvciAodmFyIGkgPSAwOyBpIDwgc2VnbWVudHMubGVuZ3RoOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHNlZ21lbnRzW2ldO1xuICAgIGlmICh0eXBlb2Ygc2VnbWVudC5zaXplID09PSAnc3RyaW5nJyB8fFxuICAgICAgICBzZWdtZW50LnNpemUgPT09IHRydWUpIHtcbiAgICAgIHZhcmlhYmxlLnB1c2goc2VnbWVudCk7XG4gICAgfVxuICAgIGVsc2UgaWYgKHNlZ21lbnQudHlwZSA9PT0gJ3N0cmluZycpIHtcbiAgICAgIGZpeGVkICs9IEJ1ZmZlci5ieXRlTGVuZ3RoKHNlZ21lbnQudmFsdWUpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIGZpeGVkICs9IChzZWdtZW50LnNpemUgKiBzZWdtZW50LnVuaXQpIC8gODtcbiAgICB9XG4gIH1cblxuICAkbGluZSgndmFyIGJ1ZmZlcnNpemUgPSAlZDsnLCBmaXhlZCk7XG5cbiAgaWYgKHZhcmlhYmxlLmxlbmd0aCA+IDApIHtcbiAgICBmb3IgKHZhciBqID0gMDsgaiA8IHZhcmlhYmxlLmxlbmd0aDsgaisrKSB7XG4gICAgICB2YXIgc2VnbWVudCA9IHZhcmlhYmxlW2pdO1xuICAgICAgaWYgKHNlZ21lbnQuc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgICAkbGluZShcImJ1ZmZlcnNpemUgKz0gYmluZGluZ3NbJyVzJ10ubGVuZ3RoO1wiLCBzZWdtZW50Lm5hbWUpO1xuICAgICAgfVxuICAgICAgZWxzZSB7XG4gICAgICAgICRsaW5lKFwiYnVmZmVyc2l6ZSArPSAoYmluZGluZ3NbJyVzJ10gKiAlZCkgLyA4O1wiLFxuICAgICAgICAgICAgICBzZWdtZW50LnNpemUsIHNlZ21lbnQudW5pdCk7XG4gICAgICB9XG4gICAgfVxuICB9XG59XG5cbmZ1bmN0aW9uIGVtaXRfd3JpdGUoc2VnbWVudHMpIHtcbiAgJGxpbmUoJ3ZhciB2YWwsIHNpemU7Jyk7XG5cbiAgdmFyIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDtcbiAgZm9yICh2YXIgaSA9IDA7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gc2VnbWVudHNbaV07XG4gICAgJGxpbmUoJy8vICVzJywgSlNPTi5zdHJpbmdpZnkoc2VnbWVudCkpO1xuICAgIHdyaXRlX3NlZyhzZWdtZW50KTtcbiAgfVxufVxuXG5mdW5jdGlvbiBjb21waWxlX2N0b3Ioc2VnbWVudHMpIHtcbiAgJHN0YXJ0KCk7XG4gICRsaW5lKCdyZXR1cm4gZnVuY3Rpb24oYmluZGluZ3MpIHsnKTtcbiAgJGxpbmUoXCIndXNlIHN0cmljdCc7XCIpO1xuICBzaXplX29mKHNlZ21lbnRzKTtcbiAgJGxpbmUoJ3ZhciBidWYgPSBCdWZmZXIuYWxsb2MoYnVmZmVyc2l6ZSk7Jyk7XG4gICRsaW5lKCd2YXIgb2Zmc2V0ID0gMDsnKTtcbiAgZW1pdF93cml0ZShzZWdtZW50cyk7XG4gICRsaW5lKCdyZXR1cm4gYnVmOycpO1xuICAkbGluZSgnfScpOyAvLyBlbmQgZnVuY3Rpb25cblxuICByZXR1cm4gbmV3IEZ1bmN0aW9uKCd3cml0ZV9pbnQnLCAnd3JpdGVfZmxvYXQnLCAnQnVmZmVyJyxcbiAgICAgICAgICAgICAgICAgICAgICAkcmVzdWx0KCkpKHdyaXRlX2ludCwgd3JpdGVfZmxvYXQsIEJ1ZmZlcik7XG59XG5cbm1vZHVsZS5leHBvcnRzLmNvbXBpbGVfcGF0dGVybiA9IGNvbXBpbGVfcGF0dGVybjtcbm1vZHVsZS5leHBvcnRzLmNvbXBpbGUgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0ciA9IFtdLmpvaW4uY2FsbChhcmd1bWVudHMsICcsJyk7XG4gIHZhciBwID0gcGFyc2Uoc3RyKTtcbiAgcmV0dXJuIGNvbXBpbGVfcGF0dGVybihwKTtcbn07XG5tb2R1bGUuZXhwb3J0cy5jb21waWxlX2J1aWxkZXIgPSBmdW5jdGlvbigpIHtcbiAgdmFyIHN0ciA9IFtdLmpvaW4uY2FsbChhcmd1bWVudHMsICcsJyk7XG4gIHZhciBwID0gcGFyc2Uoc3RyKTtcbiAgcmV0dXJuIGNvbXBpbGVfY3RvcihwKTtcbn07XG4iXSwibmFtZXMiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@acuminous/bitsyntax/lib/compile.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@acuminous/bitsyntax/lib/constructor.js":
/*!**************************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/constructor.js ***!
  \**************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// -*- js-indent-level: 2 -*-\n\n// Constructors given patterns\n\n\n\nvar ints = __webpack_require__(/*! buffer-more-ints */ \"(rsc)/./node_modules/buffer-more-ints/buffer-more-ints.js\");\nvar Buffer = (__webpack_require__(/*! safe-buffer */ \"(rsc)/./node_modules/safe-buffer/index.js\").Buffer);\n\n// Interpret the pattern, writing values into a buffer\nfunction write(buf, offset, pattern, bindings) {\n  for (var i=0, len = pattern.length; i < len; i++) {\n    var segment = pattern[i];\n    switch (segment.type) {\n    case 'string':\n      offset += buf.write(segment.value, offset, 'utf8');\n      break;\n    case 'binary':\n      offset += writeBinary(segment, buf, offset, bindings);\n      break;\n    case 'integer':\n      offset += writeInteger(segment, buf, offset, bindings);\n      break;\n    case 'float':\n      offset += writeFloat(segment, buf, offset, bindings);\n      break;\n    }\n  }\n  return offset;\n}\n\nfunction build(pattern, bindings) {\n  var bufsize = size_of(pattern, bindings);\n  var buf = Buffer.alloc(bufsize);\n  write(buf, 0, pattern, bindings);\n  return buf;\n}\n\n// In bytes\nfunction size_of_segment(segment, bindings) {\n  // size refers to a variable\n  if (typeof segment.size === 'string') {\n    return (bindings[segment.size] * segment.unit) / 8;\n  }\n  if (segment.type === 'string') {\n    return Buffer.byteLength(segment.value, 'utf8');\n  }\n  if (segment.type === 'binary' && segment.size === true) {\n    var val = bindings[segment.name];\n    return val.length;\n  }\n  return (segment.size * segment.unit) / 8;\n}\n\n// size of the to-be-constructed binary, in bytes\nfunction size_of(segments, bindings) {\n  var size = 0;\n  for (var i=0, len = segments.length; i < len; i++) {\n    size += size_of_segment(segments[i], bindings);\n  }\n  return size;\n}\n\nfunction writeBinary(segment, buf, offset, bindings) {\n  var bin = bindings[segment.name];\n  var size = size_of_segment(segment, bindings);\n  bin.copy(buf, offset, 0, size);\n  return size;\n}\n\n// TODO in ff might use the noAssert argument to Buffer.write*() but\n// need to check that it does the right thing wrt little-endian\n\nfunction writeInteger(segment, buf, offset, bindings) {\n  var value = (segment.name) ? bindings[segment.name] : segment.value;\n  var size = size_of_segment(segment, bindings);\n  return write_int(buf, value, offset, size, segment.bigendian);\n}\n\nfunction write_int(buf, value, offset, size, bigendian) {\n  switch (size) {\n  case 1:\n    buf.writeUInt8(value, offset);\n    break;\n  case 2:\n    (bigendian) ?\n      buf.writeUInt16BE(value, offset) :\n      buf.writeUInt16LE(value, offset);\n    break;\n  case 4:\n    (bigendian) ?\n      buf.writeUInt32BE(value, offset) :\n      buf.writeUInt32LE(value, offset);\n    break;\n  case 8:\n    (bigendian) ?\n      ints.writeUInt64BE(buf, value, offset) :\n      ints.writeUInt64LE(buf, value, offset);\n    break;\n  default:\n    throw new Error(\"integer size * unit must be 8, 16, 32 or 64\");\n  }\n  return size;\n}\n\nfunction writeFloat(segment, buf, offset, bindings) {\n  var value = (segment.name) ? bindings[segment.name] : segment.value;\n  var size = size_of_segment(segment, bindings);\n  return write_float(buf, value, offset, size, segment.bigendian);\n}\n\nfunction write_float(buf, value, offset, size, bigendian) {\n  if (size === 4) {\n    (bigendian) ?\n      buf.writeFloatBE(value, offset) :\n      buf.writeFloatLE(value, offset);\n  }\n  else if (size === 8) {\n    (bigendian) ?\n      buf.writeDoubleBE(value, offset) :\n      buf.writeDoubleLE(value, offset);\n  }\n  else {\n    throw new Error(\"float size * unit must be 32 or 64\");\n  }\n  return size;\n}\n\nvar parse = (__webpack_require__(/*! ./parse */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/parse.js\").parse);\n\nmodule.exports.write = write;\nmodule.exports.build = build;\nmodule.exports.write_int = write_int;\nmodule.exports.write_float = write_float;\n\nmodule.exports.builder = function(pstr) {\n  pstr = (arguments.length > 1) ? [].join.call(arguments, ',') : pstr;\n  var pattern = parse(pstr);\n  return function(vars) {\n    return build(pattern, vars);\n  };\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL2NvbnN0cnVjdG9yLmpzIiwibWFwcGluZ3MiOiJBQUFBOztBQUVBOztBQUVhOztBQUViLFdBQVcsbUJBQU8sQ0FBQyxtRkFBa0I7QUFDckMsYUFBYSw0RkFBNkI7O0FBRTFDO0FBQ0E7QUFDQSxzQ0FBc0MsU0FBUztBQUMvQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsU0FBUztBQUNoRDtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsWUFBWSxvR0FBd0I7O0FBRXBDLG9CQUFvQjtBQUNwQixvQkFBb0I7QUFDcEIsd0JBQXdCO0FBQ3hCLDBCQUEwQjs7QUFFMUIsc0JBQXNCO0FBQ3RCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjIvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL2NvbnN0cnVjdG9yLmpzPzdhZmEiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gLSotIGpzLWluZGVudC1sZXZlbDogMiAtKi1cblxuLy8gQ29uc3RydWN0b3JzIGdpdmVuIHBhdHRlcm5zXG5cbid1c2Ugc3RyaWN0JztcblxudmFyIGludHMgPSByZXF1aXJlKCdidWZmZXItbW9yZS1pbnRzJyk7XG52YXIgQnVmZmVyID0gcmVxdWlyZSgnc2FmZS1idWZmZXInKS5CdWZmZXI7XG5cbi8vIEludGVycHJldCB0aGUgcGF0dGVybiwgd3JpdGluZyB2YWx1ZXMgaW50byBhIGJ1ZmZlclxuZnVuY3Rpb24gd3JpdGUoYnVmLCBvZmZzZXQsIHBhdHRlcm4sIGJpbmRpbmdzKSB7XG4gIGZvciAodmFyIGk9MCwgbGVuID0gcGF0dGVybi5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzZWdtZW50ID0gcGF0dGVybltpXTtcbiAgICBzd2l0Y2ggKHNlZ21lbnQudHlwZSkge1xuICAgIGNhc2UgJ3N0cmluZyc6XG4gICAgICBvZmZzZXQgKz0gYnVmLndyaXRlKHNlZ21lbnQudmFsdWUsIG9mZnNldCwgJ3V0ZjgnKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICBvZmZzZXQgKz0gd3JpdGVCaW5hcnkoc2VnbWVudCwgYnVmLCBvZmZzZXQsIGJpbmRpbmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgb2Zmc2V0ICs9IHdyaXRlSW50ZWdlcihzZWdtZW50LCBidWYsIG9mZnNldCwgYmluZGluZ3MpO1xuICAgICAgYnJlYWs7XG4gICAgY2FzZSAnZmxvYXQnOlxuICAgICAgb2Zmc2V0ICs9IHdyaXRlRmxvYXQoc2VnbWVudCwgYnVmLCBvZmZzZXQsIGJpbmRpbmdzKTtcbiAgICAgIGJyZWFrO1xuICAgIH1cbiAgfVxuICByZXR1cm4gb2Zmc2V0O1xufVxuXG5mdW5jdGlvbiBidWlsZChwYXR0ZXJuLCBiaW5kaW5ncykge1xuICB2YXIgYnVmc2l6ZSA9IHNpemVfb2YocGF0dGVybiwgYmluZGluZ3MpO1xuICB2YXIgYnVmID0gQnVmZmVyLmFsbG9jKGJ1ZnNpemUpO1xuICB3cml0ZShidWYsIDAsIHBhdHRlcm4sIGJpbmRpbmdzKTtcbiAgcmV0dXJuIGJ1Zjtcbn1cblxuLy8gSW4gYnl0ZXNcbmZ1bmN0aW9uIHNpemVfb2Zfc2VnbWVudChzZWdtZW50LCBiaW5kaW5ncykge1xuICAvLyBzaXplIHJlZmVycyB0byBhIHZhcmlhYmxlXG4gIGlmICh0eXBlb2Ygc2VnbWVudC5zaXplID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiAoYmluZGluZ3Nbc2VnbWVudC5zaXplXSAqIHNlZ21lbnQudW5pdCkgLyA4O1xuICB9XG4gIGlmIChzZWdtZW50LnR5cGUgPT09ICdzdHJpbmcnKSB7XG4gICAgcmV0dXJuIEJ1ZmZlci5ieXRlTGVuZ3RoKHNlZ21lbnQudmFsdWUsICd1dGY4Jyk7XG4gIH1cbiAgaWYgKHNlZ21lbnQudHlwZSA9PT0gJ2JpbmFyeScgJiYgc2VnbWVudC5zaXplID09PSB0cnVlKSB7XG4gICAgdmFyIHZhbCA9IGJpbmRpbmdzW3NlZ21lbnQubmFtZV07XG4gICAgcmV0dXJuIHZhbC5sZW5ndGg7XG4gIH1cbiAgcmV0dXJuIChzZWdtZW50LnNpemUgKiBzZWdtZW50LnVuaXQpIC8gODtcbn1cblxuLy8gc2l6ZSBvZiB0aGUgdG8tYmUtY29uc3RydWN0ZWQgYmluYXJ5LCBpbiBieXRlc1xuZnVuY3Rpb24gc2l6ZV9vZihzZWdtZW50cywgYmluZGluZ3MpIHtcbiAgdmFyIHNpemUgPSAwO1xuICBmb3IgKHZhciBpPTAsIGxlbiA9IHNlZ21lbnRzLmxlbmd0aDsgaSA8IGxlbjsgaSsrKSB7XG4gICAgc2l6ZSArPSBzaXplX29mX3NlZ21lbnQoc2VnbWVudHNbaV0sIGJpbmRpbmdzKTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxuZnVuY3Rpb24gd3JpdGVCaW5hcnkoc2VnbWVudCwgYnVmLCBvZmZzZXQsIGJpbmRpbmdzKSB7XG4gIHZhciBiaW4gPSBiaW5kaW5nc1tzZWdtZW50Lm5hbWVdO1xuICB2YXIgc2l6ZSA9IHNpemVfb2Zfc2VnbWVudChzZWdtZW50LCBiaW5kaW5ncyk7XG4gIGJpbi5jb3B5KGJ1Ziwgb2Zmc2V0LCAwLCBzaXplKTtcbiAgcmV0dXJuIHNpemU7XG59XG5cbi8vIFRPRE8gaW4gZmYgbWlnaHQgdXNlIHRoZSBub0Fzc2VydCBhcmd1bWVudCB0byBCdWZmZXIud3JpdGUqKCkgYnV0XG4vLyBuZWVkIHRvIGNoZWNrIHRoYXQgaXQgZG9lcyB0aGUgcmlnaHQgdGhpbmcgd3J0IGxpdHRsZS1lbmRpYW5cblxuZnVuY3Rpb24gd3JpdGVJbnRlZ2VyKHNlZ21lbnQsIGJ1Ziwgb2Zmc2V0LCBiaW5kaW5ncykge1xuICB2YXIgdmFsdWUgPSAoc2VnbWVudC5uYW1lKSA/IGJpbmRpbmdzW3NlZ21lbnQubmFtZV0gOiBzZWdtZW50LnZhbHVlO1xuICB2YXIgc2l6ZSA9IHNpemVfb2Zfc2VnbWVudChzZWdtZW50LCBiaW5kaW5ncyk7XG4gIHJldHVybiB3cml0ZV9pbnQoYnVmLCB2YWx1ZSwgb2Zmc2V0LCBzaXplLCBzZWdtZW50LmJpZ2VuZGlhbik7XG59XG5cbmZ1bmN0aW9uIHdyaXRlX2ludChidWYsIHZhbHVlLCBvZmZzZXQsIHNpemUsIGJpZ2VuZGlhbikge1xuICBzd2l0Y2ggKHNpemUpIHtcbiAgY2FzZSAxOlxuICAgIGJ1Zi53cml0ZVVJbnQ4KHZhbHVlLCBvZmZzZXQpO1xuICAgIGJyZWFrO1xuICBjYXNlIDI6XG4gICAgKGJpZ2VuZGlhbikgP1xuICAgICAgYnVmLndyaXRlVUludDE2QkUodmFsdWUsIG9mZnNldCkgOlxuICAgICAgYnVmLndyaXRlVUludDE2TEUodmFsdWUsIG9mZnNldCk7XG4gICAgYnJlYWs7XG4gIGNhc2UgNDpcbiAgICAoYmlnZW5kaWFuKSA/XG4gICAgICBidWYud3JpdGVVSW50MzJCRSh2YWx1ZSwgb2Zmc2V0KSA6XG4gICAgICBidWYud3JpdGVVSW50MzJMRSh2YWx1ZSwgb2Zmc2V0KTtcbiAgICBicmVhaztcbiAgY2FzZSA4OlxuICAgIChiaWdlbmRpYW4pID9cbiAgICAgIGludHMud3JpdGVVSW50NjRCRShidWYsIHZhbHVlLCBvZmZzZXQpIDpcbiAgICAgIGludHMud3JpdGVVSW50NjRMRShidWYsIHZhbHVlLCBvZmZzZXQpO1xuICAgIGJyZWFrO1xuICBkZWZhdWx0OlxuICAgIHRocm93IG5ldyBFcnJvcihcImludGVnZXIgc2l6ZSAqIHVuaXQgbXVzdCBiZSA4LCAxNiwgMzIgb3IgNjRcIik7XG4gIH1cbiAgcmV0dXJuIHNpemU7XG59XG5cbmZ1bmN0aW9uIHdyaXRlRmxvYXQoc2VnbWVudCwgYnVmLCBvZmZzZXQsIGJpbmRpbmdzKSB7XG4gIHZhciB2YWx1ZSA9IChzZWdtZW50Lm5hbWUpID8gYmluZGluZ3Nbc2VnbWVudC5uYW1lXSA6IHNlZ21lbnQudmFsdWU7XG4gIHZhciBzaXplID0gc2l6ZV9vZl9zZWdtZW50KHNlZ21lbnQsIGJpbmRpbmdzKTtcbiAgcmV0dXJuIHdyaXRlX2Zsb2F0KGJ1ZiwgdmFsdWUsIG9mZnNldCwgc2l6ZSwgc2VnbWVudC5iaWdlbmRpYW4pO1xufVxuXG5mdW5jdGlvbiB3cml0ZV9mbG9hdChidWYsIHZhbHVlLCBvZmZzZXQsIHNpemUsIGJpZ2VuZGlhbikge1xuICBpZiAoc2l6ZSA9PT0gNCkge1xuICAgIChiaWdlbmRpYW4pID9cbiAgICAgIGJ1Zi53cml0ZUZsb2F0QkUodmFsdWUsIG9mZnNldCkgOlxuICAgICAgYnVmLndyaXRlRmxvYXRMRSh2YWx1ZSwgb2Zmc2V0KTtcbiAgfVxuICBlbHNlIGlmIChzaXplID09PSA4KSB7XG4gICAgKGJpZ2VuZGlhbikgP1xuICAgICAgYnVmLndyaXRlRG91YmxlQkUodmFsdWUsIG9mZnNldCkgOlxuICAgICAgYnVmLndyaXRlRG91YmxlTEUodmFsdWUsIG9mZnNldCk7XG4gIH1cbiAgZWxzZSB7XG4gICAgdGhyb3cgbmV3IEVycm9yKFwiZmxvYXQgc2l6ZSAqIHVuaXQgbXVzdCBiZSAzMiBvciA2NFwiKTtcbiAgfVxuICByZXR1cm4gc2l6ZTtcbn1cblxudmFyIHBhcnNlID0gcmVxdWlyZSgnLi9wYXJzZScpLnBhcnNlO1xuXG5tb2R1bGUuZXhwb3J0cy53cml0ZSA9IHdyaXRlO1xubW9kdWxlLmV4cG9ydHMuYnVpbGQgPSBidWlsZDtcbm1vZHVsZS5leHBvcnRzLndyaXRlX2ludCA9IHdyaXRlX2ludDtcbm1vZHVsZS5leHBvcnRzLndyaXRlX2Zsb2F0ID0gd3JpdGVfZmxvYXQ7XG5cbm1vZHVsZS5leHBvcnRzLmJ1aWxkZXIgPSBmdW5jdGlvbihwc3RyKSB7XG4gIHBzdHIgPSAoYXJndW1lbnRzLmxlbmd0aCA+IDEpID8gW10uam9pbi5jYWxsKGFyZ3VtZW50cywgJywnKSA6IHBzdHI7XG4gIHZhciBwYXR0ZXJuID0gcGFyc2UocHN0cik7XG4gIHJldHVybiBmdW5jdGlvbih2YXJzKSB7XG4gICAgcmV0dXJuIGJ1aWxkKHBhdHRlcm4sIHZhcnMpO1xuICB9O1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@acuminous/bitsyntax/lib/constructor.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@acuminous/bitsyntax/lib/interp.js":
/*!*********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/interp.js ***!
  \*********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// -*- js-indent: 2 -*-\n// Interpreter for bit syntax AST.\n// Grammar:\n//\n// pattern   := segment (\",\" segment)*\n// segment   := (value | var) (\":\" size)? (\"/\" specifier (\"-\" specifier)*)? | string\n// var       := \"_\" | identifier\n// size      := integer | var\n// specifier := \"little\" | \"big\" | \"signed\" | \"unsigned\" | \"unit\" \":\" 0..256 | type\n// type      := \"integer\" | \"binary\" | \"float\"\n//\n// where integer has the obvious meaning, and identifier is anything\n// other than \"_\" that fits the JavaScript identifier specification.\n//\n\n// We'll use an object to represent each segment, and an array of\n// segments for a pattern. We won't try to optimise for groups of\n// patterns; we'll just step through each to see if it works. We rely\n// a hypothetical prior step to check that it's a valid pattern.\n\n// ? compile to intermediate instructions ?\n\n// A segment looks like\n// {\n//    type: string, // 'string' is special case\n//    size: integer | true, // true means 'all remaining'\n//    name: string | null, // (may be '_')\n//    value: value | null, // either name OR value\n//    unit: integer,\n//    signed: boolean,\n//    bigendian: boolean\n// }\n\n\n\nvar ints    = __webpack_require__(/*! buffer-more-ints */ \"(rsc)/./node_modules/buffer-more-ints/buffer-more-ints.js\"),\n    debug   = __webpack_require__(/*! debug */ \"(rsc)/./node_modules/debug/src/index.js\")('bitsyntax-Interpreter');\n\nfunction parse_int(bin, off, sizeInBytes, bigendian, signed) {\n  switch (sizeInBytes) {\n  case 1:\n    return (signed) ? bin.readInt8(off) : bin.readUInt8(off);\n  case 2:\n    return (bigendian) ?\n      (signed) ? bin.readInt16BE(off) : bin.readUInt16BE(off) :\n      (signed) ? bin.readInt16LE(off) : bin.readUInt16LE(off);\n  case 4:\n    return (bigendian) ?\n      (signed) ? bin.readInt32BE(off) : bin.readUInt32BE(off) :\n      (signed) ? bin.readInt32LE(off) : bin.readUInt32LE(off);\n  case 8:\n    return (bigendian) ?\n      ((signed) ? ints.readInt64BE : ints.readUInt64BE)(bin, off) :\n      ((signed) ? ints.readInt64LE : ints.readUInt64LE)(bin, off);\n  default:\n    throw \"Integers must be 8-, 16-, 32- or 64-bit\";\n  }\n}\n\nfunction parse_float(bin, off, sizeInBytes, bigendian) {\n  switch (sizeInBytes) {\n  case 4:\n    return (bigendian) ? bin.readFloatBE(off) : bin.readFloatLE(off);\n  case 8:\n    return (bigendian) ? bin.readDoubleBE(off) : bin.readDoubleLE(off);\n  default:\n    throw \"Floats must be 32- or 64-bit\";\n  }\n}\n\nfunction size_of(segment, bound) {\n  var size = segment.size;\n  if (typeof size === 'string') {\n    return bound[size];\n  }\n  else {\n    return size;\n  }\n}\n\nfunction new_scope(env) {\n  function scope() {};\n  scope.prototype = env;\n  return new scope();\n}\n\nfunction bindings(scope) {\n  var s = {};\n  for (var k in scope) {\n    if (scope.hasOwnProperty(k)) {\n      s[k] = scope[k];\n    }\n  }\n  return s;\n}\n\nfunction match(pattern, binary, boundvars) {\n  var offset = 0, vars = new_scope(boundvars);\n  var binsize = binary.length * 8;\n\n  function skip_bits(segment) {\n    debug(\"skip bits\"); debug(segment);\n    var size = size_of(segment, vars);\n    if (size === true) {\n      if (offset % 8 === 0) {\n        offset = binsize;\n        return true;\n      }\n      else {\n        return false;\n      }\n    }\n\n    var bits = segment.unit * size;\n    if (offset + bits > binsize) {\n      return false;\n    }\n    else {\n      offset += bits;\n    }\n  }\n\n  function get_integer(segment) {\n    debug(\"get_integer\"); debug(segment);\n    // let's do only multiples of eight bits for now\n    var unit = segment.unit, size = size_of(segment, vars);\n    var bitsize = size * unit;\n    var byteoffset = offset / 8; // NB assumes aligned\n    offset += bitsize;\n    if (bitsize % 8 > 0 || (offset > binsize)) {\n      return false;\n    }\n    else {\n      return parse_int(binary, byteoffset, bitsize / 8,\n                       segment.bigendian, segment.signed);\n    }\n  }\n\n  function get_float(segment) {\n    debug(\"get_float\"); debug(segment);\n    var unit = segment.unit; var size = size_of(segment, vars);\n    var bitsize = size * unit;\n    var byteoffset = offset / 8; // assume aligned\n    offset += bitsize;\n    if (offset > binsize) {\n      return false;\n    }\n    else {\n      return parse_float(binary, byteoffset,\n                         bitsize / 8, segment.bigendian);\n    }\n  }\n\n  function get_binary(segment) {\n    debug(\"get_binary\"); debug(segment);\n    var unit = segment.unit, size = size_of(segment, vars);\n    var byteoffset = offset / 8; // NB alignment\n\n    if (size === true) {\n      offset = binsize;\n      return binary.slice(byteoffset);\n    }\n    else {\n      var bitsize = size * unit;\n      if (bitsize % 8 > 0 || (offset + bitsize) > binsize) {\n        return false;\n      }\n      else {\n        offset += bitsize;\n        return binary.slice(byteoffset, byteoffset + bitsize / 8);\n      }\n    }\n  }\n\n  function get_string(segment) {\n    debug(\"get_string\"); debug(segment);\n    var len = segment.value.length;\n    var byteoffset = offset / 8;\n\n    offset += len * 8;\n    if (offset > binsize) {\n      return false;\n    }\n    // FIXME bytes vs UTF8 characters\n    return binary.slice(byteoffset, byteoffset + len).toString('utf8');\n  }\n\n  var patternlen = pattern.length;\n  for (var i = 0;  i < patternlen; i++) {\n    var segment = pattern[i];\n    var result = false;\n    if (segment.name === '_') {\n      result = skip_bits(segment);\n    }\n    else {\n      switch (segment.type) {\n      case 'string':\n        result = get_string(segment);\n        break;\n      case 'integer':\n        result = get_integer(segment);\n        break;\n      case 'float':\n        result = get_float(segment);\n        break;\n      case 'binary':\n        result = get_binary(segment);\n        break;\n      }\n\n      if (result === false) {\n        return false;\n      }\n      else if (segment.name) {\n        vars[segment.name] = result;\n      }\n      else if (segment.value != result) {\n        return false;\n      }\n    }\n  }\n  if (offset == binsize) {\n    return bindings(vars);\n  }\n  else {\n    return false;\n  }\n}\n\nmodule.exports.match = match;\nmodule.exports.parse_int = parse_int;\nmodule.exports.parse_float = parse_float;\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL2ludGVycC5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQSxhQUFhO0FBQ2I7O0FBRUE7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRWE7O0FBRWIsY0FBYyxtQkFBTyxDQUFDLG1GQUFrQjtBQUN4QyxjQUFjLG1CQUFPLENBQUMsc0RBQU87O0FBRTdCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHdCQUF3QjtBQUN4QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBLGlDQUFpQztBQUNqQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSx3QkFBd0I7QUFDeEIsNkJBQTZCO0FBQzdCO0FBQ0EsaUNBQWlDO0FBQ2pDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBLGlDQUFpQzs7QUFFakM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxtQkFBbUIsZ0JBQWdCO0FBQ25DO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQix3QkFBd0I7QUFDeEIsMEJBQTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMi8uL25vZGVfbW9kdWxlcy9AYWN1bWlub3VzL2JpdHN5bnRheC9saWIvaW50ZXJwLmpzP2VkOTQiXSwic291cmNlc0NvbnRlbnQiOlsiLy8gLSotIGpzLWluZGVudDogMiAtKi1cbi8vIEludGVycHJldGVyIGZvciBiaXQgc3ludGF4IEFTVC5cbi8vIEdyYW1tYXI6XG4vL1xuLy8gcGF0dGVybiAgIDo9IHNlZ21lbnQgKFwiLFwiIHNlZ21lbnQpKlxuLy8gc2VnbWVudCAgIDo9ICh2YWx1ZSB8IHZhcikgKFwiOlwiIHNpemUpPyAoXCIvXCIgc3BlY2lmaWVyIChcIi1cIiBzcGVjaWZpZXIpKik/IHwgc3RyaW5nXG4vLyB2YXIgICAgICAgOj0gXCJfXCIgfCBpZGVudGlmaWVyXG4vLyBzaXplICAgICAgOj0gaW50ZWdlciB8IHZhclxuLy8gc3BlY2lmaWVyIDo9IFwibGl0dGxlXCIgfCBcImJpZ1wiIHwgXCJzaWduZWRcIiB8IFwidW5zaWduZWRcIiB8IFwidW5pdFwiIFwiOlwiIDAuLjI1NiB8IHR5cGVcbi8vIHR5cGUgICAgICA6PSBcImludGVnZXJcIiB8IFwiYmluYXJ5XCIgfCBcImZsb2F0XCJcbi8vXG4vLyB3aGVyZSBpbnRlZ2VyIGhhcyB0aGUgb2J2aW91cyBtZWFuaW5nLCBhbmQgaWRlbnRpZmllciBpcyBhbnl0aGluZ1xuLy8gb3RoZXIgdGhhbiBcIl9cIiB0aGF0IGZpdHMgdGhlIEphdmFTY3JpcHQgaWRlbnRpZmllciBzcGVjaWZpY2F0aW9uLlxuLy9cblxuLy8gV2UnbGwgdXNlIGFuIG9iamVjdCB0byByZXByZXNlbnQgZWFjaCBzZWdtZW50LCBhbmQgYW4gYXJyYXkgb2Zcbi8vIHNlZ21lbnRzIGZvciBhIHBhdHRlcm4uIFdlIHdvbid0IHRyeSB0byBvcHRpbWlzZSBmb3IgZ3JvdXBzIG9mXG4vLyBwYXR0ZXJuczsgd2UnbGwganVzdCBzdGVwIHRocm91Z2ggZWFjaCB0byBzZWUgaWYgaXQgd29ya3MuIFdlIHJlbHlcbi8vIGEgaHlwb3RoZXRpY2FsIHByaW9yIHN0ZXAgdG8gY2hlY2sgdGhhdCBpdCdzIGEgdmFsaWQgcGF0dGVybi5cblxuLy8gPyBjb21waWxlIHRvIGludGVybWVkaWF0ZSBpbnN0cnVjdGlvbnMgP1xuXG4vLyBBIHNlZ21lbnQgbG9va3MgbGlrZVxuLy8ge1xuLy8gICAgdHlwZTogc3RyaW5nLCAvLyAnc3RyaW5nJyBpcyBzcGVjaWFsIGNhc2Vcbi8vICAgIHNpemU6IGludGVnZXIgfCB0cnVlLCAvLyB0cnVlIG1lYW5zICdhbGwgcmVtYWluaW5nJ1xuLy8gICAgbmFtZTogc3RyaW5nIHwgbnVsbCwgLy8gKG1heSBiZSAnXycpXG4vLyAgICB2YWx1ZTogdmFsdWUgfCBudWxsLCAvLyBlaXRoZXIgbmFtZSBPUiB2YWx1ZVxuLy8gICAgdW5pdDogaW50ZWdlcixcbi8vICAgIHNpZ25lZDogYm9vbGVhbixcbi8vICAgIGJpZ2VuZGlhbjogYm9vbGVhblxuLy8gfVxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBpbnRzICAgID0gcmVxdWlyZSgnYnVmZmVyLW1vcmUtaW50cycpLFxuICAgIGRlYnVnICAgPSByZXF1aXJlKCdkZWJ1ZycpKCdiaXRzeW50YXgtSW50ZXJwcmV0ZXInKTtcblxuZnVuY3Rpb24gcGFyc2VfaW50KGJpbiwgb2ZmLCBzaXplSW5CeXRlcywgYmlnZW5kaWFuLCBzaWduZWQpIHtcbiAgc3dpdGNoIChzaXplSW5CeXRlcykge1xuICBjYXNlIDE6XG4gICAgcmV0dXJuIChzaWduZWQpID8gYmluLnJlYWRJbnQ4KG9mZikgOiBiaW4ucmVhZFVJbnQ4KG9mZik7XG4gIGNhc2UgMjpcbiAgICByZXR1cm4gKGJpZ2VuZGlhbikgP1xuICAgICAgKHNpZ25lZCkgPyBiaW4ucmVhZEludDE2QkUob2ZmKSA6IGJpbi5yZWFkVUludDE2QkUob2ZmKSA6XG4gICAgICAoc2lnbmVkKSA/IGJpbi5yZWFkSW50MTZMRShvZmYpIDogYmluLnJlYWRVSW50MTZMRShvZmYpO1xuICBjYXNlIDQ6XG4gICAgcmV0dXJuIChiaWdlbmRpYW4pID9cbiAgICAgIChzaWduZWQpID8gYmluLnJlYWRJbnQzMkJFKG9mZikgOiBiaW4ucmVhZFVJbnQzMkJFKG9mZikgOlxuICAgICAgKHNpZ25lZCkgPyBiaW4ucmVhZEludDMyTEUob2ZmKSA6IGJpbi5yZWFkVUludDMyTEUob2ZmKTtcbiAgY2FzZSA4OlxuICAgIHJldHVybiAoYmlnZW5kaWFuKSA/XG4gICAgICAoKHNpZ25lZCkgPyBpbnRzLnJlYWRJbnQ2NEJFIDogaW50cy5yZWFkVUludDY0QkUpKGJpbiwgb2ZmKSA6XG4gICAgICAoKHNpZ25lZCkgPyBpbnRzLnJlYWRJbnQ2NExFIDogaW50cy5yZWFkVUludDY0TEUpKGJpbiwgb2ZmKTtcbiAgZGVmYXVsdDpcbiAgICB0aHJvdyBcIkludGVnZXJzIG11c3QgYmUgOC0sIDE2LSwgMzItIG9yIDY0LWJpdFwiO1xuICB9XG59XG5cbmZ1bmN0aW9uIHBhcnNlX2Zsb2F0KGJpbiwgb2ZmLCBzaXplSW5CeXRlcywgYmlnZW5kaWFuKSB7XG4gIHN3aXRjaCAoc2l6ZUluQnl0ZXMpIHtcbiAgY2FzZSA0OlxuICAgIHJldHVybiAoYmlnZW5kaWFuKSA/IGJpbi5yZWFkRmxvYXRCRShvZmYpIDogYmluLnJlYWRGbG9hdExFKG9mZik7XG4gIGNhc2UgODpcbiAgICByZXR1cm4gKGJpZ2VuZGlhbikgPyBiaW4ucmVhZERvdWJsZUJFKG9mZikgOiBiaW4ucmVhZERvdWJsZUxFKG9mZik7XG4gIGRlZmF1bHQ6XG4gICAgdGhyb3cgXCJGbG9hdHMgbXVzdCBiZSAzMi0gb3IgNjQtYml0XCI7XG4gIH1cbn1cblxuZnVuY3Rpb24gc2l6ZV9vZihzZWdtZW50LCBib3VuZCkge1xuICB2YXIgc2l6ZSA9IHNlZ21lbnQuc2l6ZTtcbiAgaWYgKHR5cGVvZiBzaXplID09PSAnc3RyaW5nJykge1xuICAgIHJldHVybiBib3VuZFtzaXplXTtcbiAgfVxuICBlbHNlIHtcbiAgICByZXR1cm4gc2l6ZTtcbiAgfVxufVxuXG5mdW5jdGlvbiBuZXdfc2NvcGUoZW52KSB7XG4gIGZ1bmN0aW9uIHNjb3BlKCkge307XG4gIHNjb3BlLnByb3RvdHlwZSA9IGVudjtcbiAgcmV0dXJuIG5ldyBzY29wZSgpO1xufVxuXG5mdW5jdGlvbiBiaW5kaW5ncyhzY29wZSkge1xuICB2YXIgcyA9IHt9O1xuICBmb3IgKHZhciBrIGluIHNjb3BlKSB7XG4gICAgaWYgKHNjb3BlLmhhc093blByb3BlcnR5KGspKSB7XG4gICAgICBzW2tdID0gc2NvcGVba107XG4gICAgfVxuICB9XG4gIHJldHVybiBzO1xufVxuXG5mdW5jdGlvbiBtYXRjaChwYXR0ZXJuLCBiaW5hcnksIGJvdW5kdmFycykge1xuICB2YXIgb2Zmc2V0ID0gMCwgdmFycyA9IG5ld19zY29wZShib3VuZHZhcnMpO1xuICB2YXIgYmluc2l6ZSA9IGJpbmFyeS5sZW5ndGggKiA4O1xuXG4gIGZ1bmN0aW9uIHNraXBfYml0cyhzZWdtZW50KSB7XG4gICAgZGVidWcoXCJza2lwIGJpdHNcIik7IGRlYnVnKHNlZ21lbnQpO1xuICAgIHZhciBzaXplID0gc2l6ZV9vZihzZWdtZW50LCB2YXJzKTtcbiAgICBpZiAoc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgaWYgKG9mZnNldCAlIDggPT09IDApIHtcbiAgICAgICAgb2Zmc2V0ID0gYmluc2l6ZTtcbiAgICAgICAgcmV0dXJuIHRydWU7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgIH1cblxuICAgIHZhciBiaXRzID0gc2VnbWVudC51bml0ICogc2l6ZTtcbiAgICBpZiAob2Zmc2V0ICsgYml0cyA+IGJpbnNpemUpIHtcbiAgICAgIHJldHVybiBmYWxzZTtcbiAgICB9XG4gICAgZWxzZSB7XG4gICAgICBvZmZzZXQgKz0gYml0cztcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRfaW50ZWdlcihzZWdtZW50KSB7XG4gICAgZGVidWcoXCJnZXRfaW50ZWdlclwiKTsgZGVidWcoc2VnbWVudCk7XG4gICAgLy8gbGV0J3MgZG8gb25seSBtdWx0aXBsZXMgb2YgZWlnaHQgYml0cyBmb3Igbm93XG4gICAgdmFyIHVuaXQgPSBzZWdtZW50LnVuaXQsIHNpemUgPSBzaXplX29mKHNlZ21lbnQsIHZhcnMpO1xuICAgIHZhciBiaXRzaXplID0gc2l6ZSAqIHVuaXQ7XG4gICAgdmFyIGJ5dGVvZmZzZXQgPSBvZmZzZXQgLyA4OyAvLyBOQiBhc3N1bWVzIGFsaWduZWRcbiAgICBvZmZzZXQgKz0gYml0c2l6ZTtcbiAgICBpZiAoYml0c2l6ZSAlIDggPiAwIHx8IChvZmZzZXQgPiBiaW5zaXplKSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHJldHVybiBwYXJzZV9pbnQoYmluYXJ5LCBieXRlb2Zmc2V0LCBiaXRzaXplIC8gOCxcbiAgICAgICAgICAgICAgICAgICAgICAgc2VnbWVudC5iaWdlbmRpYW4sIHNlZ21lbnQuc2lnbmVkKTtcbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRfZmxvYXQoc2VnbWVudCkge1xuICAgIGRlYnVnKFwiZ2V0X2Zsb2F0XCIpOyBkZWJ1ZyhzZWdtZW50KTtcbiAgICB2YXIgdW5pdCA9IHNlZ21lbnQudW5pdDsgdmFyIHNpemUgPSBzaXplX29mKHNlZ21lbnQsIHZhcnMpO1xuICAgIHZhciBiaXRzaXplID0gc2l6ZSAqIHVuaXQ7XG4gICAgdmFyIGJ5dGVvZmZzZXQgPSBvZmZzZXQgLyA4OyAvLyBhc3N1bWUgYWxpZ25lZFxuICAgIG9mZnNldCArPSBiaXRzaXplO1xuICAgIGlmIChvZmZzZXQgPiBiaW5zaXplKSB7XG4gICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgcmV0dXJuIHBhcnNlX2Zsb2F0KGJpbmFyeSwgYnl0ZW9mZnNldCxcbiAgICAgICAgICAgICAgICAgICAgICAgICBiaXRzaXplIC8gOCwgc2VnbWVudC5iaWdlbmRpYW4pO1xuICAgIH1cbiAgfVxuXG4gIGZ1bmN0aW9uIGdldF9iaW5hcnkoc2VnbWVudCkge1xuICAgIGRlYnVnKFwiZ2V0X2JpbmFyeVwiKTsgZGVidWcoc2VnbWVudCk7XG4gICAgdmFyIHVuaXQgPSBzZWdtZW50LnVuaXQsIHNpemUgPSBzaXplX29mKHNlZ21lbnQsIHZhcnMpO1xuICAgIHZhciBieXRlb2Zmc2V0ID0gb2Zmc2V0IC8gODsgLy8gTkIgYWxpZ25tZW50XG5cbiAgICBpZiAoc2l6ZSA9PT0gdHJ1ZSkge1xuICAgICAgb2Zmc2V0ID0gYmluc2l6ZTtcbiAgICAgIHJldHVybiBiaW5hcnkuc2xpY2UoYnl0ZW9mZnNldCk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdmFyIGJpdHNpemUgPSBzaXplICogdW5pdDtcbiAgICAgIGlmIChiaXRzaXplICUgOCA+IDAgfHwgKG9mZnNldCArIGJpdHNpemUpID4gYmluc2l6ZSkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgICB9XG4gICAgICBlbHNlIHtcbiAgICAgICAgb2Zmc2V0ICs9IGJpdHNpemU7XG4gICAgICAgIHJldHVybiBiaW5hcnkuc2xpY2UoYnl0ZW9mZnNldCwgYnl0ZW9mZnNldCArIGJpdHNpemUgLyA4KTtcbiAgICAgIH1cbiAgICB9XG4gIH1cblxuICBmdW5jdGlvbiBnZXRfc3RyaW5nKHNlZ21lbnQpIHtcbiAgICBkZWJ1ZyhcImdldF9zdHJpbmdcIik7IGRlYnVnKHNlZ21lbnQpO1xuICAgIHZhciBsZW4gPSBzZWdtZW50LnZhbHVlLmxlbmd0aDtcbiAgICB2YXIgYnl0ZW9mZnNldCA9IG9mZnNldCAvIDg7XG5cbiAgICBvZmZzZXQgKz0gbGVuICogODtcbiAgICBpZiAob2Zmc2V0ID4gYmluc2l6ZSkge1xuICAgICAgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICAvLyBGSVhNRSBieXRlcyB2cyBVVEY4IGNoYXJhY3RlcnNcbiAgICByZXR1cm4gYmluYXJ5LnNsaWNlKGJ5dGVvZmZzZXQsIGJ5dGVvZmZzZXQgKyBsZW4pLnRvU3RyaW5nKCd1dGY4Jyk7XG4gIH1cblxuICB2YXIgcGF0dGVybmxlbiA9IHBhdHRlcm4ubGVuZ3RoO1xuICBmb3IgKHZhciBpID0gMDsgIGkgPCBwYXR0ZXJubGVuOyBpKyspIHtcbiAgICB2YXIgc2VnbWVudCA9IHBhdHRlcm5baV07XG4gICAgdmFyIHJlc3VsdCA9IGZhbHNlO1xuICAgIGlmIChzZWdtZW50Lm5hbWUgPT09ICdfJykge1xuICAgICAgcmVzdWx0ID0gc2tpcF9iaXRzKHNlZ21lbnQpO1xuICAgIH1cbiAgICBlbHNlIHtcbiAgICAgIHN3aXRjaCAoc2VnbWVudC50eXBlKSB7XG4gICAgICBjYXNlICdzdHJpbmcnOlxuICAgICAgICByZXN1bHQgPSBnZXRfc3RyaW5nKHNlZ21lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgICByZXN1bHQgPSBnZXRfaW50ZWdlcihzZWdtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdmbG9hdCc6XG4gICAgICAgIHJlc3VsdCA9IGdldF9mbG9hdChzZWdtZW50KTtcbiAgICAgICAgYnJlYWs7XG4gICAgICBjYXNlICdiaW5hcnknOlxuICAgICAgICByZXN1bHQgPSBnZXRfYmluYXJ5KHNlZ21lbnQpO1xuICAgICAgICBicmVhaztcbiAgICAgIH1cblxuICAgICAgaWYgKHJlc3VsdCA9PT0gZmFsc2UpIHtcbiAgICAgICAgcmV0dXJuIGZhbHNlO1xuICAgICAgfVxuICAgICAgZWxzZSBpZiAoc2VnbWVudC5uYW1lKSB7XG4gICAgICAgIHZhcnNbc2VnbWVudC5uYW1lXSA9IHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIGVsc2UgaWYgKHNlZ21lbnQudmFsdWUgIT0gcmVzdWx0KSB7XG4gICAgICAgIHJldHVybiBmYWxzZTtcbiAgICAgIH1cbiAgICB9XG4gIH1cbiAgaWYgKG9mZnNldCA9PSBiaW5zaXplKSB7XG4gICAgcmV0dXJuIGJpbmRpbmdzKHZhcnMpO1xuICB9XG4gIGVsc2Uge1xuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5tb2R1bGUuZXhwb3J0cy5tYXRjaCA9IG1hdGNoO1xubW9kdWxlLmV4cG9ydHMucGFyc2VfaW50ID0gcGFyc2VfaW50O1xubW9kdWxlLmV4cG9ydHMucGFyc2VfZmxvYXQgPSBwYXJzZV9mbG9hdDtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@acuminous/bitsyntax/lib/interp.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@acuminous/bitsyntax/lib/parse.js":
/*!********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/parse.js ***!
  \********************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

"use strict";
eval("// Parse patterns in string form into the form we use for interpreting\n// (and later, for compiling).\n\n\n\nvar ast = __webpack_require__(/*! ./pattern */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/pattern.js\");\nvar parser = __webpack_require__(/*! ./parser */ \"(rsc)/./node_modules/@acuminous/bitsyntax/lib/parser.js\");\n\nfunction parse_pattern(string) {\n  var segments = parser.parse(string);\n  for (var i=0, len = segments.length; i < len; i++) {\n    var s = segments[i];\n    if (s.string != undefined) {\n      segments[i] = ast.string(s.string);\n    }\n    else if (s.value != undefined) {\n      segments[i] = ast.value(s.value, s.size, s.specifiers);\n    }\n    else if (s.name != undefined) {\n      segments[i] = ast.variable(s.name, s.size, s.specifiers);\n    }\n    else {\n      throw \"Unknown segment \" + s;\n    }\n  }\n  return segments;\n}\n\nmodule.exports.parse = function() {\n  var str = [].join.call(arguments, ',');\n  return parse_pattern(str);\n};\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL3BhcnNlLmpzIiwibWFwcGluZ3MiOiJBQUFBO0FBQ0E7O0FBRWE7O0FBRWIsVUFBVSxtQkFBTyxDQUFDLDJFQUFXO0FBQzdCLGFBQWEsbUJBQU8sQ0FBQyx5RUFBVTs7QUFFL0I7QUFDQTtBQUNBLHVDQUF1QyxTQUFTO0FBQ2hEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBLG9CQUFvQjtBQUNwQjtBQUNBO0FBQ0EiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly93ZWIyLy4vbm9kZV9tb2R1bGVzL0BhY3VtaW5vdXMvYml0c3ludGF4L2xpYi9wYXJzZS5qcz83MDI1Il0sInNvdXJjZXNDb250ZW50IjpbIi8vIFBhcnNlIHBhdHRlcm5zIGluIHN0cmluZyBmb3JtIGludG8gdGhlIGZvcm0gd2UgdXNlIGZvciBpbnRlcnByZXRpbmdcbi8vIChhbmQgbGF0ZXIsIGZvciBjb21waWxpbmcpLlxuXG4ndXNlIHN0cmljdCc7XG5cbnZhciBhc3QgPSByZXF1aXJlKCcuL3BhdHRlcm4nKTtcbnZhciBwYXJzZXIgPSByZXF1aXJlKCcuL3BhcnNlcicpO1xuXG5mdW5jdGlvbiBwYXJzZV9wYXR0ZXJuKHN0cmluZykge1xuICB2YXIgc2VnbWVudHMgPSBwYXJzZXIucGFyc2Uoc3RyaW5nKTtcbiAgZm9yICh2YXIgaT0wLCBsZW4gPSBzZWdtZW50cy5sZW5ndGg7IGkgPCBsZW47IGkrKykge1xuICAgIHZhciBzID0gc2VnbWVudHNbaV07XG4gICAgaWYgKHMuc3RyaW5nICE9IHVuZGVmaW5lZCkge1xuICAgICAgc2VnbWVudHNbaV0gPSBhc3Quc3RyaW5nKHMuc3RyaW5nKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocy52YWx1ZSAhPSB1bmRlZmluZWQpIHtcbiAgICAgIHNlZ21lbnRzW2ldID0gYXN0LnZhbHVlKHMudmFsdWUsIHMuc2l6ZSwgcy5zcGVjaWZpZXJzKTtcbiAgICB9XG4gICAgZWxzZSBpZiAocy5uYW1lICE9IHVuZGVmaW5lZCkge1xuICAgICAgc2VnbWVudHNbaV0gPSBhc3QudmFyaWFibGUocy5uYW1lLCBzLnNpemUsIHMuc3BlY2lmaWVycyk7XG4gICAgfVxuICAgIGVsc2Uge1xuICAgICAgdGhyb3cgXCJVbmtub3duIHNlZ21lbnQgXCIgKyBzO1xuICAgIH1cbiAgfVxuICByZXR1cm4gc2VnbWVudHM7XG59XG5cbm1vZHVsZS5leHBvcnRzLnBhcnNlID0gZnVuY3Rpb24oKSB7XG4gIHZhciBzdHIgPSBbXS5qb2luLmNhbGwoYXJndW1lbnRzLCAnLCcpO1xuICByZXR1cm4gcGFyc2VfcGF0dGVybihzdHIpO1xufTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@acuminous/bitsyntax/lib/parse.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@acuminous/bitsyntax/lib/parser.js":
/*!*********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/parser.js ***!
  \*********************************************************/
/***/ ((module) => {

eval("module.exports = (function(){\n  /*\n   * Generated by PEG.js 0.7.0.\n   *\n   * http://pegjs.majda.cz/\n   */\n  \n  function quote(s) {\n    /*\n     * ECMA-262, 5th ed., 7.8.4: All characters may appear literally in a\n     * string literal except for the closing quote character, backslash,\n     * carriage return, line separator, paragraph separator, and line feed.\n     * Any character may appear in the form of an escape sequence.\n     *\n     * For portability, we also escape escape all control and non-ASCII\n     * characters. Note that \"\\0\" and \"\\v\" escape sequences are not used\n     * because JSHint does not like the first and IE the second.\n     */\n     return '\"' + s\n      .replace(/\\\\/g, '\\\\\\\\')  // backslash\n      .replace(/\"/g, '\\\\\"')    // closing quote character\n      .replace(/\\x08/g, '\\\\b') // backspace\n      .replace(/\\t/g, '\\\\t')   // horizontal tab\n      .replace(/\\n/g, '\\\\n')   // line feed\n      .replace(/\\f/g, '\\\\f')   // form feed\n      .replace(/\\r/g, '\\\\r')   // carriage return\n      .replace(/[\\x00-\\x07\\x0B\\x0E-\\x1F\\x80-\\uFFFF]/g, escape)\n      + '\"';\n  }\n  \n  var result = {\n    /*\n     * Parses the input with a generated parser. If the parsing is successfull,\n     * returns a value explicitly or implicitly specified by the grammar from\n     * which the parser was generated (see |PEG.buildParser|). If the parsing is\n     * unsuccessful, throws |PEG.parser.SyntaxError| describing the error.\n     */\n    parse: function(input, startRule) {\n      var parseFunctions = {\n        \"start\": parse_start,\n        \"segmentTail\": parse_segmentTail,\n        \"segment\": parse_segment,\n        \"string\": parse_string,\n        \"chars\": parse_chars,\n        \"char\": parse_char,\n        \"hexDigit\": parse_hexDigit,\n        \"identifier\": parse_identifier,\n        \"number\": parse_number,\n        \"size\": parse_size,\n        \"specifierList\": parse_specifierList,\n        \"specifierTail\": parse_specifierTail,\n        \"specifier\": parse_specifier,\n        \"unit\": parse_unit,\n        \"ws\": parse_ws\n      };\n      \n      if (startRule !== undefined) {\n        if (parseFunctions[startRule] === undefined) {\n          throw new Error(\"Invalid rule name: \" + quote(startRule) + \".\");\n        }\n      } else {\n        startRule = \"start\";\n      }\n      \n      var pos = 0;\n      var reportFailures = 0;\n      var rightmostFailuresPos = 0;\n      var rightmostFailuresExpected = [];\n      \n      function padLeft(input, padding, length) {\n        var result = input;\n        \n        var padLength = length - input.length;\n        for (var i = 0; i < padLength; i++) {\n          result = padding + result;\n        }\n        \n        return result;\n      }\n      \n      function escape(ch) {\n        var charCode = ch.charCodeAt(0);\n        var escapeChar;\n        var length;\n        \n        if (charCode <= 0xFF) {\n          escapeChar = 'x';\n          length = 2;\n        } else {\n          escapeChar = 'u';\n          length = 4;\n        }\n        \n        return '\\\\' + escapeChar + padLeft(charCode.toString(16).toUpperCase(), '0', length);\n      }\n      \n      function matchFailed(failure) {\n        if (pos < rightmostFailuresPos) {\n          return;\n        }\n        \n        if (pos > rightmostFailuresPos) {\n          rightmostFailuresPos = pos;\n          rightmostFailuresExpected = [];\n        }\n        \n        rightmostFailuresExpected.push(failure);\n      }\n      \n      function parse_start() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_ws();\n        if (result0 !== null) {\n          result1 = parse_segment();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_segmentTail();\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_segmentTail();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, head, tail) { tail.unshift(head); return tail; })(pos0, result0[1], result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_segmentTail() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        result0 = parse_ws();\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 44) {\n            result1 = \",\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\",\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result2 = parse_ws();\n            if (result2 !== null) {\n              result3 = parse_segment();\n              if (result3 !== null) {\n                result0 = [result0, result1, result2, result3];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, seg) { return seg; })(pos0, result0[3]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_segment() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        result0 = parse_string();\n        if (result0 !== null) {\n          result0 = (function(offset, str) { return {string: str}; })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          pos1 = pos;\n          result0 = parse_identifier();\n          if (result0 !== null) {\n            result1 = parse_size();\n            result1 = result1 !== null ? result1 : \"\";\n            if (result1 !== null) {\n              result2 = parse_specifierList();\n              result2 = result2 !== null ? result2 : \"\";\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, v, size, specs) { return {name: v, size: size, specifiers: specs}; })(pos0, result0[0], result0[1], result0[2]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            pos1 = pos;\n            result0 = parse_number();\n            if (result0 !== null) {\n              result1 = parse_size();\n              result1 = result1 !== null ? result1 : \"\";\n              if (result1 !== null) {\n                result2 = parse_specifierList();\n                result2 = result2 !== null ? result2 : \"\";\n                if (result2 !== null) {\n                  result0 = [result0, result1, result2];\n                } else {\n                  result0 = null;\n                  pos = pos1;\n                }\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n            if (result0 !== null) {\n              result0 = (function(offset, v, size, specs) { return {value: v, size: size, specifiers: specs}; })(pos0, result0[0], result0[1], result0[2]);\n            }\n            if (result0 === null) {\n              pos = pos0;\n            }\n          }\n        }\n        return result0;\n      }\n      \n      function parse_string() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 34) {\n          result0 = \"\\\"\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"\\\\\\\"\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          if (input.charCodeAt(pos) === 34) {\n            result1 = \"\\\"\";\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"\\\\\\\"\\\"\");\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) { return \"\";    })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 34) {\n            result0 = \"\\\"\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"\\\\\\\"\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = parse_chars();\n            if (result1 !== null) {\n              if (input.charCodeAt(pos) === 34) {\n                result2 = \"\\\"\";\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"\\\\\\\"\\\"\");\n                }\n              }\n              if (result2 !== null) {\n                result0 = [result0, result1, result2];\n              } else {\n                result0 = null;\n                pos = pos1;\n              }\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, chars) { return chars; })(pos0, result0[1]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n        }\n        return result0;\n      }\n      \n      function parse_chars() {\n        var result0, result1;\n        var pos0;\n        \n        pos0 = pos;\n        result1 = parse_char();\n        if (result1 !== null) {\n          result0 = [];\n          while (result1 !== null) {\n            result0.push(result1);\n            result1 = parse_char();\n          }\n        } else {\n          result0 = null;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, chars) { return chars.join(\"\"); })(pos0, result0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_char() {\n        var result0, result1, result2, result3, result4;\n        var pos0, pos1;\n        \n        if (/^[^\"\\\\\\0-\\x1F]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[^\\\"\\\\\\\\\\\\0-\\\\x1F]\");\n          }\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          if (input.substr(pos, 2) === \"\\\\\\\"\") {\n            result0 = \"\\\\\\\"\";\n            pos += 2;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"\\\\\\\\\\\\\\\"\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result0 = (function(offset) { return '\"';  })(pos0);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n          if (result0 === null) {\n            pos0 = pos;\n            if (input.substr(pos, 2) === \"\\\\\\\\\") {\n              result0 = \"\\\\\\\\\";\n              pos += 2;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"\\\\\\\\\\\\\\\\\\\"\");\n              }\n            }\n            if (result0 !== null) {\n              result0 = (function(offset) { return \"\\\\\"; })(pos0);\n            }\n            if (result0 === null) {\n              pos = pos0;\n            }\n            if (result0 === null) {\n              pos0 = pos;\n              if (input.substr(pos, 2) === \"\\\\/\") {\n                result0 = \"\\\\/\";\n                pos += 2;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"\\\\\\\\/\\\"\");\n                }\n              }\n              if (result0 !== null) {\n                result0 = (function(offset) { return \"/\";  })(pos0);\n              }\n              if (result0 === null) {\n                pos = pos0;\n              }\n              if (result0 === null) {\n                pos0 = pos;\n                if (input.substr(pos, 2) === \"\\\\b\") {\n                  result0 = \"\\\\b\";\n                  pos += 2;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"\\\\\\\\b\\\"\");\n                  }\n                }\n                if (result0 !== null) {\n                  result0 = (function(offset) { return \"\\b\"; })(pos0);\n                }\n                if (result0 === null) {\n                  pos = pos0;\n                }\n                if (result0 === null) {\n                  pos0 = pos;\n                  if (input.substr(pos, 2) === \"\\\\f\") {\n                    result0 = \"\\\\f\";\n                    pos += 2;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"\\\\\\\\f\\\"\");\n                    }\n                  }\n                  if (result0 !== null) {\n                    result0 = (function(offset) { return \"\\f\"; })(pos0);\n                  }\n                  if (result0 === null) {\n                    pos = pos0;\n                  }\n                  if (result0 === null) {\n                    pos0 = pos;\n                    if (input.substr(pos, 2) === \"\\\\n\") {\n                      result0 = \"\\\\n\";\n                      pos += 2;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"\\\\\\\\n\\\"\");\n                      }\n                    }\n                    if (result0 !== null) {\n                      result0 = (function(offset) { return \"\\n\"; })(pos0);\n                    }\n                    if (result0 === null) {\n                      pos = pos0;\n                    }\n                    if (result0 === null) {\n                      pos0 = pos;\n                      if (input.substr(pos, 2) === \"\\\\r\") {\n                        result0 = \"\\\\r\";\n                        pos += 2;\n                      } else {\n                        result0 = null;\n                        if (reportFailures === 0) {\n                          matchFailed(\"\\\"\\\\\\\\r\\\"\");\n                        }\n                      }\n                      if (result0 !== null) {\n                        result0 = (function(offset) { return \"\\r\"; })(pos0);\n                      }\n                      if (result0 === null) {\n                        pos = pos0;\n                      }\n                      if (result0 === null) {\n                        pos0 = pos;\n                        if (input.substr(pos, 2) === \"\\\\t\") {\n                          result0 = \"\\\\t\";\n                          pos += 2;\n                        } else {\n                          result0 = null;\n                          if (reportFailures === 0) {\n                            matchFailed(\"\\\"\\\\\\\\t\\\"\");\n                          }\n                        }\n                        if (result0 !== null) {\n                          result0 = (function(offset) { return \"\\t\"; })(pos0);\n                        }\n                        if (result0 === null) {\n                          pos = pos0;\n                        }\n                        if (result0 === null) {\n                          pos0 = pos;\n                          pos1 = pos;\n                          if (input.substr(pos, 2) === \"\\\\u\") {\n                            result0 = \"\\\\u\";\n                            pos += 2;\n                          } else {\n                            result0 = null;\n                            if (reportFailures === 0) {\n                              matchFailed(\"\\\"\\\\\\\\u\\\"\");\n                            }\n                          }\n                          if (result0 !== null) {\n                            result1 = parse_hexDigit();\n                            if (result1 !== null) {\n                              result2 = parse_hexDigit();\n                              if (result2 !== null) {\n                                result3 = parse_hexDigit();\n                                if (result3 !== null) {\n                                  result4 = parse_hexDigit();\n                                  if (result4 !== null) {\n                                    result0 = [result0, result1, result2, result3, result4];\n                                  } else {\n                                    result0 = null;\n                                    pos = pos1;\n                                  }\n                                } else {\n                                  result0 = null;\n                                  pos = pos1;\n                                }\n                              } else {\n                                result0 = null;\n                                pos = pos1;\n                              }\n                            } else {\n                              result0 = null;\n                              pos = pos1;\n                            }\n                          } else {\n                            result0 = null;\n                            pos = pos1;\n                          }\n                          if (result0 !== null) {\n                            result0 = (function(offset, h1, h2, h3, h4) {\n                                return String.fromCharCode(parseInt(\"0x\" + h1 + h2 + h3 + h4));\n                              })(pos0, result0[1], result0[2], result0[3], result0[4]);\n                          }\n                          if (result0 === null) {\n                            pos = pos0;\n                          }\n                        }\n                      }\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      \n      function parse_hexDigit() {\n        var result0;\n        \n        if (/^[0-9a-fA-F]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[0-9a-fA-F]\");\n          }\n        }\n        return result0;\n      }\n      \n      function parse_identifier() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (/^[_a-zA-Z]/.test(input.charAt(pos))) {\n          result0 = input.charAt(pos);\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[_a-zA-Z]\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = [];\n          if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {\n            result2 = input.charAt(pos);\n            pos++;\n          } else {\n            result2 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[_a-zA-Z0-9]\");\n            }\n          }\n          while (result2 !== null) {\n            result1.push(result2);\n            if (/^[_a-zA-Z0-9]/.test(input.charAt(pos))) {\n              result2 = input.charAt(pos);\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[_a-zA-Z0-9]\");\n              }\n            }\n          }\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, head, tail) { return head + tail.join(''); })(pos0, result0[0], result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_number() {\n        var result0, result1, result2;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        if (input.charCodeAt(pos) === 48) {\n          result0 = \"0\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"0\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result0 = (function(offset) { return 0; })(pos0);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          pos1 = pos;\n          if (/^[1-9]/.test(input.charAt(pos))) {\n            result0 = input.charAt(pos);\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[1-9]\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = [];\n            if (/^[0-9]/.test(input.charAt(pos))) {\n              result2 = input.charAt(pos);\n              pos++;\n            } else {\n              result2 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"[0-9]\");\n              }\n            }\n            while (result2 !== null) {\n              result1.push(result2);\n              if (/^[0-9]/.test(input.charAt(pos))) {\n                result2 = input.charAt(pos);\n                pos++;\n              } else {\n                result2 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"[0-9]\");\n                }\n              }\n            }\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, head, tail) { return parseInt(head + tail.join('')); })(pos0, result0[0], result0[1]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n        }\n        return result0;\n      }\n      \n      function parse_size() {\n        var result0, result1;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 58) {\n          result0 = \":\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\":\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_number();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, num) { return num; })(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        if (result0 === null) {\n          pos0 = pos;\n          pos1 = pos;\n          if (input.charCodeAt(pos) === 58) {\n            result0 = \":\";\n            pos++;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\":\\\"\");\n            }\n          }\n          if (result0 !== null) {\n            result1 = parse_identifier();\n            if (result1 !== null) {\n              result0 = [result0, result1];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n          if (result0 !== null) {\n            result0 = (function(offset, id) { return id; })(pos0, result0[1]);\n          }\n          if (result0 === null) {\n            pos = pos0;\n          }\n        }\n        return result0;\n      }\n      \n      function parse_specifierList() {\n        var result0, result1, result2, result3;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 47) {\n          result0 = \"/\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"/\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_specifier();\n          if (result1 !== null) {\n            result2 = [];\n            result3 = parse_specifierTail();\n            while (result3 !== null) {\n              result2.push(result3);\n              result3 = parse_specifierTail();\n            }\n            if (result2 !== null) {\n              result0 = [result0, result1, result2];\n            } else {\n              result0 = null;\n              pos = pos1;\n            }\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, head, tail) { tail.unshift(head); return tail; })(pos0, result0[1], result0[2]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_specifierTail() {\n        var result0, result1;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (input.charCodeAt(pos) === 45) {\n          result0 = \"-\";\n          pos++;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"-\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_specifier();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, spec) { return spec; })(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_specifier() {\n        var result0;\n        \n        if (input.substr(pos, 6) === \"little\") {\n          result0 = \"little\";\n          pos += 6;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"little\\\"\");\n          }\n        }\n        if (result0 === null) {\n          if (input.substr(pos, 3) === \"big\") {\n            result0 = \"big\";\n            pos += 3;\n          } else {\n            result0 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"\\\"big\\\"\");\n            }\n          }\n          if (result0 === null) {\n            if (input.substr(pos, 6) === \"signed\") {\n              result0 = \"signed\";\n              pos += 6;\n            } else {\n              result0 = null;\n              if (reportFailures === 0) {\n                matchFailed(\"\\\"signed\\\"\");\n              }\n            }\n            if (result0 === null) {\n              if (input.substr(pos, 8) === \"unsigned\") {\n                result0 = \"unsigned\";\n                pos += 8;\n              } else {\n                result0 = null;\n                if (reportFailures === 0) {\n                  matchFailed(\"\\\"unsigned\\\"\");\n                }\n              }\n              if (result0 === null) {\n                if (input.substr(pos, 7) === \"integer\") {\n                  result0 = \"integer\";\n                  pos += 7;\n                } else {\n                  result0 = null;\n                  if (reportFailures === 0) {\n                    matchFailed(\"\\\"integer\\\"\");\n                  }\n                }\n                if (result0 === null) {\n                  if (input.substr(pos, 6) === \"binary\") {\n                    result0 = \"binary\";\n                    pos += 6;\n                  } else {\n                    result0 = null;\n                    if (reportFailures === 0) {\n                      matchFailed(\"\\\"binary\\\"\");\n                    }\n                  }\n                  if (result0 === null) {\n                    if (input.substr(pos, 5) === \"float\") {\n                      result0 = \"float\";\n                      pos += 5;\n                    } else {\n                      result0 = null;\n                      if (reportFailures === 0) {\n                        matchFailed(\"\\\"float\\\"\");\n                      }\n                    }\n                    if (result0 === null) {\n                      result0 = parse_unit();\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n        return result0;\n      }\n      \n      function parse_unit() {\n        var result0, result1;\n        var pos0, pos1;\n        \n        pos0 = pos;\n        pos1 = pos;\n        if (input.substr(pos, 5) === \"unit:\") {\n          result0 = \"unit:\";\n          pos += 5;\n        } else {\n          result0 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"\\\"unit:\\\"\");\n          }\n        }\n        if (result0 !== null) {\n          result1 = parse_number();\n          if (result1 !== null) {\n            result0 = [result0, result1];\n          } else {\n            result0 = null;\n            pos = pos1;\n          }\n        } else {\n          result0 = null;\n          pos = pos1;\n        }\n        if (result0 !== null) {\n          result0 = (function(offset, num) { return 'unit:' + num; })(pos0, result0[1]);\n        }\n        if (result0 === null) {\n          pos = pos0;\n        }\n        return result0;\n      }\n      \n      function parse_ws() {\n        var result0, result1;\n        \n        result0 = [];\n        if (/^[ \\t\\n]/.test(input.charAt(pos))) {\n          result1 = input.charAt(pos);\n          pos++;\n        } else {\n          result1 = null;\n          if (reportFailures === 0) {\n            matchFailed(\"[ \\\\t\\\\n]\");\n          }\n        }\n        while (result1 !== null) {\n          result0.push(result1);\n          if (/^[ \\t\\n]/.test(input.charAt(pos))) {\n            result1 = input.charAt(pos);\n            pos++;\n          } else {\n            result1 = null;\n            if (reportFailures === 0) {\n              matchFailed(\"[ \\\\t\\\\n]\");\n            }\n          }\n        }\n        return result0;\n      }\n      \n      \n      function cleanupExpected(expected) {\n        expected.sort();\n        \n        var lastExpected = null;\n        var cleanExpected = [];\n        for (var i = 0; i < expected.length; i++) {\n          if (expected[i] !== lastExpected) {\n            cleanExpected.push(expected[i]);\n            lastExpected = expected[i];\n          }\n        }\n        return cleanExpected;\n      }\n      \n      function computeErrorPosition() {\n        /*\n         * The first idea was to use |String.split| to break the input up to the\n         * error position along newlines and derive the line and column from\n         * there. However IE's |split| implementation is so broken that it was\n         * enough to prevent it.\n         */\n        \n        var line = 1;\n        var column = 1;\n        var seenCR = false;\n        \n        for (var i = 0; i < Math.max(pos, rightmostFailuresPos); i++) {\n          var ch = input.charAt(i);\n          if (ch === \"\\n\") {\n            if (!seenCR) { line++; }\n            column = 1;\n            seenCR = false;\n          } else if (ch === \"\\r\" || ch === \"\\u2028\" || ch === \"\\u2029\") {\n            line++;\n            column = 1;\n            seenCR = true;\n          } else {\n            column++;\n            seenCR = false;\n          }\n        }\n        \n        return { line: line, column: column };\n      }\n      \n      \n      var result = parseFunctions[startRule]();\n      \n      /*\n       * The parser is now in one of the following three states:\n       *\n       * 1. The parser successfully parsed the whole input.\n       *\n       *    - |result !== null|\n       *    - |pos === input.length|\n       *    - |rightmostFailuresExpected| may or may not contain something\n       *\n       * 2. The parser successfully parsed only a part of the input.\n       *\n       *    - |result !== null|\n       *    - |pos < input.length|\n       *    - |rightmostFailuresExpected| may or may not contain something\n       *\n       * 3. The parser did not successfully parse any part of the input.\n       *\n       *   - |result === null|\n       *   - |pos === 0|\n       *   - |rightmostFailuresExpected| contains at least one failure\n       *\n       * All code following this comment (including called functions) must\n       * handle these states.\n       */\n      if (result === null || pos !== input.length) {\n        var offset = Math.max(pos, rightmostFailuresPos);\n        var found = offset < input.length ? input.charAt(offset) : null;\n        var errorPosition = computeErrorPosition();\n        \n        throw new this.SyntaxError(\n          cleanupExpected(rightmostFailuresExpected),\n          found,\n          offset,\n          errorPosition.line,\n          errorPosition.column\n        );\n      }\n      \n      return result;\n    },\n    \n    /* Returns the parser source code. */\n    toSource: function() { return this._source; }\n  };\n  \n  /* Thrown when a parser encounters a syntax error. */\n  \n  result.SyntaxError = function(expected, found, offset, line, column) {\n    function buildMessage(expected, found) {\n      var expectedHumanized, foundHumanized;\n      \n      switch (expected.length) {\n        case 0:\n          expectedHumanized = \"end of input\";\n          break;\n        case 1:\n          expectedHumanized = expected[0];\n          break;\n        default:\n          expectedHumanized = expected.slice(0, expected.length - 1).join(\", \")\n            + \" or \"\n            + expected[expected.length - 1];\n      }\n      \n      foundHumanized = found ? quote(found) : \"end of input\";\n      \n      return \"Expected \" + expectedHumanized + \" but \" + foundHumanized + \" found.\";\n    }\n    \n    this.name = \"SyntaxError\";\n    this.expected = expected;\n    this.found = found;\n    this.message = buildMessage(expected, found);\n    this.offset = offset;\n    this.line = line;\n    this.column = column;\n  };\n  \n  result.SyntaxError.prototype = Error.prototype;\n  \n  return result;\n})();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL3BhcnNlci5qcyIsIm1hcHBpbmdzIjoiQUFBQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxRQUFRO0FBQ1I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0JBQXdCLGVBQWU7QUFDdkM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFVBQVU7QUFDVjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsY0FBYztBQUNkO0FBQ0E7QUFDQTtBQUNBLFlBQVk7QUFDWjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvREFBb0Qsb0JBQW9CLGNBQWM7QUFDdEY7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QztBQUNqRTtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQSxZQUFZO0FBQ1o7QUFDQTtBQUNBO0FBQ0EsWUFBWTtBQUNaO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0EsMkJBQTJCO0FBQzNCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vd2ViMi8uL25vZGVfbW9kdWxlcy9AYWN1bWlub3VzL2JpdHN5bnRheC9saWIvcGFyc2VyLmpzP2E4NGMiXSwic291cmNlc0NvbnRlbnQiOlsibW9kdWxlLmV4cG9ydHMgPSAoZnVuY3Rpb24oKXtcbiAgLypcbiAgICogR2VuZXJhdGVkIGJ5IFBFRy5qcyAwLjcuMC5cbiAgICpcbiAgICogaHR0cDovL3BlZ2pzLm1hamRhLmN6L1xuICAgKi9cbiAgXG4gIGZ1bmN0aW9uIHF1b3RlKHMpIHtcbiAgICAvKlxuICAgICAqIEVDTUEtMjYyLCA1dGggZWQuLCA3LjguNDogQWxsIGNoYXJhY3RlcnMgbWF5IGFwcGVhciBsaXRlcmFsbHkgaW4gYVxuICAgICAqIHN0cmluZyBsaXRlcmFsIGV4Y2VwdCBmb3IgdGhlIGNsb3NpbmcgcXVvdGUgY2hhcmFjdGVyLCBiYWNrc2xhc2gsXG4gICAgICogY2FycmlhZ2UgcmV0dXJuLCBsaW5lIHNlcGFyYXRvciwgcGFyYWdyYXBoIHNlcGFyYXRvciwgYW5kIGxpbmUgZmVlZC5cbiAgICAgKiBBbnkgY2hhcmFjdGVyIG1heSBhcHBlYXIgaW4gdGhlIGZvcm0gb2YgYW4gZXNjYXBlIHNlcXVlbmNlLlxuICAgICAqXG4gICAgICogRm9yIHBvcnRhYmlsaXR5LCB3ZSBhbHNvIGVzY2FwZSBlc2NhcGUgYWxsIGNvbnRyb2wgYW5kIG5vbi1BU0NJSVxuICAgICAqIGNoYXJhY3RlcnMuIE5vdGUgdGhhdCBcIlxcMFwiIGFuZCBcIlxcdlwiIGVzY2FwZSBzZXF1ZW5jZXMgYXJlIG5vdCB1c2VkXG4gICAgICogYmVjYXVzZSBKU0hpbnQgZG9lcyBub3QgbGlrZSB0aGUgZmlyc3QgYW5kIElFIHRoZSBzZWNvbmQuXG4gICAgICovXG4gICAgIHJldHVybiAnXCInICsgc1xuICAgICAgLnJlcGxhY2UoL1xcXFwvZywgJ1xcXFxcXFxcJykgIC8vIGJhY2tzbGFzaFxuICAgICAgLnJlcGxhY2UoL1wiL2csICdcXFxcXCInKSAgICAvLyBjbG9zaW5nIHF1b3RlIGNoYXJhY3RlclxuICAgICAgLnJlcGxhY2UoL1xceDA4L2csICdcXFxcYicpIC8vIGJhY2tzcGFjZVxuICAgICAgLnJlcGxhY2UoL1xcdC9nLCAnXFxcXHQnKSAgIC8vIGhvcml6b250YWwgdGFiXG4gICAgICAucmVwbGFjZSgvXFxuL2csICdcXFxcbicpICAgLy8gbGluZSBmZWVkXG4gICAgICAucmVwbGFjZSgvXFxmL2csICdcXFxcZicpICAgLy8gZm9ybSBmZWVkXG4gICAgICAucmVwbGFjZSgvXFxyL2csICdcXFxccicpICAgLy8gY2FycmlhZ2UgcmV0dXJuXG4gICAgICAucmVwbGFjZSgvW1xceDAwLVxceDA3XFx4MEJcXHgwRS1cXHgxRlxceDgwLVxcdUZGRkZdL2csIGVzY2FwZSlcbiAgICAgICsgJ1wiJztcbiAgfVxuICBcbiAgdmFyIHJlc3VsdCA9IHtcbiAgICAvKlxuICAgICAqIFBhcnNlcyB0aGUgaW5wdXQgd2l0aCBhIGdlbmVyYXRlZCBwYXJzZXIuIElmIHRoZSBwYXJzaW5nIGlzIHN1Y2Nlc3NmdWxsLFxuICAgICAqIHJldHVybnMgYSB2YWx1ZSBleHBsaWNpdGx5IG9yIGltcGxpY2l0bHkgc3BlY2lmaWVkIGJ5IHRoZSBncmFtbWFyIGZyb21cbiAgICAgKiB3aGljaCB0aGUgcGFyc2VyIHdhcyBnZW5lcmF0ZWQgKHNlZSB8UEVHLmJ1aWxkUGFyc2VyfCkuIElmIHRoZSBwYXJzaW5nIGlzXG4gICAgICogdW5zdWNjZXNzZnVsLCB0aHJvd3MgfFBFRy5wYXJzZXIuU3ludGF4RXJyb3J8IGRlc2NyaWJpbmcgdGhlIGVycm9yLlxuICAgICAqL1xuICAgIHBhcnNlOiBmdW5jdGlvbihpbnB1dCwgc3RhcnRSdWxlKSB7XG4gICAgICB2YXIgcGFyc2VGdW5jdGlvbnMgPSB7XG4gICAgICAgIFwic3RhcnRcIjogcGFyc2Vfc3RhcnQsXG4gICAgICAgIFwic2VnbWVudFRhaWxcIjogcGFyc2Vfc2VnbWVudFRhaWwsXG4gICAgICAgIFwic2VnbWVudFwiOiBwYXJzZV9zZWdtZW50LFxuICAgICAgICBcInN0cmluZ1wiOiBwYXJzZV9zdHJpbmcsXG4gICAgICAgIFwiY2hhcnNcIjogcGFyc2VfY2hhcnMsXG4gICAgICAgIFwiY2hhclwiOiBwYXJzZV9jaGFyLFxuICAgICAgICBcImhleERpZ2l0XCI6IHBhcnNlX2hleERpZ2l0LFxuICAgICAgICBcImlkZW50aWZpZXJcIjogcGFyc2VfaWRlbnRpZmllcixcbiAgICAgICAgXCJudW1iZXJcIjogcGFyc2VfbnVtYmVyLFxuICAgICAgICBcInNpemVcIjogcGFyc2Vfc2l6ZSxcbiAgICAgICAgXCJzcGVjaWZpZXJMaXN0XCI6IHBhcnNlX3NwZWNpZmllckxpc3QsXG4gICAgICAgIFwic3BlY2lmaWVyVGFpbFwiOiBwYXJzZV9zcGVjaWZpZXJUYWlsLFxuICAgICAgICBcInNwZWNpZmllclwiOiBwYXJzZV9zcGVjaWZpZXIsXG4gICAgICAgIFwidW5pdFwiOiBwYXJzZV91bml0LFxuICAgICAgICBcIndzXCI6IHBhcnNlX3dzXG4gICAgICB9O1xuICAgICAgXG4gICAgICBpZiAoc3RhcnRSdWxlICE9PSB1bmRlZmluZWQpIHtcbiAgICAgICAgaWYgKHBhcnNlRnVuY3Rpb25zW3N0YXJ0UnVsZV0gPT09IHVuZGVmaW5lZCkge1xuICAgICAgICAgIHRocm93IG5ldyBFcnJvcihcIkludmFsaWQgcnVsZSBuYW1lOiBcIiArIHF1b3RlKHN0YXJ0UnVsZSkgKyBcIi5cIik7XG4gICAgICAgIH1cbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIHN0YXJ0UnVsZSA9IFwic3RhcnRcIjtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgdmFyIHBvcyA9IDA7XG4gICAgICB2YXIgcmVwb3J0RmFpbHVyZXMgPSAwO1xuICAgICAgdmFyIHJpZ2h0bW9zdEZhaWx1cmVzUG9zID0gMDtcbiAgICAgIHZhciByaWdodG1vc3RGYWlsdXJlc0V4cGVjdGVkID0gW107XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhZExlZnQoaW5wdXQsIHBhZGRpbmcsIGxlbmd0aCkge1xuICAgICAgICB2YXIgcmVzdWx0ID0gaW5wdXQ7XG4gICAgICAgIFxuICAgICAgICB2YXIgcGFkTGVuZ3RoID0gbGVuZ3RoIC0gaW5wdXQubGVuZ3RoO1xuICAgICAgICBmb3IgKHZhciBpID0gMDsgaSA8IHBhZExlbmd0aDsgaSsrKSB7XG4gICAgICAgICAgcmVzdWx0ID0gcGFkZGluZyArIHJlc3VsdDtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gZXNjYXBlKGNoKSB7XG4gICAgICAgIHZhciBjaGFyQ29kZSA9IGNoLmNoYXJDb2RlQXQoMCk7XG4gICAgICAgIHZhciBlc2NhcGVDaGFyO1xuICAgICAgICB2YXIgbGVuZ3RoO1xuICAgICAgICBcbiAgICAgICAgaWYgKGNoYXJDb2RlIDw9IDB4RkYpIHtcbiAgICAgICAgICBlc2NhcGVDaGFyID0gJ3gnO1xuICAgICAgICAgIGxlbmd0aCA9IDI7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgZXNjYXBlQ2hhciA9ICd1JztcbiAgICAgICAgICBsZW5ndGggPSA0O1xuICAgICAgICB9XG4gICAgICAgIFxuICAgICAgICByZXR1cm4gJ1xcXFwnICsgZXNjYXBlQ2hhciArIHBhZExlZnQoY2hhckNvZGUudG9TdHJpbmcoMTYpLnRvVXBwZXJDYXNlKCksICcwJywgbGVuZ3RoKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gbWF0Y2hGYWlsZWQoZmFpbHVyZSkge1xuICAgICAgICBpZiAocG9zIDwgcmlnaHRtb3N0RmFpbHVyZXNQb3MpIHtcbiAgICAgICAgICByZXR1cm47XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIGlmIChwb3MgPiByaWdodG1vc3RGYWlsdXJlc1Bvcykge1xuICAgICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzUG9zID0gcG9zO1xuICAgICAgICAgIHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgfVxuICAgICAgICBcbiAgICAgICAgcmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZC5wdXNoKGZhaWx1cmUpO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zdGFydCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDM7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3dzKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3NlZ21lbnQoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IFtdO1xuICAgICAgICAgICAgcmVzdWx0MyA9IHBhcnNlX3NlZ21lbnRUYWlsKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyLnB1c2gocmVzdWx0Myk7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9zZWdtZW50VGFpbCgpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgaGVhZCwgdGFpbCkgeyB0YWlsLnVuc2hpZnQoaGVhZCk7IHJldHVybiB0YWlsOyB9KShwb3MwLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NlZ21lbnRUYWlsKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MztcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2Vfd3MoKTtcbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA0NCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IFwiLFwiO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIixcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX3dzKCk7XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2Vfc2VnbWVudCgpO1xuICAgICAgICAgICAgICBpZiAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0M107XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBzZWcpIHsgcmV0dXJuIHNlZzsgfSkocG9zMCwgcmVzdWx0MFszXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zZWdtZW50KCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICByZXN1bHQwID0gcGFyc2Vfc3RyaW5nKCk7XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIHN0cikgeyByZXR1cm4ge3N0cmluZzogc3RyfTsgfSkocG9zMCwgcmVzdWx0MCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgIHJlc3VsdDAgPSBwYXJzZV9pZGVudGlmaWVyKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9zaXplKCk7XG4gICAgICAgICAgICByZXN1bHQxID0gcmVzdWx0MSAhPT0gbnVsbCA/IHJlc3VsdDEgOiBcIlwiO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX3NwZWNpZmllckxpc3QoKTtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IHJlc3VsdDIgIT09IG51bGwgPyByZXN1bHQyIDogXCJcIjtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgdiwgc2l6ZSwgc3BlY3MpIHsgcmV0dXJuIHtuYW1lOiB2LCBzaXplOiBzaXplLCBzcGVjaWZpZXJzOiBzcGVjc307IH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX251bWJlcigpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX3NpemUoKTtcbiAgICAgICAgICAgICAgcmVzdWx0MSA9IHJlc3VsdDEgIT09IG51bGwgPyByZXN1bHQxIDogXCJcIjtcbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gcGFyc2Vfc3BlY2lmaWVyTGlzdCgpO1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSByZXN1bHQyICE9PSBudWxsID8gcmVzdWx0MiA6IFwiXCI7XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0Ml07XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgdiwgc2l6ZSwgc3BlY3MpIHsgcmV0dXJuIHt2YWx1ZTogdiwgc2l6ZTogc2l6ZSwgc3BlY2lmaWVyczogc3BlY3N9OyB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9zdHJpbmcoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM0KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiXFxcIlwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXCJcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDM0KSB7XG4gICAgICAgICAgICByZXN1bHQxID0gXCJcXFwiXCI7XG4gICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXCJcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiXCI7ICAgIH0pKHBvczApO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSAzNCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcIlwiO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFwiXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9jaGFycygpO1xuICAgICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gMzQpIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gXCJcXFwiXCI7XG4gICAgICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MiA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcIlxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQyICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyXTtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGNoYXJzKSB7IHJldHVybiBjaGFyczsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfY2hhcnMoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMDtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHJlc3VsdDEgPSBwYXJzZV9jaGFyKCk7XG4gICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFtdO1xuICAgICAgICAgIHdoaWxlIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwLnB1c2gocmVzdWx0MSk7XG4gICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfY2hhcigpO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBjaGFycykgeyByZXR1cm4gY2hhcnMuam9pbihcIlwiKTsgfSkocG9zMCwgcmVzdWx0MCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9jaGFyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MiwgcmVzdWx0MywgcmVzdWx0NDtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBpZiAoL15bXlwiXFxcXFxcMC1cXHgxRn9dLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiW15cXFwiXFxcXFxcXFxcXFxcMC1cXFxceDFGf11cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXFxcXCJcIikge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXFxcXCJcIjtcbiAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXFxcXFxcXFwiXFxcIlwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0KSB7IHJldHVybiAnXCInOyAgfSkocG9zMCk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcXFxcXFwiKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBcIlxcXFxcXFxcXCI7XG4gICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcXFxcXFxcXFxcXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCJcXFxcXCI7IH0pKHBvczApO1xuICAgICAgICAgICAgfVxuICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgIGlmIChpbnB1dC5zdWJzdHIocG9zLCAyKSA9PT0gXCJcXFxcL1wiKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXC9cIjtcbiAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIlxcXFxcXFxcL1xcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiL1wiOyAgfSkocG9zMCk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXGJcIikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXGJcIjtcbiAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXGJcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiXFxiXCI7IH0pKHBvczApO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXGZcIikge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcZlwiO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXGZcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCJcXGZcIjsgfSkocG9zMCk7XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFxuXCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcblwiO1xuICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFxuXFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCJcXG5cIjsgfSkocG9zMCk7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXHJcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiXFxcXHJcIjtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXHJcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQpIHsgcmV0dXJuIFwiXFxyXCI7IH0pKHBvczApO1xuICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgMikgPT09IFwiXFxcXHRcIikge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcdFwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgKz0gMjtcbiAgICAgICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJcXFxcXFxcXHRcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gXCJcXHRcIjsgfSkocG9zMCk7XG4gICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDIpID09PSBcIlxcXFx1XCIpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gXCJcXFxcdVwiO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyArPSAyO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiXFxcXFxcXFx1XFxcIlwiKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQxID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MiA9IHBhcnNlX2hleERpZ2l0KCk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQzID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKHJlc3VsdDMgIT09IG51bGwpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQ0ID0gcGFyc2VfaGV4RGlnaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0NCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxLCByZXN1bHQyLCByZXN1bHQzLCByZXN1bHQ0XTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGgxLCBoMiwgaDMsIGg0KSB7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBTdHJpbmcuZnJvbUNoYXJDb2RlKHBhcnNlSW50KFwiMHhcIiArIGgxICsgaDIgKyBoMyArIGg0KSk7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICB9KShwb3MwLCByZXN1bHQwWzFdLCByZXN1bHQwWzJdLCByZXN1bHQwWzNdLCByZXN1bHQwWzRdKTtcbiAgICAgICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX2hleERpZ2l0KCkge1xuICAgICAgICB2YXIgcmVzdWx0MDtcbiAgICAgICAgXG4gICAgICAgIGlmICgvXlswLTlhLWZBLUZdLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgIHJlc3VsdDAgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICBwb3MrKztcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWzAtOWEtZkEtRl1cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV9pZGVudGlmaWVyKCkge1xuICAgICAgICB2YXIgcmVzdWx0MCwgcmVzdWx0MSwgcmVzdWx0MjtcbiAgICAgICAgdmFyIHBvczAsIHBvczE7XG4gICAgICAgIFxuICAgICAgICBwb3MwID0gcG9zO1xuICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICBpZiAoL15bX2EtekEtWl0vLnRlc3QoaW5wdXQuY2hhckF0KHBvcykpKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJbX2EtekEtWl1cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IFtdO1xuICAgICAgICAgIGlmICgvXltfYS16QS1aMC05XS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIltfYS16QS1aMC05XVwiKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgICAgd2hpbGUgKHJlc3VsdDIgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDEucHVzaChyZXN1bHQyKTtcbiAgICAgICAgICAgIGlmICgvXltfYS16QS1aMC05XS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIltfYS16QS1aMC05XVwiKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGhlYWQsIHRhaWwpIHsgcmV0dXJuIGhlYWQgKyB0YWlsLmpvaW4oJycpOyB9KShwb3MwLCByZXN1bHQwWzBdLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX251bWJlcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDI7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDgpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCIwXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIwXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCkgeyByZXR1cm4gMDsgfSkocG9zMCk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgICBwb3MxID0gcG9zO1xuICAgICAgICAgIGlmICgvXlsxLTldLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWzEtOV1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQxID0gW107XG4gICAgICAgICAgICBpZiAoL15bMC05XS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICAgICAgcmVzdWx0MiA9IGlucHV0LmNoYXJBdChwb3MpO1xuICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDIgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlswLTldXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQxLnB1c2gocmVzdWx0Mik7XG4gICAgICAgICAgICAgIGlmICgvXlswLTldLy50ZXN0KGlucHV0LmNoYXJBdChwb3MpKSkge1xuICAgICAgICAgICAgICAgIHJlc3VsdDIgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgICAgICBwb3MrKztcbiAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICByZXN1bHQyID0gbnVsbDtcbiAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiWzAtOV1cIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBoZWFkLCB0YWlsKSB7IHJldHVybiBwYXJzZUludChoZWFkICsgdGFpbC5qb2luKCcnKSk7IH0pKHBvczAsIHJlc3VsdDBbMF0sIHJlc3VsdDBbMV0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NpemUoKSB7XG4gICAgICAgIHZhciByZXN1bHQwLCByZXN1bHQxO1xuICAgICAgICB2YXIgcG9zMCwgcG9zMTtcbiAgICAgICAgXG4gICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgIHBvczEgPSBwb3M7XG4gICAgICAgIGlmIChpbnB1dC5jaGFyQ29kZUF0KHBvcykgPT09IDU4KSB7XG4gICAgICAgICAgcmVzdWx0MCA9IFwiOlwiO1xuICAgICAgICAgIHBvcysrO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwiOlxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX251bWJlcigpO1xuICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDFdO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQwID0gKGZ1bmN0aW9uKG9mZnNldCwgbnVtKSB7IHJldHVybiBudW07IH0pKHBvczAsIHJlc3VsdDBbMV0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvczAgPSBwb3M7XG4gICAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgICBpZiAoaW5wdXQuY2hhckNvZGVBdChwb3MpID09PSA1OCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFwiOlwiO1xuICAgICAgICAgICAgcG9zKys7XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcIjpcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MSA9IHBhcnNlX2lkZW50aWZpZXIoKTtcbiAgICAgICAgICAgIGlmIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIGlkKSB7IHJldHVybiBpZDsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgICAgfVxuICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc3BlY2lmaWVyTGlzdCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDIsIHJlc3VsdDM7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDcpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCIvXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCIvXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc3BlY2lmaWVyKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDIgPSBbXTtcbiAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9zcGVjaWZpZXJUYWlsKCk7XG4gICAgICAgICAgICB3aGlsZSAocmVzdWx0MyAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQyLnB1c2gocmVzdWx0Myk7XG4gICAgICAgICAgICAgIHJlc3VsdDMgPSBwYXJzZV9zcGVjaWZpZXJUYWlsKCk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MiAhPT0gbnVsbCkge1xuICAgICAgICAgICAgICByZXN1bHQwID0gW3Jlc3VsdDAsIHJlc3VsdDEsIHJlc3VsdDJdO1xuICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgIHBvcyA9IHBvczE7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBoZWFkLCB0YWlsKSB7IHRhaWwudW5zaGlmdChoZWFkKTsgcmV0dXJuIHRhaWw7IH0pKHBvczAsIHJlc3VsdDBbMV0sIHJlc3VsdDBbMl0pO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgcG9zID0gcG9zMDtcbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2Vfc3BlY2lmaWVyVGFpbCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LmNoYXJDb2RlQXQocG9zKSA9PT0gNDUpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCItXCI7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCItXFxcIlwiKTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgIT09IG51bGwpIHtcbiAgICAgICAgICByZXN1bHQxID0gcGFyc2Vfc3BlY2lmaWVyKCk7XG4gICAgICAgICAgaWYgKHJlc3VsdDEgIT09IG51bGwpIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBbcmVzdWx0MCwgcmVzdWx0MV07XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgcG9zID0gcG9zMTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDAgPSAoZnVuY3Rpb24ob2Zmc2V0LCBzcGVjKSB7IHJldHVybiBzcGVjOyB9KShwb3MwLCByZXN1bHQwWzFdKTtcbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgIHBvcyA9IHBvczA7XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIHJlc3VsdDA7XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIHBhcnNlX3NwZWNpZmllcigpIHtcbiAgICAgICAgdmFyIHJlc3VsdDA7XG4gICAgICAgIFxuICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNikgPT09IFwibGl0dGxlXCIpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJsaXR0bGVcIjtcbiAgICAgICAgICBwb3MgKz0gNjtcbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcImxpdHRsZVxcXCJcIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDMpID09PSBcImJpZ1wiKSB7XG4gICAgICAgICAgICByZXN1bHQwID0gXCJiaWdcIjtcbiAgICAgICAgICAgIHBvcyArPSAzO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJiaWdcXFwiXCIpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDYpID09PSBcInNpZ25lZFwiKSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBcInNpZ25lZFwiO1xuICAgICAgICAgICAgICBwb3MgKz0gNjtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJzaWduZWRcXFwiXCIpO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9XG4gICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgOCkgPT09IFwidW5zaWduZWRcIikge1xuICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcInVuc2lnbmVkXCI7XG4gICAgICAgICAgICAgICAgcG9zICs9IDg7XG4gICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJ1bnNpZ25lZFxcXCJcIik7XG4gICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDcpID09PSBcImludGVnZXJcIikge1xuICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IFwiaW50ZWdlclwiO1xuICAgICAgICAgICAgICAgICAgcG9zICs9IDc7XG4gICAgICAgICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgIG1hdGNoRmFpbGVkKFwiXFxcImludGVnZXJcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDYpID09PSBcImJpbmFyeVwiKSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcImJpbmFyeVwiO1xuICAgICAgICAgICAgICAgICAgICBwb3MgKz0gNjtcbiAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgICAgICAgICAgICBpZiAocmVwb3J0RmFpbHVyZXMgPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJiaW5hcnlcXFwiXCIpO1xuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICBpZiAocmVzdWx0MCA9PT0gbnVsbCkge1xuICAgICAgICAgICAgICAgICAgICBpZiAoaW5wdXQuc3Vic3RyKHBvcywgNSkgPT09IFwiZmxvYXRcIikge1xuICAgICAgICAgICAgICAgICAgICAgIHJlc3VsdDAgPSBcImZsb2F0XCI7XG4gICAgICAgICAgICAgICAgICAgICAgcG9zICs9IDU7XG4gICAgICAgICAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICAgICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlxcXCJmbG9hdFxcXCJcIik7XG4gICAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgICB9XG4gICAgICAgICAgICAgICAgICAgIGlmIChyZXN1bHQwID09PSBudWxsKSB7XG4gICAgICAgICAgICAgICAgICAgICAgcmVzdWx0MCA9IHBhcnNlX3VuaXQoKTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICByZXR1cm4gcmVzdWx0MDtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgZnVuY3Rpb24gcGFyc2VfdW5pdCgpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIHZhciBwb3MwLCBwb3MxO1xuICAgICAgICBcbiAgICAgICAgcG9zMCA9IHBvcztcbiAgICAgICAgcG9zMSA9IHBvcztcbiAgICAgICAgaWYgKGlucHV0LnN1YnN0cihwb3MsIDUpID09PSBcInVuaXQ6XCIpIHtcbiAgICAgICAgICByZXN1bHQwID0gXCJ1bml0OlwiO1xuICAgICAgICAgIHBvcyArPSA1O1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIHJlc3VsdDAgPSBudWxsO1xuICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgbWF0Y2hGYWlsZWQoXCJcXFwidW5pdDpcXFwiXCIpO1xuICAgICAgICAgIH1cbiAgICAgICAgfVxuICAgICAgICBpZiAocmVzdWx0MCAhPT0gbnVsbCkge1xuICAgICAgICAgIHJlc3VsdDEgPSBwYXJzZV9udW1iZXIoKTtcbiAgICAgICAgICBpZiAocmVzdWx0MSAhPT0gbnVsbCkge1xuICAgICAgICAgICAgcmVzdWx0MCA9IFtyZXN1bHQwLCByZXN1bHQxXTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcmVzdWx0MCA9IG51bGw7XG4gICAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICAgIH1cbiAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICByZXN1bHQwID0gbnVsbDtcbiAgICAgICAgICBwb3MgPSBwb3MxO1xuICAgICAgICB9XG4gICAgICAgIGlmIChyZXN1bHQwICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MCA9IChmdW5jdGlvbihvZmZzZXQsIG51bSkgeyByZXR1cm4gJ3VuaXQ6JyArIG51bTsgfSkocG9zMCwgcmVzdWx0MFsxXSk7XG4gICAgICAgIH1cbiAgICAgICAgaWYgKHJlc3VsdDAgPT09IG51bGwpIHtcbiAgICAgICAgICBwb3MgPSBwb3MwO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBwYXJzZV93cygpIHtcbiAgICAgICAgdmFyIHJlc3VsdDAsIHJlc3VsdDE7XG4gICAgICAgIFxuICAgICAgICByZXN1bHQwID0gW107XG4gICAgICAgIGlmICgvXlsgXFx0XFxuXS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICByZXN1bHQxID0gaW5wdXQuY2hhckF0KHBvcyk7XG4gICAgICAgICAgcG9zKys7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgcmVzdWx0MSA9IG51bGw7XG4gICAgICAgICAgaWYgKHJlcG9ydEZhaWx1cmVzID09PSAwKSB7XG4gICAgICAgICAgICBtYXRjaEZhaWxlZChcIlsgXFxcXHRcXFxcbl1cIik7XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHdoaWxlIChyZXN1bHQxICE9PSBudWxsKSB7XG4gICAgICAgICAgcmVzdWx0MC5wdXNoKHJlc3VsdDEpO1xuICAgICAgICAgIGlmICgvXlsgXFx0XFxuXS8udGVzdChpbnB1dC5jaGFyQXQocG9zKSkpIHtcbiAgICAgICAgICAgIHJlc3VsdDEgPSBpbnB1dC5jaGFyQXQocG9zKTtcbiAgICAgICAgICAgIHBvcysrO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXN1bHQxID0gbnVsbDtcbiAgICAgICAgICAgIGlmIChyZXBvcnRGYWlsdXJlcyA9PT0gMCkge1xuICAgICAgICAgICAgICBtYXRjaEZhaWxlZChcIlsgXFxcXHRcXFxcbl1cIik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiByZXN1bHQwO1xuICAgICAgfVxuICAgICAgXG4gICAgICBcbiAgICAgIGZ1bmN0aW9uIGNsZWFudXBFeHBlY3RlZChleHBlY3RlZCkge1xuICAgICAgICBleHBlY3RlZC5zb3J0KCk7XG4gICAgICAgIFxuICAgICAgICB2YXIgbGFzdEV4cGVjdGVkID0gbnVsbDtcbiAgICAgICAgdmFyIGNsZWFuRXhwZWN0ZWQgPSBbXTtcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBleHBlY3RlZC5sZW5ndGg7IGkrKykge1xuICAgICAgICAgIGlmIChleHBlY3RlZFtpXSAhPT0gbGFzdEV4cGVjdGVkKSB7XG4gICAgICAgICAgICBjbGVhbkV4cGVjdGVkLnB1c2goZXhwZWN0ZWRbaV0pO1xuICAgICAgICAgICAgbGFzdEV4cGVjdGVkID0gZXhwZWN0ZWRbaV07XG4gICAgICAgICAgfVxuICAgICAgICB9XG4gICAgICAgIHJldHVybiBjbGVhbkV4cGVjdGVkO1xuICAgICAgfVxuICAgICAgXG4gICAgICBmdW5jdGlvbiBjb21wdXRlRXJyb3JQb3NpdGlvbigpIHtcbiAgICAgICAgLypcbiAgICAgICAgICogVGhlIGZpcnN0IGlkZWEgd2FzIHRvIHVzZSB8U3RyaW5nLnNwbGl0fCB0byBicmVhayB0aGUgaW5wdXQgdXAgdG8gdGhlXG4gICAgICAgICAqIGVycm9yIHBvc2l0aW9uIGFsb25nIG5ld2xpbmVzIGFuZCBkZXJpdmUgdGhlIGxpbmUgYW5kIGNvbHVtbiBmcm9tXG4gICAgICAgICAqIHRoZXJlLiBIb3dldmVyIElFJ3MgfHNwbGl0fCBpbXBsZW1lbnRhdGlvbiBpcyBzbyBicm9rZW4gdGhhdCBpdCB3YXNcbiAgICAgICAgICogZW5vdWdoIHRvIHByZXZlbnQgaXQuXG4gICAgICAgICAqL1xuICAgICAgICBcbiAgICAgICAgdmFyIGxpbmUgPSAxO1xuICAgICAgICB2YXIgY29sdW1uID0gMTtcbiAgICAgICAgdmFyIHNlZW5DUiA9IGZhbHNlO1xuICAgICAgICBcbiAgICAgICAgZm9yICh2YXIgaSA9IDA7IGkgPCBNYXRoLm1heChwb3MsIHJpZ2h0bW9zdEZhaWx1cmVzUG9zKTsgaSsrKSB7XG4gICAgICAgICAgdmFyIGNoID0gaW5wdXQuY2hhckF0KGkpO1xuICAgICAgICAgIGlmIChjaCA9PT0gXCJcXG5cIikge1xuICAgICAgICAgICAgaWYgKCFzZWVuQ1IpIHsgbGluZSsrOyB9XG4gICAgICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICAgICAgc2VlbkNSID0gZmFsc2U7XG4gICAgICAgICAgfSBlbHNlIGlmIChjaCA9PT0gXCJcXHJcIiB8fCBjaCA9PT0gXCJcXHUyMDI4XCIgfHwgY2ggPT09IFwiXFx1MjAyOVwiKSB7XG4gICAgICAgICAgICBsaW5lKys7XG4gICAgICAgICAgICBjb2x1bW4gPSAxO1xuICAgICAgICAgICAgc2VlbkNSID0gdHJ1ZTtcbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgY29sdW1uKys7XG4gICAgICAgICAgICBzZWVuQ1IgPSBmYWxzZTtcbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgXG4gICAgICAgIHJldHVybiB7IGxpbmU6IGxpbmUsIGNvbHVtbjogY29sdW1uIH07XG4gICAgICB9XG4gICAgICBcbiAgICAgIFxuICAgICAgdmFyIHJlc3VsdCA9IHBhcnNlRnVuY3Rpb25zW3N0YXJ0UnVsZV0oKTtcbiAgICAgIFxuICAgICAgLypcbiAgICAgICAqIFRoZSBwYXJzZXIgaXMgbm93IGluIG9uZSBvZiB0aGUgZm9sbG93aW5nIHRocmVlIHN0YXRlczpcbiAgICAgICAqXG4gICAgICAgKiAxLiBUaGUgcGFyc2VyIHN1Y2Nlc3NmdWxseSBwYXJzZWQgdGhlIHdob2xlIGlucHV0LlxuICAgICAgICpcbiAgICAgICAqICAgIC0gfHJlc3VsdCAhPT0gbnVsbHxcbiAgICAgICAqICAgIC0gfHBvcyA9PT0gaW5wdXQubGVuZ3RofFxuICAgICAgICogICAgLSB8cmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZHwgbWF5IG9yIG1heSBub3QgY29udGFpbiBzb21ldGhpbmdcbiAgICAgICAqXG4gICAgICAgKiAyLiBUaGUgcGFyc2VyIHN1Y2Nlc3NmdWxseSBwYXJzZWQgb25seSBhIHBhcnQgb2YgdGhlIGlucHV0LlxuICAgICAgICpcbiAgICAgICAqICAgIC0gfHJlc3VsdCAhPT0gbnVsbHxcbiAgICAgICAqICAgIC0gfHBvcyA8IGlucHV0Lmxlbmd0aHxcbiAgICAgICAqICAgIC0gfHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWR8IG1heSBvciBtYXkgbm90IGNvbnRhaW4gc29tZXRoaW5nXG4gICAgICAgKlxuICAgICAgICogMy4gVGhlIHBhcnNlciBkaWQgbm90IHN1Y2Nlc3NmdWxseSBwYXJzZSBhbnkgcGFydCBvZiB0aGUgaW5wdXQuXG4gICAgICAgKlxuICAgICAgICogICAtIHxyZXN1bHQgPT09IG51bGx8XG4gICAgICAgKiAgIC0gfHBvcyA9PT0gMHxcbiAgICAgICAqICAgLSB8cmlnaHRtb3N0RmFpbHVyZXNFeHBlY3RlZHwgY29udGFpbnMgYXQgbGVhc3Qgb25lIGZhaWx1cmVcbiAgICAgICAqXG4gICAgICAgKiBBbGwgY29kZSBmb2xsb3dpbmcgdGhpcyBjb21tZW50IChpbmNsdWRpbmcgY2FsbGVkIGZ1bmN0aW9ucykgbXVzdFxuICAgICAgICogaGFuZGxlIHRoZXNlIHN0YXRlcy5cbiAgICAgICAqL1xuICAgICAgaWYgKHJlc3VsdCA9PT0gbnVsbCB8fCBwb3MgIT09IGlucHV0Lmxlbmd0aCkge1xuICAgICAgICB2YXIgb2Zmc2V0ID0gTWF0aC5tYXgocG9zLCByaWdodG1vc3RGYWlsdXJlc1Bvcyk7XG4gICAgICAgIHZhciBmb3VuZCA9IG9mZnNldCA8IGlucHV0Lmxlbmd0aCA/IGlucHV0LmNoYXJBdChvZmZzZXQpIDogbnVsbDtcbiAgICAgICAgdmFyIGVycm9yUG9zaXRpb24gPSBjb21wdXRlRXJyb3JQb3NpdGlvbigpO1xuICAgICAgICBcbiAgICAgICAgdGhyb3cgbmV3IHRoaXMuU3ludGF4RXJyb3IoXG4gICAgICAgICAgY2xlYW51cEV4cGVjdGVkKHJpZ2h0bW9zdEZhaWx1cmVzRXhwZWN0ZWQpLFxuICAgICAgICAgIGZvdW5kLFxuICAgICAgICAgIG9mZnNldCxcbiAgICAgICAgICBlcnJvclBvc2l0aW9uLmxpbmUsXG4gICAgICAgICAgZXJyb3JQb3NpdGlvbi5jb2x1bW5cbiAgICAgICAgKTtcbiAgICAgIH1cbiAgICAgIFxuICAgICAgcmV0dXJuIHJlc3VsdDtcbiAgICB9LFxuICAgIFxuICAgIC8qIFJldHVybnMgdGhlIHBhcnNlciBzb3VyY2UgY29kZS4gKi9cbiAgICB0b1NvdXJjZTogZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzLl9zb3VyY2U7IH1cbiAgfTtcbiAgXG4gIC8qIFRocm93biB3aGVuIGEgcGFyc2VyIGVuY291bnRlcnMgYSBzeW50YXggZXJyb3IuICovXG4gIFxuICByZXN1bHQuU3ludGF4RXJyb3IgPSBmdW5jdGlvbihleHBlY3RlZCwgZm91bmQsIG9mZnNldCwgbGluZSwgY29sdW1uKSB7XG4gICAgZnVuY3Rpb24gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCkge1xuICAgICAgdmFyIGV4cGVjdGVkSHVtYW5pemVkLCBmb3VuZEh1bWFuaXplZDtcbiAgICAgIFxuICAgICAgc3dpdGNoIChleHBlY3RlZC5sZW5ndGgpIHtcbiAgICAgICAgY2FzZSAwOlxuICAgICAgICAgIGV4cGVjdGVkSHVtYW5pemVkID0gXCJlbmQgb2YgaW5wdXRcIjtcbiAgICAgICAgICBicmVhaztcbiAgICAgICAgY2FzZSAxOlxuICAgICAgICAgIGV4cGVjdGVkSHVtYW5pemVkID0gZXhwZWN0ZWRbMF07XG4gICAgICAgICAgYnJlYWs7XG4gICAgICAgIGRlZmF1bHQ6XG4gICAgICAgICAgZXhwZWN0ZWRIdW1hbml6ZWQgPSBleHBlY3RlZC5zbGljZSgwLCBleHBlY3RlZC5sZW5ndGggLSAxKS5qb2luKFwiLCBcIilcbiAgICAgICAgICAgICsgXCIgb3IgXCJcbiAgICAgICAgICAgICsgZXhwZWN0ZWRbZXhwZWN0ZWQubGVuZ3RoIC0gMV07XG4gICAgICB9XG4gICAgICBcbiAgICAgIGZvdW5kSHVtYW5pemVkID0gZm91bmQgPyBxdW90ZShmb3VuZCkgOiBcImVuZCBvZiBpbnB1dFwiO1xuICAgICAgXG4gICAgICByZXR1cm4gXCJFeHBlY3RlZCBcIiArIGV4cGVjdGVkSHVtYW5pemVkICsgXCIgYnV0IFwiICsgZm91bmRIdW1hbml6ZWQgKyBcIiBmb3VuZC5cIjtcbiAgICB9XG4gICAgXG4gICAgdGhpcy5uYW1lID0gXCJTeW50YXhFcnJvclwiO1xuICAgIHRoaXMuZXhwZWN0ZWQgPSBleHBlY3RlZDtcbiAgICB0aGlzLmZvdW5kID0gZm91bmQ7XG4gICAgdGhpcy5tZXNzYWdlID0gYnVpbGRNZXNzYWdlKGV4cGVjdGVkLCBmb3VuZCk7XG4gICAgdGhpcy5vZmZzZXQgPSBvZmZzZXQ7XG4gICAgdGhpcy5saW5lID0gbGluZTtcbiAgICB0aGlzLmNvbHVtbiA9IGNvbHVtbjtcbiAgfTtcbiAgXG4gIHJlc3VsdC5TeW50YXhFcnJvci5wcm90b3R5cGUgPSBFcnJvci5wcm90b3R5cGU7XG4gIFxuICByZXR1cm4gcmVzdWx0O1xufSkoKTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@acuminous/bitsyntax/lib/parser.js\n");

/***/ }),

/***/ "(rsc)/./node_modules/@acuminous/bitsyntax/lib/pattern.js":
/*!**********************************************************!*\
  !*** ./node_modules/@acuminous/bitsyntax/lib/pattern.js ***!
  \**********************************************************/
/***/ ((module) => {

"use strict";
eval("// -*- js-indent-level: 2 -*-\n// Constructing patterns\n\n\n\nfunction set(values) {\n  var s = {};\n  for (var i in values) {\n    if (!Object.prototype.hasOwnProperty.call(values, i)) continue;\n    s[values[i]] = 1;\n  }\n  return s;\n}\n\n// Construct a segment bound to a variable, e.g., from a segment like\n// \"Len:32/unsigned-big\". `specifiers0` is an array.\nfunction variable(name, size, specifiers0) {\n  var specifiers = set(specifiers0);\n  var segment = {name: name};\n  segment.type = type_in(specifiers);\n  specs(segment, segment.type, specifiers);\n  segment.size = size_of(segment, segment.type, size, segment.unit);\n  return segment;\n}\n\nmodule.exports.variable = variable;\nmodule.exports.rest = function() {\n  return variable('_', true, ['binary']);\n}\n\n// Construct a segment with a literal value, e.g., from a segment like\n// \"206\". `specifiers0` is an array.\n\nfunction value(val, size, specifiers0) {\n  var specifiers = set(specifiers0);\n  var segment = {value: val};\n  segment.type = type_in(specifiers);\n  // TODO check type v. value ..\n  specs(segment, segment.type, specifiers);\n  segment.size = size_of(segment, segment.type, size, segment.unit);\n  return segment;\n}\n\nmodule.exports.value = value;\n\n// A string can appear as a literal, but it must appear without\n// specifiers.\nfunction string(val) {\n  return {value: val, type: 'string'};\n}\nmodule.exports.string = string;\n\nvar TYPES = {'integer': 1, 'binary': 1, 'float': 1};\nfunction type_in(specifiers) {\n  for (var t in specifiers) {\n    if (!Object.prototype.hasOwnProperty.call(specifiers, t)) continue;\n    if (TYPES[t]) { return t; }\n  }\n  return 'integer';\n}\n\nfunction specs(segment, type, specifiers) {\n  switch (type) {\n  case 'integer':\n    segment.signed = signed_in(specifiers);\n    // fall through\n  case 'float':\n    segment.bigendian = endian_in(specifiers);\n    // fall through\n  default:\n    segment.unit = unit_in(specifiers, segment.type);\n  }\n  return segment;\n}\n\nfunction endian_in(specifiers) {\n  // default is big, but I have chosen true = bigendian\n  return !specifiers['little'];\n}\n\nfunction signed_in(specifiers) {\n  // this time I got it right; default is unsigned\n  return specifiers['signed'];\n}\n\nfunction unit_in(specifiers, type) {\n  for (var s in specifiers) {\n    if (!Object.prototype.hasOwnProperty.call(specifiers, s)) continue;\n    if (s.substr(0, 5) == 'unit:') {\n      var unit = parseInt(s.substr(5));\n      // TODO check sane for type\n      return unit;\n    }\n  }\n  // OK defaults then\n  switch (type) {\n  case 'binary':\n    return 8;\n  case 'integer':\n  case 'float':\n    return 1;\n  }\n}\n\nfunction size_of(segment, type, size, unit) {\n  if (size !== undefined && size !== '') {\n    return size;\n  }\n  else {\n    switch (type) {\n    case 'integer':\n      return 8;\n    case 'float':\n      return 64;\n    case 'binary':\n      return true;\n    }\n  }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL3BhdHRlcm4uanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFDQTs7QUFFYTs7QUFFYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsdUJBQXVCO0FBQ3ZCLG1CQUFtQjtBQUNuQjtBQUNBOztBQUVBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUEsb0JBQW9COztBQUVwQjtBQUNBO0FBQ0E7QUFDQSxVQUFVO0FBQ1Y7QUFDQSxxQkFBcUI7O0FBRXJCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsK0JBQStCO0FBQy9CO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSIsInNvdXJjZXMiOlsid2VicGFjazovL3dlYjIvLi9ub2RlX21vZHVsZXMvQGFjdW1pbm91cy9iaXRzeW50YXgvbGliL3BhdHRlcm4uanM/NGVjOCJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyAtKi0ganMtaW5kZW50LWxldmVsOiAyIC0qLVxuLy8gQ29uc3RydWN0aW5nIHBhdHRlcm5zXG5cbid1c2Ugc3RyaWN0JztcblxuZnVuY3Rpb24gc2V0KHZhbHVlcykge1xuICB2YXIgcyA9IHt9O1xuICBmb3IgKHZhciBpIGluIHZhbHVlcykge1xuICAgIGlmICghT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHZhbHVlcywgaSkpIGNvbnRpbnVlO1xuICAgIHNbdmFsdWVzW2ldXSA9IDE7XG4gIH1cbiAgcmV0dXJuIHM7XG59XG5cbi8vIENvbnN0cnVjdCBhIHNlZ21lbnQgYm91bmQgdG8gYSB2YXJpYWJsZSwgZS5nLiwgZnJvbSBhIHNlZ21lbnQgbGlrZVxuLy8gXCJMZW46MzIvdW5zaWduZWQtYmlnXCIuIGBzcGVjaWZpZXJzMGAgaXMgYW4gYXJyYXkuXG5mdW5jdGlvbiB2YXJpYWJsZShuYW1lLCBzaXplLCBzcGVjaWZpZXJzMCkge1xuICB2YXIgc3BlY2lmaWVycyA9IHNldChzcGVjaWZpZXJzMCk7XG4gIHZhciBzZWdtZW50ID0ge25hbWU6IG5hbWV9O1xuICBzZWdtZW50LnR5cGUgPSB0eXBlX2luKHNwZWNpZmllcnMpO1xuICBzcGVjcyhzZWdtZW50LCBzZWdtZW50LnR5cGUsIHNwZWNpZmllcnMpO1xuICBzZWdtZW50LnNpemUgPSBzaXplX29mKHNlZ21lbnQsIHNlZ21lbnQudHlwZSwgc2l6ZSwgc2VnbWVudC51bml0KTtcbiAgcmV0dXJuIHNlZ21lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzLnZhcmlhYmxlID0gdmFyaWFibGU7XG5tb2R1bGUuZXhwb3J0cy5yZXN0ID0gZnVuY3Rpb24oKSB7XG4gIHJldHVybiB2YXJpYWJsZSgnXycsIHRydWUsIFsnYmluYXJ5J10pO1xufVxuXG4vLyBDb25zdHJ1Y3QgYSBzZWdtZW50IHdpdGggYSBsaXRlcmFsIHZhbHVlLCBlLmcuLCBmcm9tIGEgc2VnbWVudCBsaWtlXG4vLyBcIjIwNlwiLiBgc3BlY2lmaWVyczBgIGlzIGFuIGFycmF5LlxuXG5mdW5jdGlvbiB2YWx1ZSh2YWwsIHNpemUsIHNwZWNpZmllcnMwKSB7XG4gIHZhciBzcGVjaWZpZXJzID0gc2V0KHNwZWNpZmllcnMwKTtcbiAgdmFyIHNlZ21lbnQgPSB7dmFsdWU6IHZhbH07XG4gIHNlZ21lbnQudHlwZSA9IHR5cGVfaW4oc3BlY2lmaWVycyk7XG4gIC8vIFRPRE8gY2hlY2sgdHlwZSB2LiB2YWx1ZSAuLlxuICBzcGVjcyhzZWdtZW50LCBzZWdtZW50LnR5cGUsIHNwZWNpZmllcnMpO1xuICBzZWdtZW50LnNpemUgPSBzaXplX29mKHNlZ21lbnQsIHNlZ21lbnQudHlwZSwgc2l6ZSwgc2VnbWVudC51bml0KTtcbiAgcmV0dXJuIHNlZ21lbnQ7XG59XG5cbm1vZHVsZS5leHBvcnRzLnZhbHVlID0gdmFsdWU7XG5cbi8vIEEgc3RyaW5nIGNhbiBhcHBlYXIgYXMgYSBsaXRlcmFsLCBidXQgaXQgbXVzdCBhcHBlYXIgd2l0aG91dFxuLy8gc3BlY2lmaWVycy5cbmZ1bmN0aW9uIHN0cmluZyh2YWwpIHtcbiAgcmV0dXJuIHt2YWx1ZTogdmFsLCB0eXBlOiAnc3RyaW5nJ307XG59XG5tb2R1bGUuZXhwb3J0cy5zdHJpbmcgPSBzdHJpbmc7XG5cbnZhciBUWVBFUyA9IHsnaW50ZWdlcic6IDEsICdiaW5hcnknOiAxLCAnZmxvYXQnOiAxfTtcbmZ1bmN0aW9uIHR5cGVfaW4oc3BlY2lmaWVycykge1xuICBmb3IgKHZhciB0IGluIHNwZWNpZmllcnMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcGVjaWZpZXJzLCB0KSkgY29udGludWU7XG4gICAgaWYgKFRZUEVTW3RdKSB7IHJldHVybiB0OyB9XG4gIH1cbiAgcmV0dXJuICdpbnRlZ2VyJztcbn1cblxuZnVuY3Rpb24gc3BlY3Moc2VnbWVudCwgdHlwZSwgc3BlY2lmaWVycykge1xuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnaW50ZWdlcic6XG4gICAgc2VnbWVudC5zaWduZWQgPSBzaWduZWRfaW4oc3BlY2lmaWVycyk7XG4gICAgLy8gZmFsbCB0aHJvdWdoXG4gIGNhc2UgJ2Zsb2F0JzpcbiAgICBzZWdtZW50LmJpZ2VuZGlhbiA9IGVuZGlhbl9pbihzcGVjaWZpZXJzKTtcbiAgICAvLyBmYWxsIHRocm91Z2hcbiAgZGVmYXVsdDpcbiAgICBzZWdtZW50LnVuaXQgPSB1bml0X2luKHNwZWNpZmllcnMsIHNlZ21lbnQudHlwZSk7XG4gIH1cbiAgcmV0dXJuIHNlZ21lbnQ7XG59XG5cbmZ1bmN0aW9uIGVuZGlhbl9pbihzcGVjaWZpZXJzKSB7XG4gIC8vIGRlZmF1bHQgaXMgYmlnLCBidXQgSSBoYXZlIGNob3NlbiB0cnVlID0gYmlnZW5kaWFuXG4gIHJldHVybiAhc3BlY2lmaWVyc1snbGl0dGxlJ107XG59XG5cbmZ1bmN0aW9uIHNpZ25lZF9pbihzcGVjaWZpZXJzKSB7XG4gIC8vIHRoaXMgdGltZSBJIGdvdCBpdCByaWdodDsgZGVmYXVsdCBpcyB1bnNpZ25lZFxuICByZXR1cm4gc3BlY2lmaWVyc1snc2lnbmVkJ107XG59XG5cbmZ1bmN0aW9uIHVuaXRfaW4oc3BlY2lmaWVycywgdHlwZSkge1xuICBmb3IgKHZhciBzIGluIHNwZWNpZmllcnMpIHtcbiAgICBpZiAoIU9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzcGVjaWZpZXJzLCBzKSkgY29udGludWU7XG4gICAgaWYgKHMuc3Vic3RyKDAsIDUpID09ICd1bml0OicpIHtcbiAgICAgIHZhciB1bml0ID0gcGFyc2VJbnQocy5zdWJzdHIoNSkpO1xuICAgICAgLy8gVE9ETyBjaGVjayBzYW5lIGZvciB0eXBlXG4gICAgICByZXR1cm4gdW5pdDtcbiAgICB9XG4gIH1cbiAgLy8gT0sgZGVmYXVsdHMgdGhlblxuICBzd2l0Y2ggKHR5cGUpIHtcbiAgY2FzZSAnYmluYXJ5JzpcbiAgICByZXR1cm4gODtcbiAgY2FzZSAnaW50ZWdlcic6XG4gIGNhc2UgJ2Zsb2F0JzpcbiAgICByZXR1cm4gMTtcbiAgfVxufVxuXG5mdW5jdGlvbiBzaXplX29mKHNlZ21lbnQsIHR5cGUsIHNpemUsIHVuaXQpIHtcbiAgaWYgKHNpemUgIT09IHVuZGVmaW5lZCAmJiBzaXplICE9PSAnJykge1xuICAgIHJldHVybiBzaXplO1xuICB9XG4gIGVsc2Uge1xuICAgIHN3aXRjaCAodHlwZSkge1xuICAgIGNhc2UgJ2ludGVnZXInOlxuICAgICAgcmV0dXJuIDg7XG4gICAgY2FzZSAnZmxvYXQnOlxuICAgICAgcmV0dXJuIDY0O1xuICAgIGNhc2UgJ2JpbmFyeSc6XG4gICAgICByZXR1cm4gdHJ1ZTtcbiAgICB9XG4gIH1cbn1cbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/@acuminous/bitsyntax/lib/pattern.js\n");

/***/ })

};
;